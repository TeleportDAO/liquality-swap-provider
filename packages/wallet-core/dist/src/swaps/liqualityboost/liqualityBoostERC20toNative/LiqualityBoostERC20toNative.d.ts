import BN from 'bignumber.js';
import { ActionContext } from '../../../store';
import { Asset, Network, SwapProviderType } from '../../../store/types';
import { SwapProvider } from '../../SwapProvider';
import { EstimateFeeRequest, EstimateFeeResponse, LiqualityBoostSwapProviderConfig, NextSwapActionRequest, QuoteRequest, SwapQuote, SwapRequest, SwapStatus } from '../../types';
import { BoostHistoryItem, BoostNextSwapActionRequest } from '../types';
export interface BoostNativeERC20toNativeSwapQuote extends SwapQuote {
    fromTokenAddress: string;
}
declare class LiqualityBoostERC20toNative extends SwapProvider {
    private liqualitySwapProvider;
    private sovrynSwapProvider;
    private oneinchSwapProvider;
    private astroportSwapProvider;
    private lspEndStates;
    config: LiqualityBoostSwapProviderConfig;
    bridgeAssetToAutomatedMarketMaker: {
        [key: string]: SwapProvider;
    };
    supportedBridgeAssets: Asset[];
    constructor(config: LiqualityBoostSwapProviderConfig);
    getSupportedPairs(): Promise<never[]>;
    getQuote({ network, from, to, amount }: QuoteRequest): Promise<{
        from: string;
        to: string;
        fromAmount: string;
        toAmount: string;
        minInBridgeAsset: BN;
        maxInBridgeAsset: BN;
        bridgeAsset: string;
        bridgeAssetAmount: string;
        path: string[] | null | undefined;
        fromTokenAddress: string;
    } | null>;
    newSwap({ network, walletId, quote: _quote }: SwapRequest<BoostHistoryItem>): Promise<{
        slippage: number;
        approveTxHash: string;
        swapTxHash: string;
        approveTx: import("@chainify/types").Transaction<import("@ethersproject/abstract-provider").TransactionResponse>;
        swapTx: import("@chainify/types").Transaction<import("@ethersproject/abstract-provider").TransactionResponse>;
        bridgeAsset: string;
        bridgeAssetAmount: string;
        orderId: string;
        fromAddress: string;
        toAddress: string;
        fromCounterPartyAddress: string;
        toCounterPartyAddress: string;
        secretHash: string;
        secret: string;
        expiresAt: number;
        swapExpiration: number;
        nodeSwapExpiration: number;
        fromFundHash: string;
        fromFundTx: import("@chainify/types").Transaction<any>;
        refundTx: import("@chainify/types").Transaction<any>;
        refundHash: string;
        toClaimTx: import("@chainify/types").Transaction<any>;
        toClaimHash: string;
        toFundHash: string;
        type: import("../../../store/types").TransactionType.Swap;
        claimFeeLabel: import("../../../store/types").FeeLabel;
        claimFee: number;
        fromAmount: string;
        fromAccountId: string;
        provider: SwapProviderType;
        toAccountId: string;
        toAmount: string;
        path?: string[] | undefined;
        lifiRoute?: import("@lifi/types").Step | undefined;
        swapProviderError?: import("../../types").SwapProviderError | undefined;
        fee: number;
        feeLabel: import("../../../store/types").FeeLabel;
        from: string;
        id: string;
        network: Network;
        startTime: number;
        endTime?: number | undefined;
        status: string;
        to: string;
        walletId: string;
        error?: import("@chainify/types").Nullable<string> | undefined;
        waitingForLock?: boolean | undefined;
    }>;
    updateOrder(order: BoostHistoryItem): Promise<any>;
    estimateFees({ network, walletId, asset, txType, quote, feePrices, max, }: EstimateFeeRequest<string, BoostHistoryItem>): Promise<EstimateFeeResponse | null>;
    getMin(quoteRequest: QuoteRequest): Promise<BN>;
    finalizeAutomatedMarketMakerAndStartLiqualitySwap({ swapLSP, swapAMM, network, walletId, }: BoostNextSwapActionRequest): Promise<{
        toAmount: string;
        status: string;
        orderId: string;
        fromAddress: string;
        toAddress: string;
        fromCounterPartyAddress: string;
        toCounterPartyAddress: string;
        secretHash: string;
        secret: string;
        expiresAt: number;
        swapExpiration: number;
        nodeSwapExpiration: number;
        fromFundHash: string;
        fromFundTx: import("@chainify/types").Transaction<any>;
        refundTx: import("@chainify/types").Transaction<any>;
        refundHash: string;
        toClaimTx: import("@chainify/types").Transaction<any>;
        toClaimHash: string;
        toFundHash: string;
        approveTxHash: string;
        approveTx: import("@chainify/types").Transaction<import("@ethersproject/abstract-provider").TransactionResponse>;
        type: import("../../../store/types").TransactionType.Swap;
        claimFeeLabel: import("../../../store/types").FeeLabel;
        claimFee: number;
        fromAmount: string;
        fromAccountId: string;
        provider: SwapProviderType;
        slippage: number;
        toAccountId: string;
        bridgeAsset?: string | undefined;
        path?: string[] | undefined;
        lifiRoute?: import("@lifi/types").Step | undefined;
        swapProviderError?: import("../../types").SwapProviderError | undefined;
        fee: number;
        feeLabel: import("../../../store/types").FeeLabel;
        from: string;
        id: string;
        network: Network;
        startTime: number;
        endTime?: number | undefined;
        to: string;
        walletId: string;
        error?: import("@chainify/types").Nullable<string> | undefined;
        waitingForLock?: boolean | undefined;
    } | undefined>;
    performNextSwapAction(store: ActionContext, { network, walletId, swap }: NextSwapActionRequest<BoostHistoryItem>): Promise<{
        from: string;
        fromAmount: string;
        to: string;
        toAmount: string | undefined;
        type?: import("../../../store/types").TransactionType.Swap | undefined;
        claimFeeLabel?: import("../../../store/types").FeeLabel | undefined;
        claimFee?: number | undefined;
        fromAccountId?: string | undefined;
        provider?: SwapProviderType | undefined;
        slippage?: number | undefined;
        toAccountId?: string | undefined;
        bridgeAsset?: string | undefined;
        path?: string[] | undefined;
        lifiRoute?: import("@lifi/types").Step | undefined;
        swapProviderError?: import("../../types").SwapProviderError | undefined;
        fee?: number | undefined;
        feeLabel?: import("../../../store/types").FeeLabel | undefined;
        id?: string | undefined;
        network?: Network | undefined;
        startTime?: number | undefined;
        endTime?: number | undefined;
        status?: string | undefined;
        walletId?: string | undefined;
        error?: import("@chainify/types").Nullable<string> | undefined;
        waitingForLock?: boolean | undefined;
    } | undefined>;
    protected _getStatuses(): Record<string, SwapStatus>;
    protected _txTypes(): Record<string, string | null>;
    protected _fromTxType(): string | null;
    protected _toTxType(): string | null;
    protected _timelineDiagramSteps(): string[];
    protected _totalSteps(): number;
    private swapLiqualityFormat;
    private swapAutomatedMarketMakerFormat;
}
export { LiqualityBoostERC20toNative };

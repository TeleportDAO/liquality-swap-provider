"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32 = exports.base58 = exports.padHexStart = exports.isHex = exports.sha256 = exports.hash160 = exports.ensureBuffer = void 0;
const sha2_1 = require("@ethersproject/sha2");
const bech32_1 = __importDefault(require("bech32"));
exports.bech32 = bech32_1.default;
const bs58_1 = __importDefault(require("bs58"));
exports.base58 = bs58_1.default;
const crypto_hashing_1 = __importDefault(require("crypto-hashing"));
const hex_1 = require("./hex");
/**
 * Ensure message is in buffer format.
 * @param message - any string.
 * @returns Buffer.
 */
function ensureBuffer(message) {
    if (Buffer.isBuffer(message))
        return message;
    switch (typeof message) {
        case 'string':
            message = isHex(message) ? Buffer.from(message, 'hex') : Buffer.from(message);
            break;
        case 'object':
            message = Buffer.from(JSON.stringify(message));
            break;
    }
    return Buffer.isBuffer(message) ? message : false;
}
exports.ensureBuffer = ensureBuffer;
/**
 * Get hash160 of message.
 * @param message - message in string or Buffer.
 * @returns the hash160 of a string.
 */
function hash160(message) {
    return (0, crypto_hashing_1.default)('hash160', ensureBuffer(message)).toString('hex');
}
exports.hash160 = hash160;
function sha256(data) {
    return (0, hex_1.remove0x)((0, sha2_1.sha256)((0, hex_1.ensure0x)(data)));
}
exports.sha256 = sha256;
function isHex(hex) {
    if (!hex.match(/([0-9]|[a-f])/gim))
        return false;
    const buf = Buffer.from(hex, 'hex').toString('hex');
    return buf === hex.toLowerCase();
}
exports.isHex = isHex;
/**
 * Pad a hex string with '0'
 * @param hex - The hex string to pad.
 * @param  lengthBytes - The length of the final string in bytes
 * @returns a padded string with length greater or equal to the given length
 *  rounded up to the nearest even number.
 */
function padHexStart(hex, lengthBytes) {
    let lengthString = lengthBytes * 2 || hex.length;
    lengthString += lengthString % 2;
    return hex.padStart(lengthString, '0');
}
exports.padHexStart = padHexStart;
//# sourceMappingURL=crypto.js.map
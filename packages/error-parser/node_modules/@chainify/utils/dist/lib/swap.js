"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateValue = exports.validateSecretAndHash = exports.validateSecretHash = exports.validateSecret = exports.validateExpiration = void 0;
const errors_1 = require("@chainify/errors");
const crypto_1 = require("./crypto");
const hex_1 = require("./hex");
const math_1 = require("./math");
function validateExpiration(expiration) {
    if (isNaN(expiration)) {
        throw new errors_1.InvalidExpirationError(`Invalid expiration. NaN: ${expiration}`);
    }
    if (expiration < 500000000 || expiration > 5000000000000) {
        throw new errors_1.InvalidExpirationError(`Invalid expiration. Out of bounds: ${expiration}`);
    }
}
exports.validateExpiration = validateExpiration;
function validateSecret(secret) {
    if (typeof secret !== 'string') {
        throw new errors_1.InvalidSecretError(`Invalid secret type`);
    }
    const _secret = (0, hex_1.remove0x)(secret);
    if (Buffer.from(_secret, 'hex').toString('hex') !== _secret) {
        throw new errors_1.InvalidSecretError(`Invalid secret. Not Hex.`);
    }
    const secretBuff = Buffer.from(_secret, 'hex');
    if (secretBuff.length !== 32) {
        throw new errors_1.InvalidSecretError(`Invalid secret size`);
    }
}
exports.validateSecret = validateSecret;
function validateSecretHash(secretHash) {
    if (typeof secretHash !== 'string') {
        throw new errors_1.InvalidSecretError(`Invalid secret hash type`);
    }
    const _secretHash = (0, hex_1.remove0x)(secretHash);
    if ((0, hex_1.remove0x)(Buffer.from(_secretHash, 'hex').toString('hex')) !== (0, hex_1.remove0x)(_secretHash)) {
        throw new errors_1.InvalidSecretError(`Invalid secret hash. Not Hex.`);
    }
    if (Buffer.byteLength(_secretHash, 'hex') !== 32) {
        throw new errors_1.InvalidSecretError(`Invalid secret hash: ${_secretHash}`);
    }
    // sha256('0000000000000000000000000000000000000000000000000000000000000000')
    if ('66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925' === _secretHash) {
        throw new errors_1.InvalidSecretError(`Invalid secret hash: ${_secretHash}. Secret 0 detected.`);
    }
}
exports.validateSecretHash = validateSecretHash;
function validateSecretAndHash(secret, secretHash) {
    validateSecret(secret);
    validateSecretHash(secretHash);
    const computedSecretHash = Buffer.from((0, crypto_1.sha256)(secret), 'hex');
    if (!computedSecretHash.equals(Buffer.from((0, hex_1.remove0x)(secretHash), 'hex'))) {
        throw new errors_1.InvalidSecretError(`Invalid secret: Does not match expected secret hash: ${secretHash}`);
    }
}
exports.validateSecretAndHash = validateSecretAndHash;
function validateValue(value) {
    if ((0, math_1.lte)(value, 0)) {
        throw new errors_1.InvalidValueError(`Invalid value: ${value}`);
    }
}
exports.validateValue = validateValue;
//# sourceMappingURL=swap.js.map
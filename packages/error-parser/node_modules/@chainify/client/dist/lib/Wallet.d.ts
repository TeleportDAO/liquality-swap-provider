import { Address, AddressType, Asset, BigNumber, FeeType, NamingProvider, Network, Transaction, TransactionRequest, WalletProvider } from '@chainify/types';
import Chain from './Chain';
export default abstract class Wallet<T, S> implements WalletProvider {
    protected chainProvider: Chain<T>;
    protected namingProvider: NamingProvider;
    constructor(chainProvider?: Chain<T>, namingProvider?: NamingProvider);
    setChainProvider(chainProvider: Chain<T>): void;
    getChainProvider(): Chain<T>;
    setNamingProvider(namingProvider: NamingProvider): void;
    getNamingProvider(): NamingProvider;
    signTypedData(_data: any): Promise<string>;
    abstract getConnectedNetwork(): Promise<Network>;
    abstract getSigner(): S;
    abstract getAddress(): Promise<AddressType>;
    abstract getUnusedAddress(change?: boolean, numAddressPerCall?: number): Promise<Address>;
    abstract getUsedAddresses(numAddressPerCall?: number): Promise<Address[]>;
    abstract getAddresses(start?: number, numAddresses?: number, change?: boolean): Promise<Address[]>;
    abstract signMessage(message: string, from: AddressType): Promise<string>;
    abstract sendTransaction(txRequest: TransactionRequest): Promise<Transaction>;
    abstract sendBatchTransaction(txRequests: TransactionRequest[]): Promise<Transaction[]>;
    abstract sendSweepTransaction(address: AddressType, asset: Asset, fee?: FeeType): Promise<Transaction>;
    abstract updateTransactionFee(tx: string | Transaction, newFee: FeeType): Promise<Transaction>;
    abstract getBalance(assets: Asset[]): Promise<BigNumber[]>;
    abstract exportPrivateKey(): Promise<string>;
    abstract isWalletAvailable(): Promise<boolean>;
    abstract canUpdateFee(): boolean;
    protected abstract onChainProviderUpdate(chainProvider: Chain<T>): void;
}

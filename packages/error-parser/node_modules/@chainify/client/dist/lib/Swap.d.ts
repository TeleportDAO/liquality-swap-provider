import { FeeType, SwapParams, SwapProvider, Transaction } from '@chainify/types';
import Wallet from './Wallet';
export default abstract class Swap<T, S, WalletProvider extends Wallet<T, S> = Wallet<T, S>> implements SwapProvider {
    protected walletProvider: WalletProvider;
    constructor(walletProvider?: WalletProvider);
    setWallet(wallet: WalletProvider): void;
    getWallet(): WalletProvider;
    verifyInitiateSwapTransaction(swapParams: SwapParams, initTx: string | Transaction): Promise<boolean>;
    validateSwapParams(swapParams: SwapParams): void;
    generateSecret(message: string): Promise<string>;
    abstract initiateSwap(swapParams: SwapParams, fee?: FeeType): Promise<Transaction>;
    abstract findInitiateSwapTransaction(swapParams: SwapParams, _blockNumber?: number): Promise<Transaction>;
    abstract claimSwap(swapParams: SwapParams, initTx: string, secret: string, fee?: FeeType): Promise<Transaction>;
    abstract findClaimSwapTransaction(swapParams: SwapParams, initTxHash: string, blockNumber?: number): Promise<Transaction>;
    abstract refundSwap(swapParams: SwapParams, initTx: string, fee?: FeeType): Promise<Transaction>;
    abstract findRefundSwapTransaction(swapParams: SwapParams, initiationTxHash: string, blockNumber?: number): Promise<Transaction>;
    abstract getSwapSecret(claimTxHash: string, initTxHash?: string): Promise<string>;
    abstract canUpdateFee(): boolean;
    abstract updateTransactionFee(tx: string | Transaction, newFee: FeeType): Promise<Transaction>;
    protected abstract doesTransactionMatchInitiation(swapParams: SwapParams, transaction: Transaction): Promise<boolean> | boolean;
    protected abstract onWalletProviderUpdate(wallet: WalletProvider): void;
}

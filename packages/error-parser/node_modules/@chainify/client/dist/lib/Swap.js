"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
class Swap {
    constructor(walletProvider) {
        this.walletProvider = walletProvider;
    }
    setWallet(wallet) {
        this.walletProvider = wallet;
        this.onWalletProviderUpdate(wallet);
    }
    getWallet() {
        return this.walletProvider;
    }
    verifyInitiateSwapTransaction(swapParams, initTx) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            const transaction = typeof initTx === 'string' ? yield this.walletProvider.getChainProvider().getTransactionByHash(initTx) : initTx;
            if (!transaction) {
                throw new errors_1.TxNotFoundError(`Transaction not found: ${initTx}`);
            }
            const doesMatch = yield this.doesTransactionMatchInitiation(swapParams, transaction);
            if (!(transaction.confirmations > 0)) {
                throw new errors_1.PendingTxError(`Transaction not confirmed ${transaction.confirmations}`);
            }
            if (transaction.status !== types_1.TxStatus.Success) {
                throw new errors_1.TxFailedError('Transaction not successful');
            }
            if (!doesMatch) {
                throw new errors_1.InvalidSwapParamsError(`Swap params does not match the transaction`);
            }
            return true;
        });
    }
    validateSwapParams(swapParams) {
        (0, utils_1.validateValue)(swapParams.value);
        (0, utils_1.validateSecretHash)(swapParams.secretHash);
        (0, utils_1.validateExpiration)(swapParams.expiration);
    }
    generateSecret(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.walletProvider.getAddress();
            const signedMessage = yield this.walletProvider.signMessage(message, address);
            const secret = (0, utils_1.sha256)(signedMessage);
            return secret;
        });
    }
}
exports.default = Swap;
//# sourceMappingURL=Swap.js.map
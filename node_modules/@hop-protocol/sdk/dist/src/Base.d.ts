import { Addresses } from '@hop-protocol/core/addresses';
import { ArbERC20 } from '@hop-protocol/core/contracts/ArbERC20';
import { ArbERC20__factory } from '@hop-protocol/core/contracts/factories/ArbERC20__factory';
import { ArbitrumGlobalInbox } from '@hop-protocol/core/contracts/ArbitrumGlobalInbox';
import { ArbitrumGlobalInbox__factory } from '@hop-protocol/core/contracts/factories/ArbitrumGlobalInbox__factory';
import { BigNumber, BigNumberish, Signer, providers } from 'ethers';
import { Chain, Token as TokenModel } from './models';
import { ChainSlug, NetworkSlug } from './constants';
import { L1OptimismTokenBridge } from '@hop-protocol/core/contracts/L1OptimismTokenBridge';
import { L1OptimismTokenBridge__factory } from '@hop-protocol/core/contracts/factories/L1OptimismTokenBridge__factory';
import { L1PolygonPosRootChainManager } from '@hop-protocol/core/contracts/L1PolygonPosRootChainManager';
import { L1PolygonPosRootChainManager__factory } from '@hop-protocol/core/contracts/factories/L1PolygonPosRootChainManager__factory';
import { L1XDaiForeignOmniBridge } from '@hop-protocol/core/contracts/L1XDaiForeignOmniBridge';
import { L1XDaiForeignOmniBridge__factory } from '@hop-protocol/core/contracts/factories/L1XDaiForeignOmniBridge__factory';
import { L2OptimismTokenBridge } from '@hop-protocol/core/contracts/L2OptimismTokenBridge';
import { L2OptimismTokenBridge__factory } from '@hop-protocol/core/contracts/factories/L2OptimismTokenBridge__factory';
import { L2PolygonChildERC20 } from '@hop-protocol/core/contracts/L2PolygonChildERC20';
import { L2PolygonChildERC20__factory } from '@hop-protocol/core/contracts/factories/L2PolygonChildERC20__factory';
import { L2XDaiToken } from '@hop-protocol/core/contracts/L2XDaiToken';
import { L2XDaiToken__factory } from '@hop-protocol/core/contracts/factories/L2XDaiToken__factory';
import { TChain, TProvider, TToken } from './types';
export declare type L1Factory = L1PolygonPosRootChainManager__factory | L1XDaiForeignOmniBridge__factory | ArbitrumGlobalInbox__factory | L1OptimismTokenBridge__factory;
export declare type L1Contract = L1PolygonPosRootChainManager | L1XDaiForeignOmniBridge | ArbitrumGlobalInbox | L1OptimismTokenBridge;
export declare type L2Factory = L2PolygonChildERC20__factory | L2XDaiToken__factory | ArbERC20__factory | L2OptimismTokenBridge__factory;
export declare type L2Contract = L2PolygonChildERC20 | L2XDaiToken | ArbERC20 | L2OptimismTokenBridge;
declare type Factory = L1Factory | L2Factory;
export declare type ChainProviders = {
    [slug in ChainSlug | string]: providers.Provider;
};
/**
 * Class with base methods.
 * @namespace Base
 */
declare class Base {
    /** Network name */
    network: NetworkSlug | string;
    /** Ethers signer or provider */
    signer: TProvider;
    chainProviders: ChainProviders;
    private addresses;
    private chains;
    private bonders;
    fees: {
        [token: string]: Record<string, number>;
    };
    gasPriceMultiplier: number;
    destinationFeeGasPriceMultiplier: number;
    /**
     * @desc Instantiates Base class.
     * Returns a new Base class instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @returns {Object} New Base class instance.
     */
    constructor(network: NetworkSlug | string, signer: TProvider, chainProviders?: ChainProviders);
    init(): Promise<void>;
    sendTransaction(transactionRequest: providers.TransactionRequest, chain: TChain): Promise<providers.TransactionResponse>;
    setConfigAddresses(addresses: Addresses): void;
    setChainProvider(chain: TChain, provider: providers.Provider): void;
    setChainProviders(chainProviders: ChainProviders): void;
    setChainProviderUrls(chainProviders: Record<string, string>): void;
    get supportedNetworks(): string[];
    isValidNetwork(network: string): boolean;
    get supportedChains(): string[];
    isValidChain(chain: string): boolean;
    /**
     * @desc Returns a Chain model instance with connected provider.
     * @param {Object} - Chain name or model.
     * @returns {Object} - Chain model with connected provider.
     */
    toChainModel(chain: TChain): Chain;
    /**
     * @desc Returns a Token instance.
     * @param {Object} - Token name or model.
     * @returns {Object} - Token model.
     */
    toTokenModel(token: TToken): TokenModel;
    /**
     * @desc Calculates current gas price plus increased percentage amount.
     * @param {Object} - Ether's Signer
     * @param {number} - Percentage to bump by.
     * @returns {BigNumber} Bumped as price as BigNumber
     * @example
     *```js
     *import { Hop } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bumpedGasPrice = await hop.getBumpedGasPrice(signer, 1.20)
     *console.log(bumpedGasPrice.toNumber())
     *```
     */
    getBumpedGasPrice(signer: TProvider, percent: number): Promise<BigNumber>;
    /**
     * @desc Returns Chain ID for specified Chain model.
     * @param {Object} - Chain model.
     * @returns {Number} - Chain ID.
     */
    getChainId(chain: Chain): number;
    /**
     * @desc Returns Ethers provider for specified Chain model.
     * @param {Object} - Chain model.
     * @returns {Object} - Ethers provider.
     */
    getChainProvider(chain: Chain | string): providers.Provider;
    getChainProviders: () => Record<string, providers.Provider>;
    getChainProviderUrls: () => Record<string, string>;
    /**
     * @desc Returns the connected signer address.
     * @returns {String} Ethers signer address.
     * @example
     *```js
     *import { Hop } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const address = await hop.getSignerAddress()
     *console.log(address)
     *```
     */
    getSignerAddress(): Promise<string>;
    /**
     * @desc Returns the connected signer if it's connected to the specified
     * chain id, otherwise it returns a regular provider for the specified chain.
     * @param {Object} chain - Chain name or model
     * @param {Object} signer - Ethers signer or provider
     * @returns {Object} Ethers signer or provider
     */
    getSignerOrProvider(chain: TChain, signer?: TProvider): Promise<Signer | providers.Provider>;
    getConfigAddresses(token: TToken, chain: TChain): any;
    getL1BridgeAddress(token: TToken, chain: TChain): any;
    getL2BridgeAddress(token: TToken, chain: TChain): any;
    getL1CanonicalBridgeAddress(token: TToken, chain: TChain): any;
    getL2CanonicalBridgeAddress(token: TToken, chain: TChain): any;
    getL1CanonicalTokenAddress(token: TToken, chain: TChain): any;
    getL2CanonicalTokenAddress(token: TToken, chain: TChain): any;
    getL2HopBridgeTokenAddress(token: TToken, chain: TChain): any;
    getL2AmmWrapperAddress(token: TToken, chain: TChain): any;
    getL2SaddleSwapAddress(token: TToken, chain: TChain): any;
    getL2SaddleLpTokenAddress(token: TToken, chain: TChain): any;
    getArbChainAddress(token: TToken, chain: TChain): any;
    getL1AmbBridgeAddress(token: TToken, chain: TChain): any;
    getL2AmbBridgeAddress(token: TToken, chain: TChain): any;
    getL1PosRootChainManagerAddress(token: TToken, chain: TChain): any;
    getL1PosErc20PredicateAddress(token: TToken, chain: TChain): any;
    txOverrides(chain: Chain): Promise<any>;
    protected _getBonderAddress(token: TToken, sourceChain: TChain, destinationChain: TChain): string;
    getFeeBps(token: TToken, destinationChain: TChain): number;
    setGasPriceMultiplier(gasPriceMultiplier: number): number;
    getS3ConfigData(): Promise<any>;
    getContract: (factory: Factory, address: string, provider: TProvider) => Promise<any>;
    getSupportedAssets(): any;
    getSupportedAssetsForChain(chain: TChain): any;
    estimateOptimismL1FeeFromData(gasLimit: BigNumberish, data?: string, to?: string): Promise<any>;
}
export default Base;
//# sourceMappingURL=Base.d.ts.map
import AMM from './AMM';
import Base, { ChainProviders } from './Base';
import Chain from './models/Chain';
import Token from './Token';
import TokenModel from './models/Token';
import { L2Bridge } from '@hop-protocol/core/contracts/L2Bridge';
import { BigNumber, BigNumberish, Signer, ethers } from 'ethers';
import { PriceFeed } from './priceFeed';
import { TAmount, TChain, TProvider, TTime, TTimeSlot, TToken } from './types';
declare type SendOptions = {
    deadline: BigNumberish;
    relayer: string;
    relayerFee: TAmount;
    recipient: string;
    amountOutMin: TAmount;
    bonderFee: TAmount;
    destinationAmountOutMin: TAmount;
    destinationDeadline: BigNumberish;
    checkAllowance?: boolean;
};
declare type AddLiquidityOptions = {
    minToMint: TAmount;
    deadline: BigNumberish;
};
declare type RemoveLiquidityOptions = {
    amount0Min: TAmount;
    amount1Min: TAmount;
    deadline: BigNumberish;
};
declare type RemoveLiquidityOneTokenOptions = {
    amountMin: TAmount;
    deadline: BigNumberish;
};
declare type RemoveLiquidityImbalanceOptions = {
    maxBurnAmount: TAmount;
    deadline: BigNumberish;
};
/**
 * Class representing Hop bridge.
 * @namespace HopBridge
 */
declare class HopBridge extends Base {
    private tokenSymbol;
    /** Source Chain model */
    sourceChain: Chain;
    /** Destination Chain model */
    destinationChain: Chain;
    /** Default deadline for transfers */
    defaultDeadlineMinutes: number;
    readonly priceFeed: PriceFeed;
    /**
     * @desc Instantiates Hop Bridge.
     * Returns a new Hop Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} sourceChain - Source chain model
     * @param {Object} destinationChain - Destination chain model
     * @returns {Object} HopBridge SDK instance.
     * @example
     *```js
     *import { HopBridge, Chain, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new HopBridge('kovan', signer, Token.USDC, Chain.Optimism, Chain.Gnosis)
     *```
     */
    constructor(network: string, signer: TProvider, token: TToken, chainProviders?: ChainProviders);
    /**
     * @desc Returns hop bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New HopBridge SDK instance with connected signer.
     * @example
     *```js
     *import { Hop, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *let hop = new Hop()
     * // ...
     *const bridge = hop.bridge(Token.USDC).connect(signer)
     *```
     */
    connect(signer: Signer): HopBridge;
    getL1Token(): Token;
    getCanonicalToken(chain: TChain): Token;
    getL2HopToken(chain: TChain): Token;
    toCanonicalToken(token: TToken, network: string, chain: TChain): Token;
    toHopToken(token: TToken, network: string, chain: TChain): Token;
    /**
     * @desc Send tokens to another chain.
     * @param {String} tokenAmount - Token amount to send denominated in smallest unit.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain, Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *\// send 1 USDC token from Optimism -> Gnosis
     *const tx = await bridge.send('1000000000000000000', Chain.Optimism, Chain.Gnosis)
     *console.log(tx.hash)
     *```
     */
    send(tokenAmount: TAmount, sourceChain?: TChain, destinationChain?: TChain, options?: Partial<SendOptions>): Promise<ethers.providers.TransactionResponse>;
    populateSendTx(tokenAmount: TAmount, sourceChain?: TChain, destinationChain?: TChain, options?: Partial<SendOptions>): Promise<any>;
    estimateSendGasLimit(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, options?: Partial<SendOptions>): Promise<BigNumber>;
    private getEstimatedGasLimit;
    getSendEstimatedGasCost(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, options?: Partial<SendOptions>): Promise<BigNumber>;
    getSendApprovalAddress(sourceChain: TChain, isHTokenTransfer?: boolean): any;
    populateSendApprovalTx(tokenAmount: TAmount, sourceChain: TChain, isHTokenTransfer?: boolean): Promise<any>;
    sendApproval(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, isHTokenTransfer?: boolean): Promise<ethers.providers.TransactionResponse>;
    sendHToken(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, options?: Partial<SendOptions>): Promise<ethers.providers.TransactionResponse>;
    estimateSendHTokensGasLimit(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, options?: Partial<SendOptions>): Promise<BigNumber>;
    populateSendHTokensTx(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, options?: Partial<SendOptions>): Promise<any>;
    getTokenSymbol(): string;
    getTokenImage(): string;
    getSendData(amountIn: BigNumberish, sourceChain: TChain, destinationChain: TChain, isHTokenSend?: boolean): Promise<{
        amountOut: BigNumber;
        rate: number;
        priceImpact: number;
        requiredLiquidity: BigNumber;
        lpFees: BigNumber;
        adjustedBonderFee: BigNumber;
        adjustedDestinationTxFee: BigNumber;
        totalFee: BigNumber;
        estimatedReceived: BigNumber;
    }>;
    getAmmData(chain: TChain, amountIn: BigNumberish, isToHToken: boolean, slippageTolerance: number): Promise<{
        rate: number;
        priceImpact: number;
        amountOutMin: BigNumber;
        lpFeeAmount: BigNumber;
    }>;
    getTotalFee(amountIn: BigNumberish, sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getLpFees(amountIn: BigNumberish, sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getDestinationTransactionFee(sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getOptimismL1Fee(sourceChain: TChain, destinationChain: TChain): Promise<any>;
    estimateBondWithdrawalGasLimit(sourceChain: TChain, destinationChain: TChain): Promise<any>;
    populateBondWithdrawalTx(sourceChain: TChain, destinationChain: TChain): Promise<any>;
    /**
     * @desc Estimate token amount out.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge('USDC')
     *const amountOut = await bridge.getAmountOut('1000000000000000000', Chain.Optimism, Chain.Gnosis)
     *console.log(amountOut)
     *```
     */
    getAmountOut(tokenAmountIn: TAmount, sourceChain?: TChain, destinationChain?: TChain): Promise<BigNumber>;
    /**
     * @desc Estimate the bonder liquidity needed at the destination.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge('USDC')
     *const requiredLiquidity = await bridge.getRequiredLiquidity('1000000000000000000', Chain.Optimism, Chain.Gnosis)
     *console.log(requiredLiquidity)
     *```
     */
    getRequiredLiquidity(tokenAmountIn: TAmount, sourceChain: TChain): Promise<BigNumber>;
    getAvailableLiquidity(destinationChain: TChain, bonder: string): Promise<BigNumber>;
    /**
     * @desc Returns available liquidity for Hop bridge at specified chain.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Available liquidity as BigNumber.
     */
    getFrontendAvailableLiquidity(sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    private isOruToL1;
    getBonderAvailableLiquidityData(): Promise<any>;
    getUnbondedTransferRootAmount(sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    private getBaseAvailableCreditIncludingVault;
    getVaultBalance(destinationChain: TChain, bonder: string): Promise<BigNumber>;
    /**
     * @desc Returns bridge contract instance for specified chain.
     * @param {Object} chain - chain model.
     * @returns {Object} Ethers contract instance.
     */
    getBridgeContract(chain: TChain): Promise<ethers.Contract>;
    /**
     * @desc Returns total credit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total credit as BigNumber.
     */
    getCredit(sourceChain: TChain, bonder: string): Promise<BigNumber>;
    /**
     * @desc Returns total debit, including sliding window debit, that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getTotalDebit(sourceChain: TChain, bonder: string): Promise<BigNumber>;
    /**
     * @desc Returns total debit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getDebit(sourceChain: TChain, bonder: string): Promise<BigNumber>;
    /**
     * @desc Sends transaction to execute swap on Saddle contract.
     * @param {Object} sourceChain - Source chain model.
     * @param {Boolean} toHop - Converts to Hop token only if set to true.
     * @param {Object} amount - Amount of token to swap.
     * @param {Object} minAmountOut - Minimum amount of tokens to receive in order
     * for transaction to be successful.
     * @param {Number} deadline - Transaction deadline in seconds.
     * @returns {Object} Ethers transaction object.
     */
    execSaddleSwap(sourceChain: TChain, toHop: boolean, amount: TAmount, minAmountOut: TAmount, deadline: BigNumberish): Promise<ethers.ContractTransaction>;
    /**
     * @desc Returns Hop L1 Bridge Ethers contract instance.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL1Bridge(signer?: TProvider): Promise<import("@src/../../core/contracts/L1ERC20Bridge").L1ERC20Bridge>;
    /**
     * @desc Returns Hop L2 Bridge Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL2Bridge(chain: TChain, signer?: TProvider): Promise<L2Bridge>;
    getAmm(chain: TChain): AMM;
    /**
     * @desc Returns Hop Bridge AMM wrapper Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getAmmWrapper(chain: TChain, signer?: TProvider): Promise<import("@src/../../core/contracts/L2AmmWrapper").L2AmmWrapper>;
    /**
     * @desc Returns Hop Bridge Saddle reserve amounts.
     * @param {Object} chain - Chain model.
     * @returns {Array} Array containing reserve amounts for canonical token
     * and hTokens.
     */
    getSaddleSwapReserves(chain?: TChain): Promise<[BigNumber, BigNumber]>;
    getReservesTotal(chain?: TChain): Promise<BigNumber>;
    /**
     * @desc Returns Hop Bridge Saddle Swap LP Token Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getSaddleLpToken(chain: TChain, signer?: TProvider): Token;
    /**
     * @desc Sends transaction to add liquidity to AMM.
     * @param {Object} amount0Desired - Amount of token #0 in smallest unit
     * @param {Object} amount1Desired - Amount of token #1 in smallest unit
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    addLiquidity(amount0Desired: TAmount, amount1Desired: TAmount, chain?: TChain, options?: Partial<AddLiquidityOptions>): Promise<ethers.providers.TransactionResponse>;
    /**
     * @desc Sends transaction to remove liquidity from AMM.
     * @param {Object} liquidityTokenAmount - Amount of LP tokens to burn.
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    removeLiquidity(liquidityTokenAmount: TAmount, chain?: TChain, options?: Partial<RemoveLiquidityOptions>): Promise<ethers.providers.TransactionResponse>;
    removeLiquidityOneToken(lpTokenAmount: TAmount, tokenIndex: number, chain?: TChain, options?: Partial<RemoveLiquidityOneTokenOptions>): Promise<ethers.ContractTransaction>;
    removeLiquidityImbalance(token0Amount: TAmount, token1Amount: TAmount, chain?: TChain, options?: Partial<RemoveLiquidityImbalanceOptions>): Promise<ethers.ContractTransaction>;
    calculateWithdrawOneToken(tokenAmount: TAmount, tokenIndex: number, chain?: TChain): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The default deadline to use in seconds.
     * @returns {Number} Deadline in seconds
     */
    get defaultDeadlineSeconds(): number;
    /**
     * @readonly
     * @desc The time slot for the current time.
     * @param {Object} time - Unix timestamp (in seconds) to get the time slot.
     * @returns {Object} Time slot for the given time as BigNumber.
     */
    getTimeSlot(time: TTime): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The challenge period.
     * @returns {Object} The challenge period for the bridge as BigNumber.
     */
    challengePeriod(): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The size of the time slots.
     * @returns {Object} The size of the time slots for the bridge as BigNumber.
     */
    timeSlotSize(): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The amount bonded for a time slot for a bonder.
     * @param {Object} chain - Chain model.
     * @param {Number} timeSlot - Time slot to get.
     * @param {String} bonder - Address of the bonder to check.
     * @returns {Object} Amount bonded for the bonder for the given time slot as BigNumber.
     */
    timeSlotToAmountBonded(timeSlot: TTimeSlot, bonder: string): Promise<BigNumber>;
    private getTokenIndexes;
    private populateSendL1ToL2Tx;
    private populateSendL2ToL1Tx;
    private populateSendL2ToL2Tx;
    private calcToHTokenAmount;
    private calcFromHTokenAmount;
    private getBonderFeeRelative;
    private getBonderFeeAbsolute;
    private getRate;
    private getPriceImpact;
    private checkConnectedChain;
    getAmbBridge(chain: TChain): Promise<import("@src/../../core/contracts/L1HomeAMBNativeToErc20").L1HomeAMBNativeToErc20>;
    getChainNativeToken(chain: TChain): TokenModel;
    isNativeToken(chain?: TChain): boolean;
    getEthBalance(chain?: TChain, address?: string): Promise<BigNumber>;
    isSupportedAsset(chain: TChain): boolean;
    getBonderAddress(sourceChain: TChain, destinationChain: TChain): string;
    shouldAttemptSwap(amountOutMin: BigNumber, deadline: BigNumberish): boolean;
    private getGasEstimateFromAddress;
    withdraw(chain: Chain, recipient: string, amount: BigNumberish, transferNonce: string, bonderFee: BigNumberish, amountOutMin: BigNumberish, deadline: number, transferRootHash: string, rootTotalAmount: BigNumberish, transferIdTreeIndex: number, siblings: string[], totalLeaves: number): Promise<any>;
}
export default HopBridge;
//# sourceMappingURL=HopBridge.d.ts.map
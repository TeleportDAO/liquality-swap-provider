import Base, { ChainProviders } from './Base';
import Chain from './models/Chain';
import { BigNumber, Contract, Signer, ethers, providers } from 'ethers';
import { TAmount, TChain } from './types';
import { TokenSymbol } from './constants';
/**
 * Class reprensenting ERC20 Token
 * @namespace Token
 */
declare class Token extends Base {
    readonly address: string;
    readonly decimals: number;
    readonly name: string;
    readonly image: string;
    readonly chain: Chain;
    readonly contract: Contract;
    _symbol: TokenSymbol;
    /**
     * @desc Instantiates Token class.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Number} chainId - Chain ID.
     * @param {String} address - Token address.
     * @param {Number} decimals - Token decimals.
     * @param {String} symbol - Token symbol.
     * @param {String} name - Token name.
     * @param {Object} signer - Ethers signer.
     * @returns {Object} Token class instance.
     */
    constructor(network: string, chain: TChain, address: string, decimals: number, symbol: TokenSymbol, name: string, image: string, signer?: Signer | providers.Provider, chainProviders?: ChainProviders);
    get symbol(): string;
    /**
     * @desc Returns a token instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New Token SDK instance with connected signer.
     */
    connect(signer: Signer | providers.Provider): Token;
    /**
     * @desc Returns token allowance.
     * @param {String} spender - spender address.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const hop = new Hop('mainnet')
     *const bridge = hop.bridge('USDC')
     *const token = bridge.getCanonicalToken(Chain.Polygon)
     *const spender = await bridge.getSendApprovalAddress(Chain.Polygon)
     *const account = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const allowance = await token.allowance(spender, account)
     *console.log(allowance)
     *```
     */
    allowance(spender: string, address?: string): Promise<BigNumber>;
    /**
     * @desc Returns token balance of signer.
     * @param {String} spender - spender address.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const bridge = hop.bridge('USDC').connect(signer)
     *const spender = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const allowance = bridge.allowance(Chain.Gnosis, spender)
     *```
     */
    balanceOf(address?: string): Promise<BigNumber>;
    /**
     * @desc ERC20 token transfer
     * @param {String} recipient - recipient address.
     * @param {String} amount - Token amount.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop } from '@hop-protocol/sdk'
     *
     *const bridge = hop.bridge('USDC').connect(signer)
     *const recipient = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const amount = '1000000000000000000'
     *const tx = await bridge.erc20Transfer(spender, amount)
     *```
     */
    transfer(recipient: string, amount: TAmount): Promise<ethers.providers.TransactionResponse>;
    /**
     * @desc Approve address to spend tokens if not enough allowance .
     * @param {Object} chain - Chain model.
     * @param {String} spender - spender address.
     * @param {String} amount - amount allowed to spend.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const bridge = hop.bridge('USDC').connect(signer)
     *const spender = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const amount = '1000000000000000000'
     *const tx = await bridge.approve(Chain.Gnosis, spender, amount)
     *```
     */
    approve(spender: string, amount?: TAmount): Promise<ethers.providers.TransactionResponse>;
    populateApproveTx(spender: string, amount?: TAmount): Promise<any>;
    /**
     * @desc Returns a token Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers contract instance.
     */
    getErc20(): Promise<import("@src/../../core/contracts/ERC20").ERC20 | import("@src/../../core/contracts/WETH9").WETH9>;
    overrides(): Promise<any>;
    get chainId(): void;
    eq(token: Token): boolean;
    get isNativeToken(): boolean;
    get nativeTokenSymbol(): string;
    getNativeTokenBalance(address?: string): Promise<BigNumber>;
    getWethContract(): Promise<import("@src/../../core/contracts/WETH9").WETH9>;
    getWrappedToken(): Token;
    populateWrapTokenTx(amount: TAmount): Promise<ethers.PopulatedTransaction>;
    wrapToken(amount: TAmount, estimateGasOnly?: boolean): Promise<BigNumber | ethers.providers.TransactionResponse>;
    populateUnwrapTokenTx(amount: TAmount): Promise<ethers.PopulatedTransaction>;
    unwrapToken(amount: TAmount): Promise<ethers.providers.TransactionResponse>;
    getWrapTokenEstimatedGas(chain: TChain): Promise<{
        to?: string;
        from?: string;
        nonce?: number;
        gasLimit: BigNumber;
        gasPrice?: BigNumber;
        data?: string;
        value?: BigNumber;
        chainId?: number;
        type?: number;
        accessList?: ethers.utils.AccessList;
        maxFeePerGas?: BigNumber;
        maxPriorityFeePerGas?: BigNumber;
        customData?: Record<string, any>;
    }>;
    private getGasEstimateFromAddress;
    totalSupply(): Promise<BigNumber>;
    static fromJSON(json: any): Token;
    toJSON(): {
        address: string;
        decimals: number;
        name: string;
        image: string;
        chain: Chain;
        symbol: string;
    };
}
export default Token;
//# sourceMappingURL=Token.d.ts.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const fast_memoize_1 = __importDefault(require("fast-memoize"));
const ethers_1 = require("ethers");
const models_1 = require("./models");
const constants_1 = require("./constants");
const config_1 = require("./config");
const contracts_1 = require("@eth-optimism/contracts");
const utils_1 = require("ethers/lib/utils");
const s3FileCache = {};
// cache provider
const getProvider = (0, fast_memoize_1.default)((network, chain) => {
    const rpcUrl = config_1.config.chains[network][chain].rpcUrl;
    if (!rpcUrl) {
        if (network === 'staging') {
            network = 'mainnet';
        }
        return ethers_1.providers.getDefaultProvider(network);
    }
    return new ethers_1.providers.StaticJsonRpcProvider({
        url: rpcUrl,
        timeout: 60 * 1000
    });
});
const getContractMemo = (0, fast_memoize_1.default)((factory, address, cacheKey) => {
    let cached;
    return (provider) => {
        if (!cached) {
            cached = factory.connect(address, provider);
        }
        return cached;
    };
});
// cache contract
const getContract = (factory, address, provider) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g;
    const p = provider;
    // memoize function doesn't handle dynamic provider object well, so
    // here we derived a cache key based on connected account address and rpc url.
    const signerAddress = (p === null || p === void 0 ? void 0 : p.getAddress) ? yield (p === null || p === void 0 ? void 0 : p.getAddress()) : '';
    const chainId = (_c = (_b = (_a = p === null || p === void 0 ? void 0 : p.provider) === null || _a === void 0 ? void 0 : _a._network) === null || _b === void 0 ? void 0 : _b.chainId) !== null && _c !== void 0 ? _c : '';
    yield (p === null || p === void 0 ? void 0 : p._networkPromise);
    const fallbackProviderChainId = (_e = (_d = p === null || p === void 0 ? void 0 : p._network) === null || _d === void 0 ? void 0 : _d.chainId) !== null && _e !== void 0 ? _e : '';
    const rpcUrl = (_g = (_f = p === null || p === void 0 ? void 0 : p.connection) === null || _f === void 0 ? void 0 : _f.url) !== null && _g !== void 0 ? _g : '';
    const cacheKey = `${signerAddress}${chainId}${fallbackProviderChainId}${rpcUrl}`;
    return getContractMemo(factory, address, cacheKey)(provider);
});
/**
 * Class with base methods.
 * @namespace Base
 */
class Base {
    /**
     * @desc Instantiates Base class.
     * Returns a new Base class instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @returns {Object} New Base class instance.
     */
    constructor(network, signer, chainProviders) {
        this.chainProviders = {};
        this.gasPriceMultiplier = 0;
        this.destinationFeeGasPriceMultiplier = 1;
        this.getChainProviders = () => {
            const obj = {};
            for (const chainSlug of this.supportedChains) {
                const provider = this.getChainProvider(chainSlug);
                obj[chainSlug] = provider;
            }
            return obj;
        };
        this.getChainProviderUrls = () => {
            var _a, _b;
            const obj = {};
            for (const chainSlug of this.supportedChains) {
                const provider = this.getChainProvider(chainSlug);
                obj[chainSlug] = (_b = (_a = provider) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.url;
            }
            return obj;
        };
        this.getContract = getContract;
        if (!network) {
            throw new Error(`network is required. Options are: ${this.supportedNetworks.join(',')}`);
        }
        if (!this.isValidNetwork(network)) {
            throw new Error(`network "${network}" is unsupported. Supported networks are: ${this.supportedNetworks.join(',')}`);
        }
        this.network = network;
        if (signer) {
            this.signer = signer;
        }
        if (chainProviders) {
            this.chainProviders = chainProviders;
        }
        this.chains = config_1.config.chains[network];
        this.addresses = config_1.config.addresses[network];
        this.bonders = config_1.config.bonders[network];
        this.fees = config_1.config.bonderFeeBps[network];
        this.destinationFeeGasPriceMultiplier = config_1.config.destinationFeeGasPriceMultiplier[network];
        this.init();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = s3FileCache[this.network] || (yield this.getS3ConfigData());
                if (data.bonders) {
                    this.bonders = data.bonders;
                }
                if (data.bonderFeeBps) {
                    this.fees = data.bonderFeeBps;
                }
                if (data.destinationFeeGasPriceMultiplier) {
                    this.destinationFeeGasPriceMultiplier = data.destinationFeeGasPriceMultiplier;
                }
                s3FileCache[this.network] = data;
            }
            catch (err) {
                console.error(err);
            }
        });
    }
    sendTransaction(transactionRequest, chain) {
        const chainId = this.toChainModel(chain).chainId;
        return this.signer.sendTransaction(Object.assign(Object.assign({}, transactionRequest), { chainId }));
    }
    setConfigAddresses(addresses) {
        if (addresses.bridges) {
            this.addresses = addresses.bridges;
        }
        if (addresses.bonders) {
            this.bonders = addresses.bonders;
        }
    }
    setChainProvider(chain, provider) {
        chain = this.toChainModel(chain);
        if (!this.isValidChain(chain.slug)) {
            throw new Error(`unsupported chain "${chain.slug}" for network ${this.network}`);
        }
        this.chainProviders[chain.slug] = provider;
    }
    setChainProviders(chainProviders) {
        for (const chainSlug in chainProviders) {
            const chain = this.toChainModel(chainSlug);
            if (!this.isValidChain(chain.slug)) {
                throw new Error(`unsupported chain "${chain.slug}" for network ${this.network}`);
            }
            if (chainProviders[chainSlug]) {
                this.chainProviders[chain.slug] = chainProviders[chainSlug];
            }
        }
    }
    setChainProviderUrls(chainProviders) {
        for (const chainSlug in chainProviders) {
            const chain = this.toChainModel(chainSlug);
            if (!this.isValidChain(chain.slug)) {
                throw new Error(`unsupported chain "${chain.slug}" for network ${this.network}`);
            }
            if (chainProviders[chainSlug]) {
                this.chainProviders[chain.slug] = new ethers_1.providers.StaticJsonRpcProvider(chainProviders[chainSlug]);
            }
        }
    }
    get supportedNetworks() {
        return Object.keys(this.chains || config_1.config.chains);
    }
    isValidNetwork(network) {
        return this.supportedNetworks.includes(network);
    }
    get supportedChains() {
        return Object.keys(this.chains);
    }
    isValidChain(chain) {
        return this.supportedChains.includes(chain);
    }
    /**
     * @desc Returns a Chain model instance with connected provider.
     * @param {Object} - Chain name or model.
     * @returns {Object} - Chain model with connected provider.
     */
    toChainModel(chain) {
        if (typeof chain === 'string') {
            chain = models_1.Chain.fromSlug(chain);
        }
        if (chain.slug === 'xdai') {
            console.warn(constants_1.Errors.xDaiRebrand);
            chain = models_1.Chain.fromSlug('gnosis');
        }
        if (!this.isValidChain(chain.slug)) {
            throw new Error(`chain "${chain.slug}" is unsupported. Supported chains are: ${this.supportedChains.join(',')}`);
        }
        chain.provider = this.getChainProvider(chain);
        chain.chainId = this.getChainId(chain);
        return chain;
    }
    /**
     * @desc Returns a Token instance.
     * @param {Object} - Token name or model.
     * @returns {Object} - Token model.
     */
    toTokenModel(token) {
        if (typeof token === 'string') {
            const canonicalSymbol = models_1.Token.getCanonicalSymbol(token);
            const { name, decimals } = config_1.metadata.tokens[this.network][canonicalSymbol];
            return new models_1.Token(0, '', decimals, token, name);
        }
        return token;
    }
    /**
     * @desc Calculates current gas price plus increased percentage amount.
     * @param {Object} - Ether's Signer
     * @param {number} - Percentage to bump by.
     * @returns {BigNumber} Bumped as price as BigNumber
     * @example
     *```js
     *import { Hop } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bumpedGasPrice = await hop.getBumpedGasPrice(signer, 1.20)
     *console.log(bumpedGasPrice.toNumber())
     *```
     */
    getBumpedGasPrice(signer, percent) {
        return __awaiter(this, void 0, void 0, function* () {
            const gasPrice = yield signer.getGasPrice();
            return gasPrice.mul(ethers_1.BigNumber.from(percent * 100)).div(ethers_1.BigNumber.from(100));
        });
    }
    /**
     * @desc Returns Chain ID for specified Chain model.
     * @param {Object} - Chain model.
     * @returns {Number} - Chain ID.
     */
    getChainId(chain) {
        const { chainId } = this.chains[chain.slug];
        return Number(chainId);
    }
    /**
     * @desc Returns Ethers provider for specified Chain model.
     * @param {Object} - Chain model.
     * @returns {Object} - Ethers provider.
     */
    getChainProvider(chain) {
        let chainSlug;
        if (chain instanceof models_1.Chain && (chain === null || chain === void 0 ? void 0 : chain.slug)) {
            chainSlug = chain === null || chain === void 0 ? void 0 : chain.slug;
        }
        else if (typeof chain === 'string') {
            chainSlug = chain;
        }
        else {
            throw new Error(`unknown chain "${chain}"`);
        }
        if (chainSlug === 'xdai') {
            console.warn(constants_1.Errors.xDaiRebrand);
            chainSlug = constants_1.ChainSlug.Gnosis;
        }
        if (this.chainProviders[chainSlug]) {
            return this.chainProviders[chainSlug];
        }
        return getProvider(this.network, chainSlug);
    }
    /**
     * @desc Returns the connected signer address.
     * @returns {String} Ethers signer address.
     * @example
     *```js
     *import { Hop } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const address = await hop.getSignerAddress()
     *console.log(address)
     *```
     */
    getSignerAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (ethers_1.Signer.isSigner(this.signer)) {
                return this.signer.getAddress();
            }
        });
    }
    /**
     * @desc Returns the connected signer if it's connected to the specified
     * chain id, otherwise it returns a regular provider for the specified chain.
     * @param {Object} chain - Chain name or model
     * @param {Object} signer - Ethers signer or provider
     * @returns {Object} Ethers signer or provider
     */
    getSignerOrProvider(chain, signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log('getSignerOrProvider')
            chain = this.toChainModel(chain);
            if (!signer) {
                return chain.provider;
            }
            if (ethers_1.Signer.isSigner(signer)) {
                if (signer.provider) {
                    const connectedChainId = yield signer.getChainId();
                    // console.log('connectedChainId: ', connectedChainId)
                    // console.log('chain.chainId: ', chain.chainId)
                    if (connectedChainId !== chain.chainId) {
                        if (!signer.provider) {
                            // console.log('connect provider')
                            return signer.connect(chain.provider);
                        }
                        // console.log('return chain.provider')
                        return chain.provider;
                    }
                    return signer;
                }
                else {
                    return chain.provider;
                }
            }
            else {
                // console.log('isSigner')
                const { chainId } = yield signer.getNetwork();
                if (chainId !== chain.chainId) {
                    return chain.provider;
                }
                return signer;
            }
        });
    }
    getConfigAddresses(token, chain) {
        var _a, _b;
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        return (_b = (_a = this.addresses) === null || _a === void 0 ? void 0 : _a[token.canonicalSymbol]) === null || _b === void 0 ? void 0 : _b[chain.slug];
    }
    getL1BridgeAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l1Bridge;
    }
    getL2BridgeAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2Bridge;
    }
    getL1CanonicalBridgeAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l1CanonicalBridge;
    }
    getL2CanonicalBridgeAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2CanonicalBridge;
    }
    getL1CanonicalTokenAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l1CanonicalToken;
    }
    getL2CanonicalTokenAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2CanonicalToken;
    }
    getL2HopBridgeTokenAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2HopBridgeToken;
    }
    getL2AmmWrapperAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2AmmWrapper;
    }
    getL2SaddleSwapAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2SaddleSwap;
    }
    getL2SaddleLpTokenAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2SaddleLpToken;
    }
    // Arbitrum ARB Chain address
    getArbChainAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.arbChain;
    }
    // Gnosis L1 Home AMB bridge address
    getL1AmbBridgeAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l1Amb;
    }
    // Gnosis L2 AMB bridge address
    getL2AmbBridgeAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l2Amb;
    }
    // Polygon Root Chain Manager address
    getL1PosRootChainManagerAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l1PosRootChainManager;
    }
    // Polygon ERC20 Predicate address
    getL1PosErc20PredicateAddress(token, chain) {
        var _a;
        return (_a = this.getConfigAddresses(token, chain)) === null || _a === void 0 ? void 0 : _a.l1PosPredicate;
    }
    // Transaction overrides options
    txOverrides(chain) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const txOptions = {};
            if (this.gasPriceMultiplier > 0) {
                txOptions.gasPrice = yield this.getBumpedGasPrice(this.signer, this.gasPriceMultiplier);
            }
            // Not all Polygon nodes follow recommended 30 Gwei gasPrice
            // https://forum.matic.network/t/recommended-min-gas-price-setting/2531
            if (chain.equals(models_1.Chain.Polygon)) {
                if ((_a = txOptions.gasPrice) === null || _a === void 0 ? void 0 : _a.lt(constants_1.MinPolygonGasPrice)) {
                    txOptions.gasPrice = ethers_1.BigNumber.from(constants_1.MinPolygonGasPrice);
                }
                txOptions.gasLimit = constants_1.MinPolygonGasLimit;
            }
            return txOptions;
        });
    }
    _getBonderAddress(token, sourceChain, destinationChain) {
        var _a, _b, _c;
        token = this.toTokenModel(token);
        sourceChain = this.toChainModel(sourceChain);
        destinationChain = this.toChainModel(destinationChain);
        const bonder = (_c = (_b = (_a = this.bonders) === null || _a === void 0 ? void 0 : _a[token.canonicalSymbol]) === null || _b === void 0 ? void 0 : _b[sourceChain.slug]) === null || _c === void 0 ? void 0 : _c[destinationChain.slug];
        if (!bonder) {
            console.warn(`bonder address not found for route ${token.symbol}.${sourceChain.slug}->${destinationChain.slug}`);
        }
        return bonder;
    }
    getFeeBps(token, destinationChain) {
        var _a;
        token = this.toTokenModel(token);
        destinationChain = this.toChainModel(destinationChain);
        if (!token) {
            throw new Error('token is required');
        }
        if (!destinationChain) {
            throw new Error('destinationChain is required');
        }
        const fees = (_a = this.fees) === null || _a === void 0 ? void 0 : _a[token === null || token === void 0 ? void 0 : token.canonicalSymbol];
        if (!fees) {
            throw new Error('fee data not found');
        }
        const feeBps = fees[destinationChain.slug] || 0;
        return feeBps;
    }
    setGasPriceMultiplier(gasPriceMultiplier) {
        return (this.gasPriceMultiplier = gasPriceMultiplier);
    }
    getS3ConfigData() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `https://assets.hop.exchange/${this.network}/v1-core-config.json`;
            const res = yield (0, isomorphic_fetch_1.default)(url);
            const json = yield res.json();
            if (!json) {
                throw new Error('expected json object');
            }
            return json;
        });
    }
    getSupportedAssets() {
        const supported = {};
        for (const token in this.addresses) {
            for (const chain in this.addresses[token]) {
                if (!supported[chain]) {
                    supported[chain] = {};
                }
                supported[chain][token] = true;
            }
        }
        return supported;
    }
    getSupportedAssetsForChain(chain) {
        chain = this.toChainModel(chain);
        const supported = this.getSupportedAssets();
        return supported[chain.slug];
    }
    estimateOptimismL1FeeFromData(gasLimit, data = '0x', to = ethers_1.constants.AddressZero) {
        return __awaiter(this, void 0, void 0, function* () {
            gasLimit = ethers_1.BigNumber.from(gasLimit.toString());
            const chain = this.toChainModel(models_1.Chain.Optimism);
            const gasPrice = yield chain.provider.getGasPrice();
            const ovmGasPriceOracle = (0, contracts_1.getContractFactory)('OVM_GasPriceOracle')
                .attach(contracts_1.predeploys.OVM_GasPriceOracle).connect(chain.provider);
            const serializedTx = (0, utils_1.serializeTransaction)({
                value: (0, utils_1.parseEther)('0'),
                gasPrice,
                gasLimit,
                to,
                data
            });
            const l1FeeInWei = yield ovmGasPriceOracle.getL1Fee(serializedTx);
            return l1FeeInWei;
        });
    }
}
exports.default = Base;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __importDefault(require("./Base"));
const Chain_1 = __importDefault(require("./models/Chain"));
const Token_1 = __importDefault(require("./models/Token"));
const ethers_1 = require("ethers");
const ERC20__factory_1 = require("@hop-protocol/core/contracts/factories/ERC20__factory");
const constants_1 = require("./constants");
const WETH9__factory_1 = require("@hop-protocol/core/contracts/factories/WETH9__factory");
/**
 * Class reprensenting ERC20 Token
 * @namespace Token
 */
class Token extends Base_1.default {
    // TODO: clean up and remove unused parameters.
    /**
     * @desc Instantiates Token class.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Number} chainId - Chain ID.
     * @param {String} address - Token address.
     * @param {Number} decimals - Token decimals.
     * @param {String} symbol - Token symbol.
     * @param {String} name - Token name.
     * @param {Object} signer - Ethers signer.
     * @returns {Object} Token class instance.
     */
    constructor(network, chain, address, decimals, symbol, name, image, signer, chainProviders) {
        super(network, signer, chainProviders);
        this.address = ethers_1.ethers.utils.getAddress(address);
        this.decimals = decimals;
        this._symbol = symbol;
        this.name = name;
        this.image = image;
        this.chain = this.toChainModel(chain);
    }
    get symbol() {
        if (this._symbol === Token_1.default.ETH && !this.isNativeToken) {
            return constants_1.WrappedToken.WETH;
        }
        return this._symbol;
    }
    /**
     * @desc Returns a token instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New Token SDK instance with connected signer.
     */
    connect(signer) {
        return new Token(this.network, this.chain, this.address, this.decimals, this._symbol, this.name, this.image, signer, this.chainProviders);
    }
    /**
     * @desc Returns token allowance.
     * @param {String} spender - spender address.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const hop = new Hop('mainnet')
     *const bridge = hop.bridge('USDC')
     *const token = bridge.getCanonicalToken(Chain.Polygon)
     *const spender = await bridge.getSendApprovalAddress(Chain.Polygon)
     *const account = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const allowance = await token.allowance(spender, account)
     *console.log(allowance)
     *```
     */
    allowance(spender, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenContract = yield this.getErc20();
            address = address !== null && address !== void 0 ? address : yield this.getSignerAddress();
            if (!address) {
                throw new Error('signer required');
            }
            return tokenContract.allowance(address, spender);
        });
    }
    /**
     * @desc Returns token balance of signer.
     * @param {String} spender - spender address.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const bridge = hop.bridge('USDC').connect(signer)
     *const spender = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const allowance = bridge.allowance(Chain.Gnosis, spender)
     *```
     */
    balanceOf(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNativeToken) {
                return this.getNativeTokenBalance(address);
            }
            address = address !== null && address !== void 0 ? address : yield this.getSignerAddress();
            if (!address) {
                throw new Error('address is required');
            }
            const tokenContract = yield this.getErc20();
            return tokenContract.balanceOf(address);
        });
    }
    /**
     * @desc ERC20 token transfer
     * @param {String} recipient - recipient address.
     * @param {String} amount - Token amount.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop } from '@hop-protocol/sdk'
     *
     *const bridge = hop.bridge('USDC').connect(signer)
     *const recipient = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const amount = '1000000000000000000'
     *const tx = await bridge.erc20Transfer(spender, amount)
     *```
     */
    transfer(recipient, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNativeToken) {
                return this.sendTransaction({
                    to: recipient,
                    value: amount
                }, this.chain);
            }
            const tokenContract = yield this.getErc20();
            return tokenContract.transfer(recipient, amount, yield this.overrides());
        });
    }
    /**
     * @desc Approve address to spend tokens if not enough allowance .
     * @param {Object} chain - Chain model.
     * @param {String} spender - spender address.
     * @param {String} amount - amount allowed to spend.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const bridge = hop.bridge('USDC').connect(signer)
     *const spender = '0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1'
     *const amount = '1000000000000000000'
     *const tx = await bridge.approve(Chain.Gnosis, spender, amount)
     *```
     */
    approve(spender, amount = ethers_1.ethers.constants.MaxUint256) {
        return __awaiter(this, void 0, void 0, function* () {
            const populatedTx = yield this.populateApproveTx(spender, amount);
            const allowance = yield this.allowance(spender);
            if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                return this.sendTransaction(populatedTx, this.chain);
            }
        });
    }
    populateApproveTx(spender, amount = ethers_1.ethers.constants.MaxUint256) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNativeToken) {
                return;
            }
            const tokenContract = yield this.getErc20();
            return tokenContract.populateTransaction.approve(spender, amount, yield this.overrides());
        });
    }
    /**
     * @desc Returns a token Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers contract instance.
     */
    getErc20() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNativeToken) {
                return this.getWethContract();
            }
            const provider = yield this.getSignerOrProvider(this.chain);
            return ERC20__factory_1.ERC20__factory.connect(this.address, provider);
        });
    }
    overrides() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.txOverrides(this.chain);
        });
    }
    // ToDo: Remove chainId. This is added to comply with the token model type
    get chainId() {
        throw new Error('chainId should not be accessed');
    }
    eq(token) {
        return (this.symbol.toLowerCase() === token.symbol.toLowerCase() &&
            this.address.toLowerCase() === token.address.toLowerCase() &&
            this.chain.equals(token.chain));
    }
    get isNativeToken() {
        const isEth = this._symbol === Token_1.default.ETH &&
            (this.chain.equals(Chain_1.default.Ethereum) ||
                this.chain.equals(Chain_1.default.Arbitrum) ||
                this.chain.equals(Chain_1.default.Optimism));
        const isMatic = this._symbol === Token_1.default.MATIC && this.chain.equals(Chain_1.default.Polygon);
        const isxDai = [Token_1.default.DAI, Token_1.default.XDAI].includes(this._symbol) &&
            this.chain.equals(Chain_1.default.Gnosis);
        return isEth || isMatic || isxDai;
    }
    get nativeTokenSymbol() {
        return this.chain.nativeTokenSymbol;
    }
    getNativeTokenBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            address = address !== null && address !== void 0 ? address : yield this.getSignerAddress();
            if (!address) {
                throw new Error('address is required');
            }
            return this.chain.provider.getBalance(address);
        });
    }
    getWethContract() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getSignerOrProvider(this.chain);
            return WETH9__factory_1.WETH9__factory.connect(this.address, provider);
        });
    }
    getWrappedToken() {
        if (!this.isNativeToken) {
            return this;
        }
        return new Token(this.network, this.chain, this.address, this.decimals, `W${this._symbol}`, this.name, this.image, this.signer, this.chainProviders);
    }
    populateWrapTokenTx(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield this.getWethContract();
            return contract.populateTransaction.deposit({
                value: amount
            });
        });
    }
    wrapToken(amount, estimateGasOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield this.getWethContract();
            if (estimateGasOnly) {
                // a `from` address is required if using only provider (not signer)
                const from = yield this.getGasEstimateFromAddress();
                return contract.connect(this.chain.provider).estimateGas.deposit({
                    value: amount,
                    from
                });
            }
            const populatedTx = yield this.populateWrapTokenTx(amount);
            return this.sendTransaction(populatedTx, this.chain);
        });
    }
    populateUnwrapTokenTx(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = yield this.getWethContract();
            return contract.populateTransaction.withdraw(amount);
        });
    }
    unwrapToken(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const populatedTx = yield this.populateUnwrapTokenTx(amount);
            return this.sendTransaction(populatedTx, this.chain);
        });
    }
    getWrapTokenEstimatedGas(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const amount = ethers_1.BigNumber.from(1);
            const contract = yield this.getWethContract();
            // a `from` address is required if using only provider (not signer)
            const from = yield this.getGasEstimateFromAddress();
            const [gasLimit, tx] = yield Promise.all([
                contract.connect(this.chain.provider).estimateGas.deposit({
                    value: amount,
                    from
                }),
                contract.connect(this.chain.provider).populateTransaction.deposit({
                    value: amount,
                    from
                })
            ]);
            return Object.assign({ gasLimit }, tx);
        });
    }
    getGasEstimateFromAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            let address = yield this.getSignerAddress();
            if (!address) {
                address = yield this._getBonderAddress(this._symbol, this.chain, Chain_1.default.Ethereum);
            }
            return address;
        });
    }
    totalSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isNativeToken) {
                return ethers_1.BigNumber.from(0);
            }
            const tokenContract = yield this.getErc20();
            return tokenContract.totalSupply();
        });
    }
    static fromJSON(json) {
        return new Token(json.network, json.chain, json.address, json.decimals, json.symbol, json.name, json.image);
    }
    toJSON() {
        return {
            address: this.address,
            decimals: this.decimals,
            name: this.name,
            image: this.image,
            chain: this.chain,
            symbol: this._symbol
        };
    }
}
exports.default = Token;

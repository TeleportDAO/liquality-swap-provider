"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBaseWalletProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const typechain_1 = require("../typechain");
const utils_2 = require("../utils");
class EvmBaseWalletProvider extends client_1.Wallet {
    constructor(chainProvider, namingProvider) {
        super(chainProvider, namingProvider);
    }
    getSigner() {
        return this.signer;
    }
    setSigner(signer) {
        this.signer = signer;
    }
    signMessage(message, _from) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedMessage = yield this.signer.signMessage(message);
            return (0, utils_1.remove0x)(signedMessage);
        });
    }
    sendTransaction(txRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainId = Number(this.chainProvider.getNetwork().chainId);
            // default to average fee
            if (!txRequest.fee) {
                txRequest.fee = (yield this.chainProvider.getFees()).average.fee;
            }
            let ethersTxRequest = null;
            // Handle ERC20 transfers
            if (txRequest.asset && txRequest.asset.type === types_1.AssetTypes.erc20) {
                const transferErc20Tx = yield typechain_1.ERC20__factory.connect(txRequest.asset.contractAddress, this.signer).populateTransaction.transfer((0, utils_1.ensure0x)(txRequest.to.toString()), txRequest.value.toString(10));
                ethersTxRequest = (0, utils_2.parseTxRequest)(Object.assign(Object.assign({ chainId }, transferErc20Tx), (0, utils_2.extractFeeData)(txRequest.fee)));
            }
            // Handle ETH transfers & contract calls
            else {
                ethersTxRequest = (0, utils_2.parseTxRequest)(Object.assign(Object.assign({ chainId }, txRequest), (0, utils_2.extractFeeData)(txRequest.fee)));
            }
            if (!ethersTxRequest.from) {
                ethersTxRequest.from = yield this.signer.getAddress();
            }
            if (!ethersTxRequest.gasLimit) {
                ethersTxRequest.gasLimit = yield this.estimateGas(ethersTxRequest);
            }
            const result = yield this.signer.sendTransaction(ethersTxRequest);
            return (0, utils_2.parseTxResponse)(result);
        });
    }
    sendBatchTransaction(txRequests) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const txRequest of txRequests) {
                const tx = yield this.sendTransaction(txRequest);
                result.push(tx);
            }
            return result;
        });
    }
    sendSweepTransaction(address, asset, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = (yield this.getBalance([asset]))[0];
            const tx = { to: address, value: balance, fee };
            return yield this.sendTransaction(tx);
        });
    }
    updateTransactionFee(tx, newFee) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = typeof tx === 'string' ? yield this.chainProvider.getTransactionByHash(tx) : tx;
            const { gasPrice, maxPriorityFeePerGas, maxFeePerGas } = transaction._raw;
            // EIP1559
            if (typeof newFee !== 'number') {
                if (maxPriorityFeePerGas && newFee.maxPriorityFeePerGas && maxFeePerGas && newFee.maxFeePerGas) {
                    if (maxPriorityFeePerGas.gte((0, utils_2.fromGwei)(newFee.maxPriorityFeePerGas).toNumber())) {
                        throw new errors_1.ReplaceFeeInsufficientError('Replace transaction underpriced: provide more maxPriorityFeePerGas');
                    }
                    if (maxFeePerGas.gte((0, utils_2.fromGwei)(newFee.maxFeePerGas).toNumber())) {
                        throw new errors_1.ReplaceFeeInsufficientError('Replace transaction underpriced: provide more maxFeePerGas');
                    }
                }
                else {
                    throw new errors_1.ReplaceFeeInsufficientError('No replacement fee is provided');
                }
            }
            // Legacy
            else if (gasPrice && newFee) {
                if (gasPrice.gte((0, utils_2.fromGwei)(newFee).toNumber())) {
                    throw new errors_1.ReplaceFeeInsufficientError('Replace transaction underpriced: provide more gasPrice');
                }
            }
            else {
                throw new errors_1.ReplaceFeeInsufficientError('Replace transaction underpriced');
            }
            const newTransaction = Object.assign(Object.assign({}, transaction), { value: new types_1.BigNumber(transaction.value), nonce: transaction._raw.nonce, fee: newFee });
            return this.sendTransaction(newTransaction);
        });
    }
    getBalance(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.getAddress();
            return yield this.chainProvider.getBalance([user], assets);
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainProvider.getNetwork();
        });
    }
    estimateGas(txRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const estimation = yield this.chainProvider.getProvider().estimateGas(txRequest);
                // do not add gas limit margin for sending native asset
                if (estimation.eq(21000)) {
                    return estimation;
                }
                // gas estimation is increased with 50%
                else {
                    return (0, utils_2.calculateGasMargin)(estimation, 5000);
                }
            }
            catch (error) {
                const { message } = error, attrs = __rest(error, ["message"]);
                throw new errors_1.NodeError(message, Object.assign({}, attrs));
            }
        });
    }
}
exports.EvmBaseWalletProvider = EvmBaseWalletProvider;
//# sourceMappingURL=EvmBaseWalletProvider.js.map
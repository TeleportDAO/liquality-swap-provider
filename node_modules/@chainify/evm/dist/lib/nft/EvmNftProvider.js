"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmNftProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const constants_1 = require("@ethersproject/constants");
const typechain_1 = require("../typechain");
const types_2 = require("../types");
const utils_1 = require("../utils");
class EvmNftProvider extends client_1.Nft {
    constructor(walletProvider) {
        super(walletProvider);
        this._erc721 = typechain_1.ERC721__factory.connect(constants_1.AddressZero, this.walletProvider.getSigner());
        this._erc1155 = typechain_1.ERC1155__factory.connect(constants_1.AddressZero, this.walletProvider.getSigner());
        this.cache = {};
        this.schemas = { ERC721: this._erc721, ERC1155: this._erc1155 };
    }
    transfer(contractAddress, receiver, tokenIDs, amounts, data = '0x', fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.populateTrasnfer(contractAddress, receiver, tokenIDs, amounts, data);
            return yield this.walletProvider.sendTransaction((0, utils_1.toEthereumTxRequest)(tx, fee));
        });
    }
    balanceOf(contractAddress, owners, tokenIDs) {
        return __awaiter(this, void 0, void 0, function* () {
            const { schema, contract } = yield this._cacheGet(contractAddress);
            const _owners = owners.map((owner) => owner.toString());
            switch (schema) {
                case types_2.NftTypes.ERC721: {
                    const _contract = contract;
                    const balance = yield _contract.balanceOf(_owners[0]);
                    return new types_1.BigNumber(balance.toString());
                }
                case types_2.NftTypes.ERC1155: {
                    const _contract = contract;
                    if (tokenIDs.length > 1) {
                        const balances = yield _contract.balanceOfBatch(_owners, tokenIDs);
                        return balances.map((b) => new types_1.BigNumber(b.toString()));
                    }
                    else {
                        return new types_1.BigNumber((yield _contract.balanceOf(_owners[0], tokenIDs[0])).toString());
                    }
                }
                default: {
                    throw new errors_1.UnsupportedMethodError(`Unsupported NFT type: ${schema}`);
                }
            }
        });
    }
    approve(contractAddress, operator, tokenID, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.populateApprove(contractAddress, operator, tokenID);
            return this.walletProvider.sendTransaction((0, utils_1.toEthereumTxRequest)(tx, fee));
        });
    }
    approveAll(contractAddress, operator, state, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.populateApproveAll(contractAddress, operator, state);
            return this.walletProvider.sendTransaction((0, utils_1.toEthereumTxRequest)(tx, fee));
        });
    }
    isApprovedForAll(contractAddress, operator) {
        return __awaiter(this, void 0, void 0, function* () {
            const { contract } = yield this._cacheGet(contractAddress);
            const owner = yield this.walletProvider.getAddress();
            return yield contract.isApprovedForAll(owner.toString(), operator.toString());
        });
    }
    estimateTransfer(contractAddress, receiver, tokenIDs, amounts, data = '0x') {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.populateTrasnfer(contractAddress, receiver, tokenIDs, amounts, data);
            const estimation = yield this.walletProvider.estimateGas(tx);
            return new types_1.BigNumber(estimation.toString());
        });
    }
    estimateApprove(contractAddress, operator, tokenID) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.populateApprove(contractAddress, operator, tokenID);
            const estimation = yield this.walletProvider.estimateGas(tx);
            return new types_1.BigNumber(estimation.toString());
        });
    }
    estimateApproveAll(contractAddress, operator, state) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.populateApproveAll(contractAddress, operator, state);
            const estimation = yield this.walletProvider.estimateGas(tx);
            return new types_1.BigNumber(estimation.toString());
        });
    }
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Method not implemented');
        });
    }
    _cacheGet(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const _contractAddress = contractAddress.toString();
            if (this.cache[_contractAddress]) {
                return this.cache[_contractAddress];
            }
            const ERC721_INTERFACE = {
                id: '0x80ac58cd',
                type: types_2.NftTypes.ERC721,
            };
            const ERC1155_INTERFACE = {
                id: '0xd9b67a26',
                type: types_2.NftTypes.ERC1155,
            };
            for (const _interface of [ERC721_INTERFACE, ERC1155_INTERFACE]) {
                // we can use erc721 because both erc721 and erc1155 support that interface
                const isSupported = yield this._erc721.attach(_contractAddress).supportsInterface(_interface.id);
                if (isSupported) {
                    this.cache[_contractAddress] = {
                        contract: this.schemas[_interface.type].attach(_contractAddress),
                        schema: _interface.type,
                    };
                    return this.cache[_contractAddress];
                }
            }
            throw new errors_1.UnsupportedMethodError(`Cannot find the data for ${_contractAddress}`);
        });
    }
    populateApprove(contractAddress, operator, tokenID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { schema, contract } = yield this._cacheGet(contractAddress);
            const _operator = operator.toString();
            let tx;
            switch (schema) {
                case types_2.NftTypes.ERC721: {
                    const _contract = contract;
                    tx = yield _contract.populateTransaction.approve(_operator, tokenID);
                    break;
                }
                case types_2.NftTypes.ERC1155: {
                    const _contract = contract;
                    tx = yield _contract.populateTransaction.setApprovalForAll(_operator, true);
                    break;
                }
                default: {
                    throw new errors_1.UnsupportedMethodError(`Unsupported NFT type: ${schema}`);
                }
            }
            return tx;
        });
    }
    populateTrasnfer(contractAddress, receiver, tokenIDs, amounts, data = '0x') {
        return __awaiter(this, void 0, void 0, function* () {
            const { schema, contract } = yield this._cacheGet(contractAddress);
            const owner = (yield this.walletProvider.getAddress()).toString();
            const to = receiver.toString();
            let tx;
            switch (schema) {
                case types_2.NftTypes.ERC721: {
                    if (tokenIDs.length !== 1) {
                        throw new Error(`nft.transfer supports exactly 1 tokenID transfer for ERC721. received ${tokenIDs.join(', ')}`);
                    }
                    const _contract = contract;
                    tx = yield _contract.populateTransaction['safeTransferFrom(address,address,uint256,bytes)'](owner, to, tokenIDs[0], data);
                    break;
                }
                case types_2.NftTypes.ERC1155: {
                    const _contract = contract;
                    if (tokenIDs.length > 1) {
                        tx = yield _contract.populateTransaction.safeBatchTransferFrom(owner, to, tokenIDs, amounts, data);
                    }
                    else {
                        tx = yield _contract.populateTransaction.safeTransferFrom(owner, to, tokenIDs[0], amounts[0], data);
                    }
                    break;
                }
                default: {
                    throw new errors_1.UnsupportedMethodError(`Unsupported NFT type: ${schema}`);
                }
            }
            return tx;
        });
    }
    populateApproveAll(contractAddress, operator, state) {
        return __awaiter(this, void 0, void 0, function* () {
            const { contract } = yield this._cacheGet(contractAddress);
            const tx = yield contract.populateTransaction.setApprovalForAll(operator.toString(), state);
            return tx;
        });
    }
}
exports.EvmNftProvider = EvmNftProvider;
//# sourceMappingURL=EvmNftProvider.js.map
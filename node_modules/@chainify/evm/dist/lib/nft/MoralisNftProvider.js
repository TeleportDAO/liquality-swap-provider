"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoralisNftProvider = void 0;
const node_1 = __importDefault(require("moralis/node"));
const types_1 = require("../types");
const EvmNftProvider_1 = require("./EvmNftProvider");
class MoralisNftProvider extends EvmNftProvider_1.EvmNftProvider {
    constructor(walletProvider, config) {
        super(walletProvider);
        this._config = config;
    }
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            // check if Moralis is already initialized
            if (!node_1.default.applicationId) {
                yield node_1.default.start({ masterKey: this._config.apiKey, serverUrl: this._config.url, appId: this._config.appId });
            }
            const [userAddress, network] = yield Promise.all([this.walletProvider.getAddress(), this.walletProvider.getConnectedNetwork()]);
            const chainId = `0x${Number(network.chainId).toString(16)}`;
            const nfts = yield node_1.default.Web3API.account.getNFTs({
                address: userAddress.toString(),
                chain: chainId,
            });
            return nfts.result.reduce((result, nft) => {
                var _a;
                const { contract_type, token_address, name, symbol, metadata, token_id, amount } = nft;
                // we only support ERC721 & ERC1155
                if (contract_type in types_1.NftTypes && token_address) {
                    this.cache[token_address] = {
                        contract: this.schemas[contract_type].attach(token_address),
                        schema: contract_type,
                    };
                    let nftAsset = {
                        asset_contract: {
                            address: token_address,
                            name,
                            symbol,
                        },
                        collection: {
                            name,
                        },
                        token_id,
                        amount,
                        standard: contract_type,
                    };
                    if (metadata) {
                        const parsed = JSON.parse(metadata);
                        parsed.image = ((_a = parsed.image) === null || _a === void 0 ? void 0 : _a.replace('ipfs://', 'https://ipfs.io/ipfs/')) || '';
                        nftAsset = Object.assign(Object.assign({}, nftAsset), { name: parsed.name, description: parsed.description, image_original_url: parsed.image, image_preview_url: parsed.image, image_thumbnail_url: parsed.image, external_link: parsed.external_url });
                    }
                    result.push(nftAsset);
                }
                return result;
            }, []);
        });
    }
}
exports.MoralisNftProvider = MoralisNftProvider;
//# sourceMappingURL=MoralisNftProvider.js.map
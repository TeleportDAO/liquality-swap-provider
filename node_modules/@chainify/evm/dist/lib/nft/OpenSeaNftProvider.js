"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenSeaNftProvider = void 0;
const client_1 = require("@chainify/client");
const types_1 = require("../types");
const EvmNftProvider_1 = require("./EvmNftProvider");
class OpenSeaNftProvider extends EvmNftProvider_1.EvmNftProvider {
    constructor(walletProvider, config) {
        super(walletProvider);
        this._httpClient = new client_1.HttpClient(Object.assign({ baseURL: config.url, responseType: 'text', transformResponse: undefined }, (config.apiKey && {
            headers: {
                'X-Api-Key': config.apiKey,
            },
        })));
    }
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            const userAddress = yield this.walletProvider.getAddress();
            const nfts = yield this._httpClient.nodeGet(`assets?owner=${userAddress}`);
            return nfts.assets.reduce((result, nft) => {
                if (nft.asset_contract) {
                    const { schema_name, address } = nft.asset_contract;
                    if (schema_name in types_1.NftTypes && address) {
                        this.cache[address] = {
                            contract: this.schemas[schema_name].attach(address),
                            schema: schema_name,
                        };
                        const { image_preview_url, image_thumbnail_url, image_original_url, asset_contract, collection, token_id, id, external_link, description, } = nft;
                        const { image_url, name, symbol } = asset_contract;
                        result.push({
                            asset_contract: {
                                address,
                                external_link,
                                image_url,
                                name,
                                symbol,
                            },
                            collection: {
                                name: collection.name,
                            },
                            description,
                            external_link,
                            id,
                            image_original_url,
                            image_preview_url,
                            image_thumbnail_url,
                            name,
                            token_id,
                        });
                    }
                }
                return result;
            }, []);
        });
    }
}
exports.OpenSeaNftProvider = OpenSeaNftProvider;
//# sourceMappingURL=OpenSeaNftProvider.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmChainProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const logger_1 = require("@chainify/logger");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const providers_1 = require("@ethersproject/providers");
const RpcFeeProvider_1 = require("../fee/RpcFeeProvider");
const typechain_1 = require("../typechain");
const utils_2 = require("../utils");
const EvmMulticallProvider_1 = require("./EvmMulticallProvider");
/**
 * Represents a connection to any EVM network.
 * Used to fetch chain specific data like blocks, transactions, balances and fees. It uses {@link https://docs.ethers.io/v5/api | ethersjs}
 *
 * Example:
 * ```typescript
 * import { providers } from 'ethers';
 * import { EvmNetworks, EvmChainProvider } from '@chainify/evm';
 *
 * const provider = new providers.StaticJsonRpcProvider(EvmNetworks.ganache.rpcUrl);
 * const chainProvider = new EvmChainProvider(EvmNetworks.ganache, provider, null);
 * ```
 * @public
 *
 */
class EvmChainProvider extends client_1.Chain {
    /**
     * @param network - See {@link EvmNetworks}
     * @param provider - Instance of {@link https://docs.ethers.io/v5/api/providers/jsonrpc-provider/#StaticJsonRpcProvider | StaticJsonRpcProvider}
     * If not passed, it's created internally based on the `rpcUrl` from the network parameter.
     * @param feeProvider - Instance of {@link Fee}.
     * If not passed, it uses {@link https://docs.ethers.io/v5/api/providers/provider/#Provider-getFeeData | getFeeData} from the ethers provider.
     */
    constructor(network, provider, feeProvider, multicall = true) {
        super(network, provider, feeProvider);
        this._logger = new logger_1.Logger(`EvmChainProvider ${network.chainId}`);
        if (!provider && this.network.rpcUrl) {
            this.provider = new providers_1.StaticJsonRpcProvider(this.network.rpcUrl, this.network.chainId);
        }
        if (!feeProvider) {
            this.feeProvider = new RpcFeeProvider_1.RpcFeeProvider(this.provider);
        }
        if (multicall) {
            this.multicall = new EvmMulticallProvider_1.EvmMulticallProvider(this.provider);
        }
    }
    /**
     * Used to fetch the name, decimals and symbols of an ERC20 token
     * @param asset - the address of the token contract
     * @returns
     */
    getTokenDetails(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.multicall) {
                    const [decimals, name, symbol] = yield this.multicall.multicall(['decimals', 'name', 'symbol'].map((method) => {
                        return {
                            target: asset,
                            abi: typechain_1.ERC20__factory.abi,
                            name: method,
                            params: [],
                        };
                    }));
                    return { decimals, name, symbol };
                }
                else {
                    const token = typechain_1.ERC20__factory.connect(asset, this.provider);
                    const [decimals, name, symbol] = yield Promise.all([token.decimals(), token.name(), token.symbol()]);
                    return { decimals, name, symbol };
                }
            }
            catch (err) {
                this._logger.error(err);
                throw new errors_1.NodeError(`Cannot fetch details for ${asset}`);
            }
        });
    }
    /**
     * @param blockHash - the hash of the block
     * @returns
     * If `includeTx` is `false` the `_raw` object type is {@link https://docs.ethers.io/v5/api/providers/types/#providers-Block | EthersBlock}.
     *
     * If `includeTx` is `true`  the `_raw` object type {@link https://docs.ethers.io/v5/api/providers/types/#providers-BlockWithTransactions | BlockWithTransactions}
     * and `transactions` array with type {@link https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse | EthersTransactionResponse}
     */
    getBlockByHash(blockHash, includeTx = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._getBlock((0, utils_1.ensure0x)(blockHash), includeTx);
        });
    }
    /**
     * @param blockNumber - the number of the block. If not passed, it fetches the latest block
     * @returns
     * If `includeTx` is `false` the `_raw` object type is {@link https://docs.ethers.io/v5/api/providers/types/#providers-Block | EthersBlock}.
     *
     * If `includeTx` is `true`  the `_raw` object type {@link https://docs.ethers.io/v5/api/providers/types/#providers-BlockWithTransactions | BlockWithTransactions}
     * and `transactions` array with type {@link https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse | EthersTransactionResponse}
     */
    getBlockByNumber(blockNumber, includeTx = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!blockNumber) {
                blockNumber = yield this.getBlockHeight();
            }
            return this._getBlock(blockNumber, includeTx);
        });
    }
    /**
     * @returns resolves with the latest block number
     */
    getBlockHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.getBlockNumber();
        });
    }
    /**
     * @param txHash - the transaction hash prefixed with `0x`
     * @returns a transaction object with _raw object type
     * of {@link https://docs.ethers.io/v5/api/providers/types/#providers-TransactionResponse | EthersTransactionResponse}
     */
    getTransactionByHash(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const _txHash = (0, utils_1.ensure0x)(txHash);
            const tx = yield this.provider.getTransaction(_txHash);
            if (!tx) {
                throw new errors_1.TxNotFoundError('Transaction not found');
            }
            const result = (0, utils_2.parseTxResponse)(tx);
            if (result.confirmations > 0) {
                const receipt = yield this.provider.getTransactionReceipt(_txHash);
                return (0, utils_2.parseTxResponse)(tx, receipt);
            }
            return result;
        });
    }
    /**
     * @param addresses - currently fetches the balances only for `addresses[0]`
     * @param assets - the list of assets
     * @returns - the balances of `assets` in the passed order
     */
    getBalance(addresses, assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = addresses[0].toString();
            if (this.multicall) {
                try {
                    const balances = yield this.multicall.getMultipleBalances(user, assets);
                    return balances;
                }
                catch (_err) {
                    // fallback to fetching without multicall
                    this.multicall = null;
                    const balances = yield this.getBalance(addresses, assets);
                    this.multicall = new EvmMulticallProvider_1.EvmMulticallProvider(this.provider);
                    return balances;
                }
            }
            else {
                const allBalancePromise = assets.map((a) => {
                    try {
                        if (a.type === types_1.AssetTypes.native) {
                            return this.provider.getBalance(user);
                        }
                        else {
                            return typechain_1.ERC20__factory.connect(a.contractAddress, this.provider).balanceOf(user);
                        }
                    }
                    catch (err) {
                        this._logger.debug(`no multicall getBalance error ${a}`, err);
                        return null;
                    }
                });
                const balances = (yield Promise.all(allBalancePromise)).map((b) => (b ? new types_1.BigNumber(b.toString()) : null));
                return balances;
            }
        });
    }
    /**
     * @param rawTransaction - the signed transaction
     * @returns the hash of the transaction
     */
    sendRawTransaction(rawTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.provider.sendTransaction((0, utils_1.ensure0x)(rawTransaction));
            return tx.hash;
        });
    }
    /**
     * If the `feeProvider` is not defined, it fetches the fees from {@link https://docs.ethers.io/v5/api/providers/provider/#Provider-getFeeData | getFeeData}
     */
    getFees() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.feeProvider.getFees();
        });
    }
    /**
     * @throws {@link UnsupportedMethodError} if the ethers provider doesn't support rpc calls
     */
    sendRpcRequest(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.provider.send) {
                throw new errors_1.UnsupportedMethodError('Method not supported.');
            }
            return this.provider.send(method, params);
        });
    }
    _getBlock(blockTag, includeTx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (includeTx) {
                const blockWithTx = yield this.provider.getBlockWithTransactions(blockTag);
                if (!blockWithTx) {
                    throw new errors_1.BlockNotFoundError(blockTag);
                }
                return (0, utils_2.parseBlockResponse)(blockWithTx, blockWithTx.transactions);
            }
            else {
                const block = yield this.provider.getBlock(blockTag);
                if (!block) {
                    throw new errors_1.BlockNotFoundError(blockTag);
                }
                return (0, utils_2.parseBlockResponse)(block);
            }
        });
    }
}
exports.EvmChainProvider = EvmChainProvider;
//# sourceMappingURL=EvmChainProvider.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmSwapProvider = void 0;
const utils_1 = require("@chainify/utils");
const EvmBaseSwapProvider_1 = require("./EvmBaseSwapProvider");
class EvmSwapProvider extends EvmBaseSwapProvider_1.EvmBaseSwapProvider {
    constructor(swapOptions, walletProvider) {
        super(swapOptions, walletProvider);
    }
    findInitiateSwapTransaction(swapParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentBlock = yield this.walletProvider.getChainProvider().getBlockHeight();
            return yield this.searchLogs((from, to) => __awaiter(this, void 0, void 0, function* () {
                const filter = yield this.contract.queryFilter(this.contract.filters.Initiate(), from, to);
                const initiate = filter.find((event) => {
                    // no need to call verifyInitiateSwapTransaction because if the transaction is failed, then the event won't be logged
                    // the event will only be logged if the tx is successful & confirmed
                    const isTrue = this.doesTransactionMatchInitiation(swapParams, { _raw: event });
                    return isTrue;
                });
                if (initiate) {
                    const tx = yield this.walletProvider.getChainProvider().getTransactionByHash(initiate.transactionHash);
                    return Object.assign(Object.assign({}, tx), { _raw: initiate });
                }
            }), currentBlock);
        });
    }
    findClaimSwapTransaction(swapParams, initTxHash) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const foundTx = yield this.findTx(swapParams, initTxHash, 'Claim');
            const secret = (_b = (_a = foundTx === null || foundTx === void 0 ? void 0 : foundTx._raw) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b.secret;
            if (secret) {
                return Object.assign(Object.assign({}, foundTx), { secret: (0, utils_1.remove0x)(secret) });
            }
        });
    }
    findRefundSwapTransaction(swapParams, initTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.findTx(swapParams, initTxHash, 'Refund');
        });
    }
    searchLogs(callback, currentBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            let from = utils_1.Math.sub(currentBlock, this.swapOptions.numberOfBlocksPerRequest).toString();
            let to = currentBlock.toString();
            while (utils_1.Math.gte(from, utils_1.Math.sub(currentBlock, this.swapOptions.totalNumberOfBlocks))) {
                const result = yield callback(Number(from), Number(to));
                if (result) {
                    return result;
                }
                from = utils_1.Math.sub(from, this.swapOptions.numberOfBlocksPerRequest).toString();
                to = utils_1.Math.sub(to, this.swapOptions.numberOfBlocksPerRequest).toString();
            }
        });
    }
    findTx(swapParams, initTxHash, eventFilter) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const txReceipt = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            if (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs) {
                for (const log of txReceipt.logs) {
                    const initiate = this.tryParseLog(log);
                    if (((_a = initiate === null || initiate === void 0 ? void 0 : initiate.args) === null || _a === void 0 ? void 0 : _a.id) && initiate.args.htlc) {
                        yield this.verifyInitiateSwapTransaction(swapParams, Object.assign(Object.assign({}, txReceipt), { _raw: initiate }));
                        const currentBlock = yield this.walletProvider.getChainProvider().getBlockHeight();
                        return yield this.searchLogs((from, to) => __awaiter(this, void 0, void 0, function* () {
                            const event = yield this.contract.queryFilter(this.contract.filters[eventFilter](initiate.args.id), from, to);
                            if (event.length > 1) {
                                throw Error(`This should never happen. Found more than one ${eventFilter} TX`);
                            }
                            else {
                                if (event[0]) {
                                    const tx = yield this.walletProvider.getChainProvider().getTransactionByHash(event[0].transactionHash);
                                    return Object.assign(Object.assign({}, tx), { _raw: event[0] });
                                }
                            }
                        }), currentBlock);
                    }
                }
            }
            return null;
        });
    }
}
exports.EvmSwapProvider = EvmSwapProvider;
//# sourceMappingURL=EvmSwapProvider.js.map
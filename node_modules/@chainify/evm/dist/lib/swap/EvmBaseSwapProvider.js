"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBaseSwapProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const constants_1 = require("@ethersproject/constants");
const typechain_1 = require("../typechain");
const utils_2 = require("../utils");
class EvmBaseSwapProvider extends client_1.Swap {
    constructor(swapOptions, walletProvider) {
        super(walletProvider);
        this.swapOptions = Object.assign(Object.assign({}, swapOptions), { contractAddress: (swapOptions === null || swapOptions === void 0 ? void 0 : swapOptions.contractAddress) || '0x133713376F69C1A67d7f3594583349DFB53d8166', numberOfBlocksPerRequest: (swapOptions === null || swapOptions === void 0 ? void 0 : swapOptions.numberOfBlocksPerRequest) || 2000, totalNumberOfBlocks: (swapOptions === null || swapOptions === void 0 ? void 0 : swapOptions.totalNumberOfBlocks) || 100000, gasLimitMargin: (swapOptions === null || swapOptions === void 0 ? void 0 : swapOptions.gasLimitMargin) || 1000 });
        if (walletProvider) {
            this.contract = typechain_1.LiqualityHTLC__factory.connect(this.swapOptions.contractAddress, this.walletProvider.getSigner());
        }
    }
    initiateSwap(swapParams, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            const parsedSwapParams = (0, utils_2.parseSwapParams)(swapParams);
            const value = swapParams.asset.type === types_1.AssetTypes.native ? parsedSwapParams.amount : 0;
            const tx = yield this.contract.populateTransaction.initiate(parsedSwapParams, { value });
            const estimatedGasLimit = yield this.contract.estimateGas.initiate(parsedSwapParams, { value });
            return yield this.walletProvider.sendTransaction((0, utils_2.toEthereumTxRequest)(Object.assign(Object.assign({}, tx), { gasLimit: (0, utils_2.calculateGasMargin)(estimatedGasLimit, this.swapOptions.gasLimitMargin) }), fee));
        });
    }
    claimSwap(swapParams, initTxHash, secret, fee) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.validateSecret)(secret);
            (0, utils_1.validateSecretAndHash)(secret, swapParams.secretHash);
            const transaction = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, transaction);
            if (transaction === null || transaction === void 0 ? void 0 : transaction.logs) {
                for (const log of transaction.logs) {
                    const initiate = this.tryParseLog(log);
                    if ((_a = initiate === null || initiate === void 0 ? void 0 : initiate.args) === null || _a === void 0 ? void 0 : _a.id) {
                        const secret0x = (0, utils_1.ensure0x)(secret);
                        const tx = yield this.contract.populateTransaction.claim(initiate.args.id, secret0x);
                        const estimatedGasLimit = yield this.contract.estimateGas.claim(initiate.args.id, secret0x);
                        const txResponse = yield this.walletProvider.sendTransaction((0, utils_2.toEthereumTxRequest)(Object.assign(Object.assign({}, tx), { gasLimit: (0, utils_2.calculateGasMargin)(estimatedGasLimit, this.swapOptions.gasLimitMargin) }), fee));
                        return txResponse;
                    }
                }
            }
        });
    }
    refundSwap(swapParams, initTxHash, fee) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, transaction);
            if (transaction === null || transaction === void 0 ? void 0 : transaction.logs) {
                for (const log of transaction.logs) {
                    const initiate = this.tryParseLog(log);
                    if ((_a = initiate === null || initiate === void 0 ? void 0 : initiate.args) === null || _a === void 0 ? void 0 : _a.id) {
                        const tx = yield this.contract.populateTransaction.refund(initiate.args.id);
                        const estimatedGasLimit = yield this.contract.estimateGas.refund(initiate.args.id);
                        const txResponse = yield this.walletProvider.sendTransaction((0, utils_2.toEthereumTxRequest)(Object.assign(Object.assign({}, tx), { gasLimit: (0, utils_2.calculateGasMargin)(estimatedGasLimit, this.swapOptions.gasLimitMargin) }), fee));
                        return txResponse;
                    }
                }
            }
        });
    }
    getSwapSecret(claimTx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = yield this.walletProvider.getChainProvider().getTransactionByHash(claimTx);
            if (!transaction) {
                throw new errors_1.TxNotFoundError(`Transaction not found: ${claimTx}`);
            }
            if (transaction === null || transaction === void 0 ? void 0 : transaction.logs) {
                for (const log of transaction.logs) {
                    const claim = this.tryParseLog(log);
                    if (((_a = claim === null || claim === void 0 ? void 0 : claim.args) === null || _a === void 0 ? void 0 : _a.id) && claim.args.secret) {
                        return (0, utils_1.remove0x)(claim.args.secret);
                    }
                }
            }
        });
    }
    canUpdateFee() {
        return false;
    }
    updateTransactionFee(_tx, _newFee) {
        throw new errors_1.UnimplementedMethodError('Method not supported.');
    }
    onWalletProviderUpdate(wallet) {
        this.contract = typechain_1.LiqualityHTLC__factory.connect(this.swapOptions.contractAddress, wallet.getSigner());
    }
    doesTransactionMatchInitiation(swapParams, transaction) {
        var _a;
        let htlcArgs = (_a = transaction === null || transaction === void 0 ? void 0 : transaction._raw) === null || _a === void 0 ? void 0 : _a.args;
        if (!htlcArgs) {
            if (transaction === null || transaction === void 0 ? void 0 : transaction.logs) {
                for (const log of transaction.logs) {
                    const initiate = this.tryParseLog(log);
                    if (initiate) {
                        htlcArgs = initiate.args;
                    }
                }
            }
        }
        if (htlcArgs) {
            return (utils_1.Math.eq(htlcArgs.htlc.amount, swapParams.value) &&
                utils_1.Math.eq(htlcArgs.htlc.expiration, swapParams.expiration) &&
                (0, utils_1.compare)(htlcArgs.htlc.recipientAddress, (0, utils_1.ensure0x)(swapParams.recipientAddress.toString())) &&
                (0, utils_1.compare)(htlcArgs.htlc.refundAddress, (0, utils_1.ensure0x)(swapParams.refundAddress.toString())) &&
                (0, utils_1.compare)(htlcArgs.htlc.tokenAddress, swapParams.asset.type === types_1.AssetTypes.native ? constants_1.AddressZero : swapParams.asset.contractAddress) &&
                (0, utils_1.compare)((0, utils_1.ensure0x)(htlcArgs.htlc.secretHash), (0, utils_1.ensure0x)(swapParams.secretHash)));
        }
    }
    tryParseLog(log) {
        try {
            return this.contract.interface.parseLog(log);
        }
        catch (err) {
            if (err.code === 'INVALID_ARGUMENT' && err.argument === 'topichash') {
                return null;
            }
            else {
                throw err;
            }
        }
    }
}
exports.EvmBaseSwapProvider = EvmBaseSwapProvider;
//# sourceMappingURL=EvmBaseSwapProvider.js.map
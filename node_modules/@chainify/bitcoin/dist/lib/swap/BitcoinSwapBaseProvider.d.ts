/// <reference types="node" />
import { Swap } from '@chainify/client';
import { SwapParams, Transaction } from '@chainify/types';
import { payments } from 'bitcoinjs-lib';
import { BitcoinBaseChainProvider } from '../chain/BitcoinBaseChainProvider';
import { BitcoinNetwork, Input, SwapMode, Transaction as BitcoinTransaction } from '../types';
import { IBitcoinWallet } from '../wallet/IBitcoinWallet';
import { BitcoinSwapProviderOptions, TransactionMatchesFunction } from './types';
export declare abstract class BitcoinSwapBaseProvider extends Swap<BitcoinBaseChainProvider, null, IBitcoinWallet<BitcoinBaseChainProvider>> {
    protected _network: BitcoinNetwork;
    protected _mode: SwapMode;
    constructor(options: BitcoinSwapProviderOptions, walletProvider?: IBitcoinWallet<BitcoinBaseChainProvider>);
    validateSwapParams(swapParams: SwapParams): void;
    initiateSwap(swapParams: SwapParams, feePerByte: number): Promise<Transaction<any>>;
    claimSwap(swapParams: SwapParams, initiationTxHash: string, secret: string, feePerByte: number): Promise<Transaction<BitcoinTransaction>>;
    refundSwap(swapParams: SwapParams, initiationTxHash: string, feePerByte: number): Promise<Transaction<BitcoinTransaction>>;
    findInitiateSwapTransaction(swapParams: SwapParams, blockNumber?: number): Promise<Transaction<any>>;
    getSwapSecret(claimTxHash: string, initTxHash: string): Promise<string>;
    findClaimSwapTransaction(swapParams: SwapParams, initTxHash: string, blockNumber?: number): Promise<Transaction<any>>;
    findRefundSwapTransaction(swapParams: SwapParams, initiationTxHash: string, blockNumber?: number): Promise<Transaction<any>>;
    protected onWalletProviderUpdate(_wallet: IBitcoinWallet<BitcoinBaseChainProvider, any>): void;
    protected getSwapOutput(swapParams: SwapParams): Buffer;
    private getSwapInput;
    protected getSwapPaymentVariants(swapOutput: Buffer): {
        p2wsh: payments.Payment;
        p2shSegwit: payments.Payment;
        p2sh: payments.Payment;
    };
    private _redeemSwap;
    private _redeemSwapOutput;
    protected extractSwapParams(outputScript: string): {
        recipientPublicKey: string;
        refundPublicKey: string;
        secretHash: string;
        expiration: number;
    };
    /**
     * Only to be used for situations where transaction is trusted. e.g to bump fee
     * DO NOT USE THIS TO VERIFY THE REDEEM
     */
    private UNSAFE_isSwapRedeemTransaction;
    canUpdateFee(): boolean;
    updateTransactionFee(tx: Transaction<BitcoinTransaction> | string, newFeePerByte: number): Promise<Transaction<any>>;
    protected getInputScript(vin: Input): string[];
    protected doesTransactionMatchRedeem(initiationTxHash: string, tx: Transaction<BitcoinTransaction>, isRefund: boolean): boolean;
    protected doesTransactionMatchInitiation(swapParams: SwapParams, transaction: Transaction<BitcoinTransaction>): boolean;
    protected abstract findSwapTransaction(swapParams: SwapParams, blockNumber: number, predicate: TransactionMatchesFunction): Promise<Transaction<BitcoinTransaction>>;
}

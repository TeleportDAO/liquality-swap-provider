"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinSwapEsploraProvider = void 0;
const client_1 = require("@chainify/client");
const BitcoinSwapBaseProvider_1 = require("./BitcoinSwapBaseProvider");
class BitcoinSwapEsploraProvider extends BitcoinSwapBaseProvider_1.BitcoinSwapBaseProvider {
    constructor(options, walletProvider) {
        super(options, walletProvider);
        this._httpClient = new client_1.HttpClient({ baseURL: options.scraperUrl });
    }
    findSwapTransaction(swapParams, _blockNumber, predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentHeight = yield this.walletProvider.getChainProvider().getBlockHeight();
            const swapOutput = this.getSwapOutput(swapParams);
            const paymentVariants = this.getSwapPaymentVariants(swapOutput);
            for (const paymentVariant of Object.values(paymentVariants)) {
                const addressTransaction = this.findAddressTransaction(paymentVariant.address, currentHeight, predicate);
                if (addressTransaction)
                    return addressTransaction;
            }
        });
    }
    findAddressTransaction(address, currentHeight, predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: This does not go through pages as swap addresses have at most 2 transactions
            // Investigate whether retrieving more transactions is required.
            const transactions = yield this._httpClient.nodeGet(`/address/${address}/txs`);
            for (const transaction of transactions) {
                const formattedTransaction = yield this.walletProvider
                    .getChainProvider()
                    .getProvider()
                    .formatTransaction(transaction, currentHeight);
                if (predicate(formattedTransaction)) {
                    return formattedTransaction;
                }
            }
        });
    }
}
exports.BitcoinSwapEsploraProvider = BitcoinSwapEsploraProvider;
//# sourceMappingURL=BitcoinSwapEsploraProvider.js.map
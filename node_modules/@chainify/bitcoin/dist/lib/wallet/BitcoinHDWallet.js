"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinHDWalletProvider = void 0;
const bip32_1 = require("bip32");
const bip39_1 = require("bip39");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const bitcoinjs_message_1 = require("bitcoinjs-message");
const types_1 = require("../types");
const BitcoinBaseWallet_1 = require("./BitcoinBaseWallet");
class BitcoinHDWalletProvider extends BitcoinBaseWallet_1.BitcoinBaseWalletProvider {
    constructor(options, chainProvider) {
        const { mnemonic, baseDerivationPath, addressType = types_1.AddressType.BECH32, network } = options;
        super({ baseDerivationPath, addressType, network }, chainProvider);
        if (!mnemonic) {
            throw new Error('Mnemonic should not be empty');
        }
        this._mnemonic = mnemonic;
    }
    canUpdateFee() {
        return true;
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses[0];
        });
    }
    getBalance(_assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return yield this.chainProvider.getBalance(addresses, _assets);
        });
    }
    signMessage(message, from) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getWalletAddress(from);
            const keyPair = yield this.keyPair(address.derivationPath);
            const signature = yield (0, bitcoinjs_message_1.signAsync)(message, keyPair.privateKey, keyPair.compressed);
            return signature.toString('hex');
        });
    }
    exportPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._toWIF(this._baseDerivationPath);
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._network;
        });
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    baseDerivationNode() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._baseDerivationNode) {
                return this._baseDerivationNode;
            }
            const baseNode = yield this.seedNode();
            this._baseDerivationNode = baseNode.derivePath(this._baseDerivationPath);
            return this._baseDerivationNode;
        });
    }
    buildTransaction(targets, feePerByte, fixedInputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const network = this._network;
            const unusedAddress = yield this.getUnusedAddress(true);
            const { inputs, change, fee } = yield this.getInputsForAmount(targets, feePerByte, fixedInputs);
            if (change) {
                targets.push({
                    address: unusedAddress.address,
                    value: change.value,
                });
            }
            const psbt = new bitcoinjs_lib_1.Psbt({ network });
            const needsWitness = [types_1.AddressType.BECH32, types_1.AddressType.P2SH_SEGWIT].includes(this._addressType);
            for (let i = 0; i < inputs.length; i++) {
                const wallet = yield this.getWalletAddress(inputs[i].address);
                const keyPair = yield this.keyPair(wallet.derivationPath);
                const paymentVariant = this.getPaymentVariantFromPublicKey(keyPair.publicKey);
                const psbtInput = {
                    hash: inputs[i].txid,
                    index: inputs[i].vout,
                    sequence: 0,
                };
                if (needsWitness) {
                    psbtInput.witnessUtxo = {
                        script: paymentVariant.output,
                        value: inputs[i].value,
                    };
                }
                else {
                    const inputTxRaw = yield this.chainProvider.getProvider().getRawTransactionByHash(inputs[i].txid);
                    psbtInput.nonWitnessUtxo = Buffer.from(inputTxRaw, 'hex');
                }
                if (this._addressType === types_1.AddressType.P2SH_SEGWIT) {
                    psbtInput.redeemScript = paymentVariant.redeem.output;
                }
                psbt.addInput(psbtInput);
            }
            for (const output of targets) {
                if (output.script) {
                    psbt.addOutput({
                        value: output.value,
                        script: output.script,
                    });
                }
                else {
                    psbt.addOutput({
                        value: output.value,
                        address: output.address,
                    });
                }
            }
            for (let i = 0; i < inputs.length; i++) {
                const wallet = yield this.getWalletAddress(inputs[i].address);
                const keyPair = yield this.keyPair(wallet.derivationPath);
                psbt.signInput(i, keyPair);
                psbt.validateSignaturesOfInput(i);
            }
            psbt.finalizeAllInputs();
            return { hex: psbt.extractTransaction().toHex(), fee };
        });
    }
    buildSweepTransaction(externalChangeAddress, feePerByte) {
        return __awaiter(this, void 0, void 0, function* () {
            let _feePerByte = feePerByte || null; // TODO: fix me
            if (!_feePerByte) {
                _feePerByte = yield this.chainProvider.getProvider().getFeePerByte();
            }
            const { inputs, outputs, change } = yield this.getInputsForAmount([], _feePerByte, [], 100, true);
            if (change) {
                throw new Error('There should not be any change for sweeping transaction');
            }
            const _outputs = [{ address: externalChangeAddress, value: outputs[0].value }];
            // TODO: fix the inherited legacy code
            return this.buildTransaction(_outputs, feePerByte, inputs);
        });
    }
    signPSBT(data, inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const psbt = bitcoinjs_lib_1.Psbt.fromBase64(data, { network: this._network });
            for (const input of inputs) {
                const keyPair = yield this.keyPair(input.derivationPath);
                psbt.signInput(input.index, keyPair);
            }
            return psbt.toBase64();
        });
    }
    signBatchP2SHTransaction(inputs, addresses, tx, lockTime, segwit) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPairs = [];
            for (const address of addresses) {
                const wallet = yield this.getWalletAddress(address);
                const keyPair = yield this.keyPair(wallet.derivationPath);
                keyPairs.push(keyPair);
            }
            const sigs = [];
            for (let i = 0; i < inputs.length; i++) {
                const index = inputs[i].txInputIndex ? inputs[i].txInputIndex : inputs[i].index;
                let sigHash;
                if (segwit) {
                    sigHash = tx.hashForWitnessV0(index, inputs[i].outputScript, inputs[i].vout.vSat, bitcoinjs_lib_1.Transaction.SIGHASH_ALL);
                }
                else {
                    sigHash = tx.hashForSignature(index, inputs[i].outputScript, bitcoinjs_lib_1.Transaction.SIGHASH_ALL);
                }
                const sig = bitcoinjs_lib_1.script.signature.encode(keyPairs[i].sign(sigHash), bitcoinjs_lib_1.Transaction.SIGHASH_ALL);
                sigs.push(sig);
            }
            return sigs;
        });
    }
    keyPair(derivationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const wif = yield this._toWIF(derivationPath);
            return bitcoinjs_lib_1.ECPair.fromWIF(wif, this._network);
        });
    }
    _toWIF(derivationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = yield this.seedNode();
            return node.derivePath(derivationPath).toWIF();
        });
    }
    seedNode() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._seedNode) {
                return this._seedNode;
            }
            const seed = yield (0, bip39_1.mnemonicToSeed)(this._mnemonic);
            this._seedNode = (0, bip32_1.fromSeed)(seed, this._network);
            return this._seedNode;
        });
    }
}
exports.BitcoinHDWalletProvider = BitcoinHDWalletProvider;
//# sourceMappingURL=BitcoinHDWallet.js.map
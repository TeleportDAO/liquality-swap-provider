/// <reference types="node" />
import { Chain, Wallet } from '@chainify/client';
import { Address, AddressType, Asset, Transaction, TransactionRequest } from '@chainify/types';
import { BIP32Interface } from 'bip32';
import { payments } from 'bitcoinjs-lib';
import { BitcoinBaseChainProvider } from '../chain/BitcoinBaseChainProvider';
import { AddressType as BtcAddressType, BitcoinNetwork, BitcoinWalletProviderOptions, Input, OutputTarget, P2SHInput, PsbtInputTarget, Transaction as BtcTransaction, UTXO } from '../types';
import { CoinSelectTarget } from '../utils';
export declare enum AddressSearchType {
    EXTERNAL = 0,
    CHANGE = 1,
    EXTERNAL_OR_CHANGE = 2
}
declare type DerivationCache = {
    [index: string]: Address;
};
export declare abstract class BitcoinBaseWalletProvider<T extends BitcoinBaseChainProvider = any, S = any> extends Wallet<T, S> {
    protected _baseDerivationPath: string;
    protected _network: BitcoinNetwork;
    protected _addressType: BtcAddressType;
    protected _derivationCache: DerivationCache;
    constructor(options: BitcoinWalletProviderOptions, chainProvider?: Chain<T>);
    protected onChainProviderUpdate(chainProvider: Chain<T>): void;
    protected abstract baseDerivationNode(): Promise<BIP32Interface>;
    protected abstract buildTransaction(targets: OutputTarget[], feePerByte?: number, fixedInputs?: Input[]): Promise<{
        hex: string;
        fee: number;
    }>;
    protected abstract buildSweepTransaction(externalChangeAddress: string, feePerByte?: number): Promise<{
        hex: string;
        fee: number;
    }>;
    abstract signPSBT(data: string, inputs: PsbtInputTarget[]): Promise<string>;
    abstract signBatchP2SHTransaction(inputs: P2SHInput[], addresses: string, tx: any, lockTime?: number, segwit?: boolean): Promise<Buffer[]>;
    getDerivationCache(): DerivationCache;
    getUnusedAddress(change?: boolean, numAddressPerCall?: number): Promise<Address>;
    getUsedAddresses(numAddressPerCall?: number): Promise<Address[]>;
    getAddresses(startingIndex?: number, numAddresses?: number, change?: boolean): Promise<Address[]>;
    sendTransaction(options: TransactionRequest): Promise<Transaction<BtcTransaction>>;
    sendBatchTransaction(transactions: TransactionRequest[]): Promise<Transaction<BtcTransaction>[]>;
    sendSweepTransaction(externalChangeAddress: AddressType, _asset: Asset, feePerByte: number): Promise<Transaction<BtcTransaction>>;
    updateTransactionFee(tx: Transaction<BtcTransaction> | string, newFeePerByte: number): Promise<Transaction<BtcTransaction>>;
    getTotalFees(transactions: TransactionRequest[], max: boolean): Promise<any>;
    protected _sendTransaction(transactions: OutputTarget[], feePerByte?: number): Promise<Transaction<BtcTransaction>>;
    protected findAddress(addresses: string[], change?: boolean): Promise<Address>;
    getWalletAddress(address: string): Promise<Address>;
    protected getDerivationPathAddress(path: string): Promise<Address>;
    protected _getUsedUnusedAddresses(numAddressPerCall: number, addressType: AddressSearchType): Promise<{
        usedAddresses: Address[];
        unusedAddress: {
            change: Address;
            external: Address;
        };
    }>;
    protected withCachedUtxos(func: () => any): Promise<any>;
    protected getTotalFee(opts: TransactionRequest, max: boolean): Promise<number>;
    protected getInputsForAmount(_targets: OutputTarget[], feePerByte?: number, fixedInputs?: Input[], numAddressPerCall?: number, sweep?: boolean): Promise<{
        inputs: UTXO[];
        change: CoinSelectTarget;
        outputs: CoinSelectTarget[];
        fee: number;
    }>;
    protected sendOptionsToOutputs(transactions: TransactionRequest[]): OutputTarget[];
    protected getAddressFromPublicKey(publicKey: Buffer): string;
    protected getPaymentVariantFromPublicKey(publicKey: Buffer): payments.Payment;
}
export {};

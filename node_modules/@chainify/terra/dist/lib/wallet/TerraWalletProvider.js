"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraWalletProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const terra_js_1 = require("@terra-money/terra.js");
const constants_1 = require("../constants");
class TerraWalletProvider extends client_1.Wallet {
    constructor(walletOptions, chainProvider) {
        const { mnemonic, derivationPath, gasAdjustment = constants_1.DEFAULT_GAS_ADJUSTMENT } = walletOptions;
        super(chainProvider);
        this.signer = new terra_js_1.MnemonicKey({ mnemonic });
        this._derivationPath = derivationPath;
        this._mnemonic = mnemonic;
        this._addressCache = {};
        this._wallet = this.chainProvider
            ? new terra_js_1.Wallet(this.chainProvider.getProvider(), this.signer)
            : new terra_js_1.Wallet(null, this.signer);
        this._gasAdjustment = gasAdjustment;
    }
    exportPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.signer.privateKey.toString('hex');
        });
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses.length > 0;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._addressCache[this._mnemonic]) {
                return this._addressCache[this._mnemonic];
            }
            const wallet = new terra_js_1.MnemonicKey({ mnemonic: this._mnemonic });
            const result = new types_1.Address({
                address: wallet.accAddress,
                derivationPath: this._derivationPath,
                publicKey: wallet.publicKey.pubkeyAddress(),
            });
            this._addressCache[this._mnemonic] = result;
            return result;
        });
    }
    getAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            return [address];
        });
    }
    getUsedAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getAddresses();
        });
    }
    getUnusedAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses[0];
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const signed = yield this.signer.sign(Buffer.from(message));
            return signed.toString('hex');
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainProvider.getNetwork();
        });
    }
    sendTransaction(txRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            // handle value transfers
            if (!txRequest.msgs) {
                txRequest.msgs = this.createSendMessage(txRequest);
            }
            else {
                // handle contract calls
            }
            const terraTx = yield this.buildTransaction(txRequest);
            const signedTx = yield this._wallet.createAndSignTx(terraTx);
            return yield this.broadcastTx(signedTx);
        });
    }
    sendSweepTransaction(address, asset) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            const balance = yield this.chainProvider.getBalance(addresses, [asset]);
            return yield this.sendTransaction({ to: address, value: balance[0] });
        });
    }
    getSigner() {
        return this.signer;
    }
    // TODO: implement this
    sendBatchTransaction(_txRequests) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Method not implemented.');
        });
    }
    updateTransactionFee(_tx, _newFee) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnimplementedMethodError('Method not supported.');
        });
    }
    getBalance(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return this.chainProvider.getBalance(addresses, assets);
        });
    }
    canUpdateFee() {
        return false;
    }
    onChainProviderUpdate(chainProvider) {
        this._wallet = new terra_js_1.Wallet(chainProvider.getProvider(), this.signer);
    }
    createSendMessage(txRequest) {
        const sender = this.signer.accAddress;
        const recipient = txRequest.to.toString();
        // handle UST & Luna
        if (txRequest.asset.type === types_1.AssetTypes.native) {
            return [
                new terra_js_1.MsgSend(this.signer.accAddress, recipient, {
                    [constants_1.assetCodeToDenom[txRequest.asset.code]]: txRequest.value.toNumber(),
                }),
            ];
        }
        // handle tokens
        else {
            return [
                new terra_js_1.MsgExecuteContract(sender, txRequest.asset.contractAddress, {
                    transfer: {
                        recipient,
                        amount: txRequest.value.toString(),
                    },
                }),
            ];
        }
    }
    broadcastTx(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.chainProvider.getProvider();
            const txResult = yield provider.tx.broadcastSync(tx);
            // exponential backoff => total of 63,5 seconds
            const txReceipt = yield (0, utils_1.retry)(() => __awaiter(this, void 0, void 0, function* () { return this.chainProvider.getTransactionByHash(txResult.txhash); }), 500, 2, 7);
            if ((0, terra_js_1.isTxError)(txReceipt._raw)) {
                throw new Error(`Encountered an error while running the transaction: ${txReceipt._raw.code} ${txReceipt._raw.codespace} ${txReceipt._raw.raw_log}`);
            }
            return txReceipt;
        });
    }
    buildTransaction(txRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const feeDenom = constants_1.assetCodeToDenom[txRequest.feeAsset.code];
            const terraTx = {
                msgs: txRequest.msgs,
                memo: txRequest.memo || txRequest.data,
                feeDenoms: [feeDenom],
            };
            let estimatedGas = txRequest.gasLimit;
            if (!estimatedGas) {
                /* simulation: estimate gas */
                const simulatedTx = yield (0, utils_1.retry)(() => __awaiter(this, void 0, void 0, function* () { return this._wallet.createTx(terraTx); }), 1000, 2, 2);
                estimatedGas = Math.ceil(simulatedTx.auth_info.fee.gas_limit * this._gasAdjustment);
            }
            if (txRequest.fee) {
                const feeAmount = new types_1.BigNumber(estimatedGas).times(Number(txRequest.fee)).integerValue(types_1.BigNumber.ROUND_CEIL).toString();
                const terraFee = new terra_js_1.Fee(estimatedGas, new terra_js_1.Coins([terra_js_1.Coin.fromData({ amount: feeAmount, denom: feeDenom })]));
                return Object.assign(Object.assign({}, terraTx), { fee: terraFee });
            }
            return terraTx;
        });
    }
}
exports.TerraWalletProvider = TerraWalletProvider;
//# sourceMappingURL=TerraWalletProvider.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraChainProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const logger_1 = require("@chainify/logger");
const types_1 = require("@chainify/types");
const terra_js_1 = require("@terra-money/terra.js");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const logger = new logger_1.Logger('TerraChainProvider');
const DEFAULT_ASSETS_FETCH_URL = 'https://assets.terra.money/cw20/tokens.json';
class TerraChainProvider extends client_1.Chain {
    constructor(network, provider, feeProvider) {
        super(network, provider, feeProvider);
        if (!provider) {
            this.provider = new terra_js_1.LCDClient({ URL: network.rpcUrl, chainID: network.chainId.toString() });
        }
        this._httpClient = new client_1.HttpClient({ baseURL: network.helperUrl });
    }
    getTokenDetails(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield client_1.HttpClient.get(this.network.assetsUrl || DEFAULT_ASSETS_FETCH_URL);
                const token = result.mainnet[asset];
                const { symbol } = token;
                return { name: symbol, symbol, decimals: 6 };
            }
            catch (err) {
                logger.error(err);
                throw new errors_1.NodeError(`Cannot fetch details for ${asset}`);
            }
        });
    }
    getBlockByNumber(blockNumber, includeTx) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = yield this.provider.tendermint.blockInfo(blockNumber);
            const currentBlockNumber = yield this.getBlockHeight();
            if (!includeTx) {
                return (0, utils_1.parseBlockResponse)(block);
            }
            else {
                const txs = yield this.provider.tx.txInfosByHeight(Number(block.block.header.height));
                const transactions = txs.map((tx) => (0, utils_1.parseTxResponse)(tx, currentBlockNumber));
                return Object.assign(Object.assign({}, (0, utils_1.parseBlockResponse)(block)), { transactions });
            }
        });
    }
    getBlockHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            const blockInfo = yield this.provider.tendermint.blockInfo();
            return Number(blockInfo.block.header.height);
        });
    }
    getTransactionByHash(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = yield this.provider.tx.txInfo(txHash);
            const currentBlockNumber = yield this.getBlockHeight();
            if (!transaction) {
                throw new errors_1.TxNotFoundError(`Transaction not found: ${txHash}`);
            }
            return (0, utils_1.parseTxResponse)(transaction, currentBlockNumber);
        });
    }
    getBalance(addresses, assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = addresses[0].toString();
            const promiseBalances = yield Promise.all(assets.map((asset) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    let balance = 0;
                    if (asset.type === types_1.AssetTypes.native) {
                        const coins = yield this.provider.bank.balance(address);
                        balance = Number((_a = coins[0].get(constants_1.assetCodeToDenom[asset.code])) === null || _a === void 0 ? void 0 : _a.amount) || 0;
                    }
                    else {
                        const token = yield this.provider.wasm.contractQuery(asset.contractAddress, {
                            balance: { address },
                        });
                        balance = Number(token.balance);
                    }
                    return new types_1.BigNumber(balance);
                }
                catch (err) {
                    if (err.message && err.message.includes('does not exist while viewing')) {
                        return new types_1.BigNumber(0);
                    }
                    else {
                        logger.debug('getBalance', err);
                        return null;
                    }
                }
            })));
            return promiseBalances;
        });
    }
    getFees(feeAsset) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.feeProvider) {
                return this.feeProvider.getFees(feeAsset);
            }
            else {
                const prices = yield this._httpClient.nodeGet('/txs/gas_prices');
                const denom = constants_1.assetCodeToDenom[(feeAsset === null || feeAsset === void 0 ? void 0 : feeAsset.code) || 'LUNA'];
                const fee = Number(prices[denom]);
                return {
                    slow: { fee },
                    average: { fee },
                    fast: { fee },
                };
            }
        });
    }
    sendRpcRequest(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const [endpoint, args] = params;
            return this.provider.apiRequester[method](endpoint, args);
        });
    }
    getBlockByHash(_blockHash, _includeTx) {
        throw new errors_1.UnsupportedMethodError('Method not supported.');
    }
    sendRawTransaction(_rawTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnsupportedMethodError('Method not supported.');
        });
    }
}
exports.TerraChainProvider = TerraChainProvider;
//# sourceMappingURL=TerraChainProvider.js.map
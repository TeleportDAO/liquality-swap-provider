"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraSwapProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const terra_js_1 = require("@terra-money/terra.js");
const constants_1 = require("../constants");
const TerraSwapBaseProvider_1 = require("./TerraSwapBaseProvider");
class TerraSwapProvider extends TerraSwapBaseProvider_1.TerraSwapBaseProvider {
    constructor(helperUrl, walletProvider) {
        super(walletProvider);
        this._httpClient = new client_1.HttpClient({ baseURL: helperUrl });
    }
    findInitiateSwapTransaction(swapParams) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            return yield this.findAddressTransaction(swapParams.refundAddress.toString(), (tx) => __awaiter(this, void 0, void 0, function* () { return yield this.doesTransactionMatchInitiation(swapParams, tx); }));
        });
    }
    findClaimSwapTransaction(swapParams, initTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const initTx = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, initTx);
            return yield this.findAddressTransaction(initTx.to.toString(), (tx) => __awaiter(this, void 0, void 0, function* () {
                if (tx.secret && tx._raw.method === 'claim') {
                    (0, utils_1.validateSecret)(tx.secret);
                    (0, utils_1.validateSecretAndHash)(tx.secret, swapParams.secretHash);
                    return true;
                }
            }));
        });
    }
    findRefundSwapTransaction(swapParams, initTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const initTx = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, initTx);
            return yield this.findAddressTransaction(initTx.to.toString(), (tx) => __awaiter(this, void 0, void 0, function* () {
                if (tx._raw.method === 'refund') {
                    return true;
                }
            }));
        });
    }
    onWalletProviderUpdate(_wallet) {
        // do nothing
    }
    findAddressTransaction(address, predicate, limit = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            let offset = null;
            const currentBlockNumber = yield this.walletProvider.getChainProvider().getBlockHeight();
            const baseUrl = `/txs?account=${address}&limit=${limit}`;
            do {
                const url = offset ? baseUrl + `&offset=${offset}` : baseUrl;
                const response = yield this._httpClient.nodeGet(url);
                if (!(response === null || response === void 0 ? void 0 : response.txs)) {
                    throw new errors_1.TxNotFoundError(`Transactions not found: ${address}`);
                }
                for (const tx of response.txs) {
                    const parsedTx = yield this.parseScraperTransaction(tx, currentBlockNumber);
                    const doesMatch = yield predicate(parsedTx);
                    if (doesMatch) {
                        return parsedTx;
                    }
                }
                offset = response.next || null;
            } while (offset !== null);
        });
    }
    parseScraperTransaction(data, currentBlockNumber) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            const result = {
                hash: data.txhash,
                _raw: { code: data.code },
                value: 0,
                confirmations: Number(data.height) - currentBlockNumber,
                status: (0, terra_js_1.isTxError)(data) ? types_1.TxStatus.Failed : types_1.TxStatus.Success,
            };
            const txType = (_d = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.tx) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.msg) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.type;
            switch (txType) {
                // Init
                case 'wasm/MsgInstantiateContract': {
                    const initTx = data.tx.value.msg[0].value;
                    if (initTx) {
                        const network = yield this.getWallet().getConnectedNetwork();
                        // only valid txns
                        if (Number(initTx.code_id) === network.codeId) {
                            const initMsg = initTx.init_msg;
                            if (initMsg) {
                                result._raw.htlc = Object.assign(Object.assign({}, initMsg), { code_id: Number(initTx.code_id) });
                                result._raw.method = 'init';
                            }
                            result.from = initTx.sender;
                            if ((_e = initTx.init_coins) === null || _e === void 0 ? void 0 : _e[0]) {
                                const { amount, denom } = initTx.init_coins[0];
                                result.value = Number(amount);
                                result.valueAsset = constants_1.denomToAssetCode[denom];
                            }
                            if ((_h = (_g = (_f = data.tx.value) === null || _f === void 0 ? void 0 : _f.fee) === null || _g === void 0 ? void 0 : _g.amount) === null || _h === void 0 ? void 0 : _h[0]) {
                                const { amount, denom } = data.tx.value.fee.amount[0];
                                result.fee = Number(amount);
                                result.feeAssetCode = constants_1.denomToAssetCode[denom];
                            }
                        }
                    }
                    break;
                }
                // refund & claim
                case 'wasm/MsgExecuteContract': {
                    const tx = data.tx.value.msg[0].value;
                    if (tx) {
                        result.from = tx.sender;
                        result.to = tx.contract;
                        if (tx.execute_msg.refund) {
                            result._raw.method = 'refund';
                        }
                        else if (tx.execute_msg.claim) {
                            result._raw.method = 'claim';
                            result.secret = tx.execute_msg.claim.secret;
                        }
                    }
                    break;
                }
            }
            return result;
        });
    }
}
exports.TerraSwapProvider = TerraSwapProvider;
//# sourceMappingURL=TerraSwapProvider.js.map
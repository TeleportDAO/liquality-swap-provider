"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraSwapBaseProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const utils_1 = require("@chainify/utils");
const terra_js_1 = require("@terra-money/terra.js");
const constants_1 = require("../constants");
class TerraSwapBaseProvider extends client_1.Swap {
    initiateSwap(swapParams, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            const address = yield this.walletProvider.getAddress();
            const { codeId } = yield this.walletProvider.getConnectedNetwork();
            const initMsg = [
                new terra_js_1.MsgInstantiateContract(
                // user
                address.toString(), 
                // admin
                null, 
                // bytecode
                codeId, 
                // swap params
                {
                    buyer: swapParams.recipientAddress.toString(),
                    seller: swapParams.refundAddress.toString(),
                    expiration: swapParams.expiration,
                    value: swapParams.value.toNumber(),
                    secret_hash: swapParams.secretHash,
                }, 
                // msg value
                { [constants_1.assetCodeToDenom[swapParams.asset.code]]: swapParams.value.toNumber() }),
            ];
            return this.walletProvider.sendTransaction({ msgs: initMsg, fee, feeAsset: swapParams.asset });
        });
    }
    claimSwap(swapParams, initiationTxHash, secret, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.validateSecret)(secret);
            (0, utils_1.validateSecretAndHash)(secret, swapParams.secretHash);
            const txReceipt = yield this.walletProvider.getChainProvider().getTransactionByHash(initiationTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, txReceipt);
            const address = yield this.walletProvider.getAddress();
            const claimMsg = [new terra_js_1.MsgExecuteContract(address.toString(), txReceipt.to.toString(), { claim: { secret } })];
            return this.walletProvider.sendTransaction({ msgs: claimMsg, fee, feeAsset: swapParams.asset });
        });
    }
    refundSwap(swapParams, initTx, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReceipt = yield this.walletProvider.getChainProvider().getTransactionByHash(initTx);
            yield this.verifyInitiateSwapTransaction(swapParams, txReceipt);
            const address = yield this.walletProvider.getAddress();
            const refundMsg = [new terra_js_1.MsgExecuteContract(address.toString(), txReceipt.to.toString(), { refund: {} })];
            return this.walletProvider.sendTransaction({ msgs: refundMsg, fee, feeAsset: swapParams.asset });
        });
    }
    getSwapSecret(claimTxHash, _initTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const claimTxReceipt = yield this.walletProvider.getChainProvider().getTransactionByHash(claimTxHash);
            return claimTxReceipt.secret;
        });
    }
    doesTransactionMatchInitiation(swapParams, initTx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const network = yield this.walletProvider.getConnectedNetwork();
            const txParams = (_a = initTx === null || initTx === void 0 ? void 0 : initTx._raw) === null || _a === void 0 ? void 0 : _a.htlc;
            return ((0, utils_1.compare)(network.codeId, txParams === null || txParams === void 0 ? void 0 : txParams.code_id) &&
                (0, utils_1.compare)(swapParams.recipientAddress.toString(), txParams.buyer) &&
                (0, utils_1.compare)(swapParams.refundAddress.toString(), txParams.seller) &&
                (0, utils_1.compare)(swapParams.secretHash, txParams.secret_hash) &&
                utils_1.Math.eq(swapParams.expiration, txParams.expiration) &&
                utils_1.Math.eq(swapParams.value, initTx.value));
        });
    }
    canUpdateFee() {
        return false;
    }
    updateTransactionFee(_tx, _newFee) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnsupportedMethodError('Method not supported.');
        });
    }
}
exports.TerraSwapBaseProvider = TerraSwapBaseProvider;
//# sourceMappingURL=TerraSwapBaseProvider.js.map
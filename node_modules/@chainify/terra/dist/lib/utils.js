"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTxResponse = exports.parseBlockResponse = void 0;
const types_1 = require("@chainify/types");
const terra_js_1 = require("@terra-money/terra.js");
const lodash_1 = require("lodash");
const luxon_1 = require("luxon");
const constants_1 = require("./constants");
function parseBlockResponse(data) {
    return {
        hash: data.block_id.hash,
        timestamp: parseTimestamp(data.block.header.time),
        number: Number(data.block.header.height),
        parentHash: data.block.last_commit.block_id.hash,
        _raw: data,
    };
}
exports.parseBlockResponse = parseBlockResponse;
const parseTimestamp = (fullDate) => {
    return luxon_1.DateTime.fromISO(fullDate).toSeconds();
};
function parseTxResponse(data, currentBlock) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const result = {
        hash: data.txhash,
        value: 0,
        _raw: data,
        confirmations: currentBlock - data.height,
        status: (0, terra_js_1.isTxError)(data) ? types_1.TxStatus.Failed : types_1.TxStatus.Success,
    };
    // handle fees
    const fee = (_c = (_b = (_a = data.tx) === null || _a === void 0 ? void 0 : _a.auth_info) === null || _b === void 0 ? void 0 : _b.fee) === null || _c === void 0 ? void 0 : _c.amount.toAmino()[0];
    if (fee) {
        const { amount, denom } = fee;
        result.fee = Number(amount);
        result.feeAssetCode = constants_1.denomToAssetCode[denom];
    }
    const msg = (_e = (_d = data.tx.body) === null || _d === void 0 ? void 0 : _d.messages) === null || _e === void 0 ? void 0 : _e[0];
    // Initiate swap
    if (msg instanceof terra_js_1.MsgInstantiateContract) {
        const init = msg.init_msg;
        // TODO: is this the best way to get the contract address?
        result.to = (0, lodash_1.get)(data, 'logs[0].eventsByType.instantiate_contract.contract_address[0]', null);
        result.value = Number((_g = (_f = msg.init_coins) === null || _f === void 0 ? void 0 : _f.toAmino()) === null || _g === void 0 ? void 0 : _g[0].amount);
        result.valueAsset = constants_1.denomToAssetCode[(_j = (_h = msg.init_coins) === null || _h === void 0 ? void 0 : _h.toAmino()) === null || _j === void 0 ? void 0 : _j[0].denom];
        // htlc init msg
        if (init.buyer && init.expiration && init.secret_hash && init.seller && init.value) {
            result._raw.htlc = Object.assign(Object.assign({}, init), { code_id: msg.code_id });
            result._raw.method = 'init';
        }
        // any other deploy tx
        else {
            result._raw.initMsg = Object.assign(Object.assign({}, init), { code_id: msg.code_id });
        }
    }
    // Claim & Refund & Transfer ERC20
    else if (msg instanceof terra_js_1.MsgExecuteContract) {
        result.from = msg.sender;
        result.to = msg.contract;
        // Claim
        const action = msg.execute_msg;
        if (action.claim) {
            result.secret = action.claim.secret;
            result._raw.method = 'claim';
        }
        else if (action.refund) {
            result._raw.method = 'refund';
        }
        // ERC20
        else if (action.transfer) {
            result.to = action.transfer.recipient.toString();
            result.value = Number(action.transfer.amount);
            result.valueAsset = msg.contract;
        }
    }
    // Send LUNA & UST
    else if (msg instanceof terra_js_1.MsgSend) {
        const { amount, denom } = msg.amount.toAmino()[0];
        result.from = msg.from_address;
        result.to = msg.to_address;
        result.value = Number(amount);
        result.valueAsset = constants_1.denomToAssetCode[denom];
    }
    return result;
}
exports.parseTxResponse = parseTxResponse;
//# sourceMappingURL=utils.js.map
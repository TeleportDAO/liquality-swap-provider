"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearWalletProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const types_2 = require("../types");
const utils_1 = require("../utils");
class NearWalletProvider extends client_1.Wallet {
    constructor(walletOptions, chainProvider) {
        super(chainProvider);
        this._derivationPath = walletOptions.derivationPath;
        this._wallet = (0, types_2.parseSeedPhrase)(walletOptions.mnemonic, this._derivationPath);
        this._keyStore = new types_2.keyStores.InMemoryKeyStore();
        this._addressCache = {};
        this._helper = new client_1.HttpClient({ baseURL: walletOptions.helperUrl });
    }
    getSigner() {
        return new types_2.InMemorySigner(this._keyStore);
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._addressCache[this._derivationPath]) {
                return this._addressCache[this._derivationPath];
            }
            const { publicKey, secretKey } = this._wallet;
            const keyPair = types_2.KeyPair.fromString(secretKey);
            let address = yield this.getImplicitAccount(publicKey, 0);
            if (!address) {
                address = Buffer.from(keyPair.getPublicKey().data).toString('hex');
            }
            yield this._keyStore.setKey(this.chainProvider.getNetwork().networkId.toString(), address, keyPair);
            const result = new types_1.Address({ address, derivationPath: this._derivationPath, publicKey });
            this._wallet.address = result;
            this._addressCache[this._derivationPath] = result;
            return result;
        });
    }
    getUnusedAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getAddress();
        });
    }
    getUsedAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getAddresses();
        });
    }
    getAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            return [address];
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            const signed = yield this.getSigner().signMessage(Buffer.from(message), address.toString(), this.chainProvider.getNetwork().networkId.toString());
            return Buffer.from(signed.signature).toString('hex');
        });
    }
    sendTransaction(txRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            const from = this.getAccount(address.toString());
            const to = txRequest.to.toString();
            let tx = null;
            if (!txRequest.actions) {
                tx = (yield from.sendMoney(to, new types_2.BN(txRequest.value.toFixed(0))));
            }
            else {
                tx = (yield from.signAndSendTransaction({ receiverId: to, actions: txRequest.actions }));
            }
            return (0, utils_1.parseTxResponse)(tx);
        });
    }
    sendBatchTransaction(txRequests) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const txRequest of txRequests) {
                const tx = yield this.sendTransaction(txRequest);
                result.push(tx);
            }
            return result;
        });
    }
    sendSweepTransaction(to, _asset) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            const from = this.getAccount(address.toString());
            const tx = (yield from.deleteAccount(to.toString()));
            return (0, utils_1.parseTxResponse)(tx);
        });
    }
    getBalance(_assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.getAddress();
            return yield this.chainProvider.getBalance([user], _assets);
        });
    }
    exportPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._wallet.secretKey;
        });
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            return Boolean(this.getAddress());
        });
    }
    canUpdateFee() {
        return false;
    }
    updateTransactionFee(_tx) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnsupportedMethodError('Method not supported for Near');
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainProvider.getNetwork();
        });
    }
    getAccount(accountId) {
        return new types_2.NearAccount({
            networkId: this.chainProvider.getNetwork().networkId.toString(),
            provider: this.chainProvider.getProvider(),
            signer: this.getSigner(),
        }, accountId);
    }
    onChainProviderUpdate(_chainProvider) {
        // do nothing
    }
    getImplicitAccount(publicKey, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this._helper.nodeGet(`/publicKey/${publicKey.toString()}/accounts`);
            return accounts[index];
        });
    }
}
exports.NearWalletProvider = NearWalletProvider;
//# sourceMappingURL=NearWalletProvider.js.map
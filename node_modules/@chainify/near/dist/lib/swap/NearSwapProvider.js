"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearSwapProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const utils_1 = require("@chainify/utils");
const utils_2 = require("../utils");
const ONE_DAY_IN_NS = 24 * 60 * 60 * 1000 * 1000 * 1000;
const CONTRACT_CODE = 'jrBWhtpuyGJ44vtP+Ib+I32tuUUtfKQBuBdQ8y3M6Ro=';
class NearSwapProvider extends client_1.Swap {
    constructor(helperUrl, walletProvider) {
        super(walletProvider);
        this._httpClient = new client_1.HttpClient({ baseURL: helperUrl });
    }
    initiateSwap(swapParams) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            return this.walletProvider.sendTransaction({
                to: this.generateUniqueString(swapParams.secretHash.substring(0, 20)),
                value: null,
                actions: (0, utils_2.getHtlcActions)(swapParams),
            });
        });
    }
    findInitiateSwapTransaction(swapParams, _blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findAddressTransaction(swapParams.refundAddress.toString(), (tx) => this.doesTransactionMatchInitiation(swapParams, tx));
        });
    }
    claimSwap(swapParams, initTxHash, secret) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.validateSecret)(secret);
            (0, utils_1.validateSecretAndHash)(secret, swapParams.secretHash);
            const transaction = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, transaction);
            return this.walletProvider.sendTransaction({
                to: transaction.to,
                value: null,
                actions: (0, utils_2.getClaimActions)(secret),
            });
        });
    }
    findClaimSwapTransaction(swapParams, initTxHash) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            const initTx = (yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash));
            if (!initTx) {
                throw new errors_1.TxNotFoundError(`Transaction receipt is not available: ${initTxHash}`);
            }
            const tx = yield this.findAddressTransaction(initTx._raw.receiver.toString(), (tx) => { var _a, _b; return ((_b = (_a = tx === null || tx === void 0 ? void 0 : tx._raw) === null || _a === void 0 ? void 0 : _a.htlc) === null || _b === void 0 ? void 0 : _b.method) === 'claim'; });
            const secret = (_b = (_a = tx === null || tx === void 0 ? void 0 : tx._raw) === null || _a === void 0 ? void 0 : _a.htlc) === null || _b === void 0 ? void 0 : _b.secret;
            if (secret) {
                (0, utils_1.validateSecretAndHash)(secret, swapParams.secretHash);
                return Object.assign(Object.assign({}, tx), { secret });
            }
        });
    }
    refundSwap(swapParams, initTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash);
            yield this.verifyInitiateSwapTransaction(swapParams, transaction);
            return this.walletProvider.sendTransaction({
                to: transaction.to,
                value: null,
                actions: (0, utils_2.getRefundActions)(),
            });
        });
    }
    findRefundSwapTransaction(swapParams, initTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateSwapParams(swapParams);
            const initTx = (yield this.walletProvider.getChainProvider().getTransactionByHash(initTxHash));
            if (!initTx) {
                throw new errors_1.TxNotFoundError(`Transaction receipt is not available: ${initTxHash}`);
            }
            return yield this.findAddressTransaction(initTx._raw.receiver.toString(), (tx) => { var _a, _b; return ((_b = (_a = tx === null || tx === void 0 ? void 0 : tx._raw) === null || _a === void 0 ? void 0 : _a.htlc) === null || _b === void 0 ? void 0 : _b.method) === 'refund'; });
        });
    }
    getSwapSecret(claimTxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = (yield this.walletProvider.getChainProvider().getTransactionByHash(claimTxHash));
            if (!tx) {
                throw new errors_1.TxNotFoundError(`Transaction not found: ${claimTxHash}`);
            }
            return tx._raw.htlc.secret;
        });
    }
    onWalletProviderUpdate(_wallet) {
        // do nothing
    }
    doesTransactionMatchInitiation(swapParams, transaction) {
        var _a;
        if ((_a = transaction === null || transaction === void 0 ? void 0 : transaction._raw) === null || _a === void 0 ? void 0 : _a.htlc) {
            return ((0, utils_1.compare)(transaction._raw.code, CONTRACT_CODE) &&
                utils_1.Math.eq(transaction._raw.value, swapParams.value) &&
                (0, utils_1.compare)(transaction._raw.sender, swapParams.refundAddress.toString()) &&
                utils_1.Math.eq(transaction._raw.htlc.expiration, swapParams.expiration) &&
                (0, utils_1.compare)(transaction._raw.htlc.recipient, swapParams.recipientAddress.toString()) &&
                (0, utils_1.compare)((0, utils_1.remove0x)(transaction._raw.htlc.secretHash), (0, utils_1.remove0x)(swapParams.secretHash)));
        }
    }
    generateUniqueString(name) {
        return `htlc-${name}-${Date.now()}`;
    }
    findAddressTransaction(address, predicate, limit = 1024) {
        return __awaiter(this, void 0, void 0, function* () {
            let offset = new Date().valueOf() * 1000 * 1000;
            for (let page = 1;; page++) {
                const transactions = (yield this._httpClient.nodeGet(`account/${address}/activity?offset=${offset}&limit=${limit}`));
                if (transactions.length === 0) {
                    return;
                }
                const parsedTransactions = {};
                for (const tx of transactions) {
                    parsedTransactions[tx.hash] = Object.assign(Object.assign({}, parsedTransactions[tx.hash]), (0, utils_2.parseScraperTransaction)(tx));
                }
                const foundTx = Object.values(parsedTransactions).find((tx) => predicate({ _raw: tx }));
                if (foundTx) {
                    const receipt = yield this.walletProvider.getChainProvider().getTransactionByHash(foundTx.hash);
                    return Object.assign(Object.assign({}, receipt), foundTx);
                }
                offset = offset - ONE_DAY_IN_NS;
            }
        });
    }
    canUpdateFee() {
        return false;
    }
    updateTransactionFee(_tx, _newFee) {
        throw new errors_1.UnimplementedMethodError('Method not supported.');
    }
}
exports.NearSwapProvider = NearSwapProvider;
//# sourceMappingURL=NearSwapProvider.js.map
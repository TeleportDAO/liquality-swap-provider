"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseScraperTransaction = exports.getRefundActions = exports.getClaimActions = exports.getHtlcActions = exports.parseTxResponse = exports.parseNearBlockTx = exports.parseBlockResponse = void 0;
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const bytecode_1 = __importDefault(require("./swap/bytecode"));
const types_2 = require("./types");
function parseBlockResponse(block, transactions) {
    return {
        number: block.header.height,
        hash: block.header.hash,
        // convert nanoseconds to milliseconds
        timestamp: fromNearTimestamp(block.header.timestamp),
        parentHash: block.header.prev_hash,
        transactions,
        _raw: block,
    };
}
exports.parseBlockResponse = parseBlockResponse;
function parseNearBlockTx(tx, currentBlock, txBlock) {
    return Object.assign({ hash: `${tx.hash}_${tx.signer_id}`, value: 0, confirmations: currentBlock && txBlock && utils_1.Math.sub(currentBlock, txBlock).toNumber(), _raw: tx }, parseTxActions(tx));
}
exports.parseNearBlockTx = parseNearBlockTx;
function parseTxResponse(response, blockNumber, latestBlock) {
    var _a;
    const tx = response.transaction;
    const parsedActions = parseTxActions(tx);
    const result = {
        blockHash: response.transaction_outcome.block_hash,
        hash: `${tx.hash}_${tx.signer_id}`,
        to: tx.receiver_id,
        from: tx.signer_id,
        value: parsedActions.value || 0,
        secret: (_a = parsedActions.htlc) === null || _a === void 0 ? void 0 : _a.secret,
        _raw: parsedActions,
    };
    if (blockNumber && latestBlock) {
        result.confirmations = utils_1.Math.sub(latestBlock, blockNumber).toNumber();
    }
    result.status = types_1.TxStatus.Unknown;
    if (response.status) {
        if (response.status.Failure) {
            result.status = types_1.TxStatus.Failed;
        }
        if (!response.status.SuccessValue || typeof response.status.SuccessValue !== 'string') {
            result.status = types_1.TxStatus.Failed;
        }
        if (response.status.SuccessReceiptId || typeof response.status.SuccessValue === 'string') {
            result.status = types_1.TxStatus.Success;
        }
    }
    return result;
}
exports.parseTxResponse = parseTxResponse;
function getHtlcActions(swapParams) {
    return [
        types_2.transactions.createAccount(),
        types_2.transactions.transfer(new types_2.BN(swapParams.value.toFixed(0))),
        types_2.transactions.deployContract(new Uint8Array(bytecode_1.default)),
        types_2.transactions.functionCall(ABI.init.method, formatSwapParams(swapParams), new types_2.BN(ABI.init.gas), new types_2.BN(0)),
    ];
}
exports.getHtlcActions = getHtlcActions;
function getClaimActions(secret) {
    const data = Buffer.from(JSON.stringify({ secret: Buffer.from((0, utils_1.remove0x)(secret), 'hex').toString('base64') }));
    return [types_2.transactions.functionCall(ABI.claim.method, data, new types_2.BN(ABI.claim.gas), new types_2.BN(0))];
}
exports.getClaimActions = getClaimActions;
function getRefundActions() {
    const data = Buffer.from(JSON.stringify({}));
    return [types_2.transactions.functionCall(ABI.refund.method, data, new types_2.BN(ABI.refund.gas), new types_2.BN(0))];
}
exports.getRefundActions = getRefundActions;
function parseScraperTransaction(tx) {
    const normalizedTx = {
        hash: `${tx.hash}_${tx.signer_id}`,
        blockHash: tx.block_hash,
        sender: tx.signer_id,
        receiver: tx.receiver_id,
    };
    switch (tx.action_kind) {
        case 'DEPLOY_CONTRACT': {
            const code = toBase64(tx.args.code_sha256);
            normalizedTx.code = code;
            break;
        }
        case 'TRANSFER': {
            const value = tx.args.deposit;
            normalizedTx.value = Number(value);
            break;
        }
        case 'FUNCTION_CALL': {
            const method = tx.args.method_name;
            const args = fromBase64(tx.args.args_base64);
            switch (method) {
                case 'init': {
                    normalizedTx.htlc = {
                        method,
                        secretHash: fromBase64(args.secretHash, 'hex'),
                        expiration: fromNearTimestamp(args.expiration),
                        recipient: args.buyer,
                    };
                    break;
                }
                case 'claim': {
                    normalizedTx.htlc = {
                        method,
                        secret: fromBase64(args.secret, 'hex'),
                    };
                    break;
                }
                case 'refund': {
                    normalizedTx.htlc = { method };
                    break;
                }
                default: {
                    break;
                }
            }
            break;
        }
        default: {
            break;
        }
    }
    return normalizedTx;
}
exports.parseScraperTransaction = parseScraperTransaction;
const ABI = {
    init: { method: 'init', gas: '10000000000000' },
    claim: { method: 'claim', gas: '10000000000000' },
    refund: { method: 'refund', gas: '8000000000000' },
};
function toNearTimestampFormat(ts) {
    // in nanoseconds
    return ts * 1000 * 1000 * 1000;
}
function formatSwapParams(swapParams) {
    return Buffer.from(JSON.stringify({
        secretHash: Buffer.from(swapParams.secretHash, 'hex').toString('base64'),
        expiration: `${toNearTimestampFormat(swapParams.expiration)}`,
        buyer: swapParams.recipientAddress.toString(),
    }));
}
function parseTxActions(tx) {
    const result = {
        value: 0,
        sender: tx.signer_id,
        receiver: tx.receiver_id,
        hash: `${tx.hash}_${tx.signer_id}`,
    };
    for (const action of tx.actions) {
        if (action.Transfer) {
            result.value = utils_1.Math.add(action.Transfer.deposit.toString(), result.value).toNumber();
        }
        if (action.DeployContract) {
            result.code = action.DeployContract.code;
        }
        if (action.FunctionCall) {
            const method = action.FunctionCall.method_name;
            switch (method) {
                case 'init': {
                    const args = fromBase64(action.FunctionCall.args);
                    result.htlc = {
                        method,
                        secretHash: fromBase64(args.secretHash, 'hex'),
                        expiration: fromNearTimestamp(args.expiration),
                        recipient: args.buyer,
                    };
                    break;
                }
                case 'claim': {
                    const args = fromBase64(action.FunctionCall.args);
                    result.htlc = {
                        method,
                        secret: fromBase64(args.secret, 'hex'),
                    };
                    break;
                }
                case 'refund': {
                    result.htlc = { method };
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }
    return result;
}
function toBase64(str, encoding = 'hex') {
    try {
        return Buffer.from(str, encoding).toString('base64');
    }
    catch (e) {
        return str;
    }
}
function fromBase64(str, encoding) {
    if (!str) {
        return {};
    }
    try {
        const decoded = Buffer.from(str, 'base64').toString(encoding);
        try {
            return JSON.parse(decoded);
        }
        catch (e) {
            return decoded;
        }
    }
    catch (e) {
        return str;
    }
}
function fromNearTimestamp(ts) {
    return Number(utils_1.Math.div(ts, 1000000000).toFixed(0));
}
//# sourceMappingURL=utils.js.map
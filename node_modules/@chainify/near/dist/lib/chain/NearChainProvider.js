"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearChainProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const logger_1 = require("@chainify/logger");
const types_1 = require("@chainify/types");
const near_api_js_1 = require("near-api-js");
const types_2 = require("../types");
const utils_1 = require("../utils");
const logger = new logger_1.Logger('NearChainProvider');
class NearChainProvider extends client_1.Chain {
    constructor(network, provider) {
        super(network, provider);
        if (!provider && this.network.rpcUrl) {
            this.provider = new near_api_js_1.providers.JsonRpcProvider({ url: this.network.rpcUrl });
        }
    }
    getBlockByHash(blockHash, includeTx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._getBlockById(blockHash, includeTx);
        });
    }
    getBlockByNumber(blockNumber, includeTx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!blockNumber) {
                blockNumber = yield this.getBlockHeight();
            }
            return this._getBlockById(blockNumber, includeTx);
        });
    }
    getBlockHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.provider.block({ finality: 'final' });
            return result.header.height;
        });
    }
    getTransactionByHash(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const currentHeight = yield this.getBlockHeight();
                const [hash, accountId] = txHash.split('_');
                const tx = (yield this.provider.txStatus(hash, accountId));
                const blockHash = tx.transaction_outcome.block_hash;
                const block = yield this.getBlockByHash(blockHash);
                return (0, utils_1.parseTxResponse)(tx, block.number, Number(currentHeight));
            }
            catch (err) {
                if (err.message.includes(`doesn't exist`)) {
                    throw new errors_1.TxNotFoundError('Transaction not found');
                }
                else {
                    throw err;
                }
            }
        });
    }
    /**
     * @param _assets - it's ignored as Chanify does not support Near tokens yet
     */
    getBalance(addresses, _assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = addresses[0].toString();
            try {
                const balance = yield this.getAccount(user).getAccountBalance();
                return [new types_1.BigNumber(balance.available)];
            }
            catch (err) {
                if (err.message && err.message.includes('does not exist while viewing')) {
                    return [new types_1.BigNumber(0)];
                }
                else {
                    logger.debug('getBalance', err);
                    return [null];
                }
            }
        });
    }
    getFees() {
        return __awaiter(this, void 0, void 0, function* () {
            const gasPrice = yield this.sendRpcRequest('gas_price', [null]);
            const fee = { fee: parseInt(gasPrice.gas_price, 10) };
            return { slow: fee, average: fee, fast: fee };
        });
    }
    sendRawTransaction(rawTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendRpcRequest('broadcast_tx_commit', [rawTransaction]);
        });
    }
    sendRpcRequest(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.sendJsonRpc(method, params);
        });
    }
    _getBlockById(blockId, includeTx) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const block = yield this.provider.block({ blockId });
                const currentHeight = yield this.getBlockHeight();
                if (includeTx && block.chunks) {
                    const chunks = yield Promise.all(block.chunks.map((c) => this.provider.chunk(c.chunk_hash)));
                    const transactions = chunks.reduce((p, chunk) => {
                        chunk.transactions.map((t) => {
                            p.push((0, utils_1.parseNearBlockTx)(t, Number(currentHeight), block.header.height));
                        });
                        return p;
                    }, []);
                    return (0, utils_1.parseBlockResponse)(block, transactions);
                }
                return (0, utils_1.parseBlockResponse)(block);
            }
            catch (err) {
                if (err.message.includes('DB Not Found Error')) {
                    throw new errors_1.BlockNotFoundError('Block not found');
                }
                else {
                    throw err;
                }
            }
        });
    }
    getAccount(accountId) {
        return new types_2.NearAccount({
            networkId: this.network.networkId.toString(),
            provider: this.provider,
            signer: null,
        }, accountId);
    }
}
exports.NearChainProvider = NearChainProvider;
//# sourceMappingURL=NearChainProvider.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaChainProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const logger_1 = require("@chainify/logger");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const spl_token_1 = require("@solana/spl-token");
const spl_token_registry_1 = require("@solana/spl-token-registry");
const web3_js_1 = require("@solana/web3.js");
const utils_2 = require("../utils");
const LAMPORTS_PER_SIGNATURE = 5000 / web3_js_1.LAMPORTS_PER_SOL;
const logger = new logger_1.Logger('SolanaChainProvider');
class SolanaChainProvider extends client_1.Chain {
    constructor(network) {
        super(network);
        if (!this.provider && this.network.rpcUrl) {
            this.provider = new web3_js_1.Connection(network.rpcUrl, {
                confirmTransactionInitialTimeout: 120000,
                commitment: 'confirmed',
            });
        }
    }
    getTokenDetails(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.tokenList) {
                this.tokenList = (yield new spl_token_registry_1.TokenListProvider().resolve()).filterByChainId(spl_token_registry_1.ENV.MainnetBeta).getList();
            }
            const { name, symbol, decimals } = this.tokenList.find((t) => t.address === tokenAddress);
            return { name, symbol, decimals };
        });
    }
    getBlockByNumber(blockNumber, includeTx) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.retry)(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const block = yield this.provider.getBlock(blockNumber);
                    if (!includeTx) {
                        return (0, utils_2.parseBlockResponse)(block);
                    }
                    const txSignatures = block.transactions.map((tx) => tx.transaction.signatures[0]);
                    const txDetails = yield this.provider.getParsedTransactions(txSignatures);
                    const transactions = txDetails.map((tx) => (0, utils_2.parseTransactionResponse)(tx));
                    return Object.assign(Object.assign({}, (0, utils_2.parseBlockResponse)(block)), { transactions });
                }
                catch (err) {
                    logger.error(err);
                    throw new errors_1.BlockNotFoundError(`Block ${blockNumber} not found`);
                }
            }));
        });
    }
    getBlockHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.provider.getSlot();
        });
    }
    getTransactionByHash(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.retry)(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const [transaction, signatures] = yield Promise.all([
                        this.provider.getParsedTransaction(txHash, 'confirmed'),
                        this.provider.getSignatureStatus(txHash, { searchTransactionHistory: true }),
                    ]);
                    return (0, utils_2.parseTransactionResponse)(transaction, signatures);
                }
                catch (err) {
                    logger.error(err);
                    throw new errors_1.TxNotFoundError(`Transaction not found: ${txHash}`);
                }
            }), 500, 2, 7);
        });
    }
    getBalance(addresses, assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = new web3_js_1.PublicKey(addresses[0].toString());
            const [nativeBalance, tokenData] = yield Promise.all([
                this.provider.getBalance(address),
                this.provider.getTokenAccountsByOwner(address, { programId: spl_token_1.TOKEN_PROGRAM_ID }),
            ]);
            const tokenBalances = tokenData.value.map((token) => {
                const { mint, amount } = spl_token_1.AccountLayout.decode(token.account.data);
                return { contractAddress: mint.toString(), amount: new types_1.BigNumber(amount.toString()) };
            });
            const balances = assets.map((asset) => {
                if (asset.type === types_1.AssetTypes.native) {
                    return new types_1.BigNumber(nativeBalance);
                }
                else {
                    const token = tokenBalances.find((token) => (0, utils_1.compare)(token.contractAddress, asset.contractAddress));
                    if (token) {
                        return token.amount;
                    }
                    else {
                        return null;
                    }
                }
            });
            return balances;
        });
    }
    /**
     * Fee price is fixed in Solana and it's equal to 5000 / LAMPORTS_PER_SOL
     */
    getFees() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                slow: {
                    fee: LAMPORTS_PER_SIGNATURE,
                },
                average: {
                    fee: LAMPORTS_PER_SIGNATURE,
                },
                fast: {
                    fee: LAMPORTS_PER_SIGNATURE,
                },
            };
        });
    }
    sendRawTransaction(rawTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const wireTransaciton = Buffer.from(rawTransaction);
            return yield this.provider.sendRawTransaction(wireTransaciton);
        });
    }
    sendRpcRequest(_method, _params) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnsupportedMethodError('Method not supported for Solana');
        });
    }
    getBlockByHash(_blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnsupportedMethodError('Method not supported for Solana');
        });
    }
}
exports.SolanaChainProvider = SolanaChainProvider;
//# sourceMappingURL=SolanaChainProvider.js.map
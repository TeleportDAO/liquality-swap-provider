"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaWalletProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const logger_1 = require("@chainify/logger");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const bip39_1 = require("bip39");
const ed25519_hd_key_1 = require("ed25519-hd-key");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const logger = new logger_1.Logger('SolanaWalletProvider');
class SolanaWalletProvider extends client_1.Wallet {
    constructor(walletOptions, chainProvider) {
        const { mnemonic, derivationPath } = walletOptions;
        super(chainProvider);
        this._mnemonic = mnemonic;
        this._derivationPath = derivationPath;
        this._addressCache = {};
        this._signer = this.setSigner();
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainProvider.getNetwork();
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._signer;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._addressCache[this._mnemonic]) {
                return this._addressCache[this._mnemonic];
            }
            const result = new types_1.Address({
                address: this._signer.publicKey.toString(),
                publicKey: this._signer.publicKey.toString(),
                derivationPath: this._derivationPath,
            });
            this._addressCache[this._mnemonic] = result;
            return result;
        });
    }
    getUnusedAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses[0];
        });
    }
    getUsedAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getAddresses();
        });
    }
    getAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            return [address];
        });
    }
    signMessage(message, _from) {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = Buffer.from(message);
            const signature = tweetnacl_1.default.sign.detached(buffer, utils_1.base58.decode(utils_1.base58.encode(this._signer.secretKey)));
            return Buffer.from(signature).toString('hex');
        });
    }
    sendTransaction(txRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            let transaction;
            const latestBlockhash = yield (0, utils_1.retry)(() => __awaiter(this, void 0, void 0, function* () { return this.chainProvider.getProvider().getLatestBlockhash('confirmed'); }));
            // Handle already builded transactions that are passed from outside - Jupiter for example
            if (txRequest.transaction) {
                transaction = txRequest.transaction;
                transaction.recentBlockhash = latestBlockhash.blockhash;
            }
            else {
                let instruction;
                const to = new web3_js_1.PublicKey(txRequest.to.toString());
                // Handle ERC20 Transactions
                if (txRequest.asset && !(txRequest.asset.type === types_1.AssetTypes.native)) {
                    const contractAddress = new web3_js_1.PublicKey(txRequest.asset.contractAddress);
                    const [fromTokenAccount, toTokenAccount] = yield Promise.all([
                        (0, spl_token_1.getAssociatedTokenAddress)(contractAddress, this._signer.publicKey),
                        (0, spl_token_1.getAssociatedTokenAddress)(contractAddress, to),
                    ]);
                    try {
                        yield (0, spl_token_1.getAccount)(this.chainProvider.getProvider(), toTokenAccount);
                    }
                    catch (err) {
                        if (err instanceof spl_token_1.TokenAccountNotFoundError) {
                            yield (0, spl_token_1.createAccount)(this.chainProvider.getProvider(), this._signer, contractAddress, to);
                        }
                        else {
                            logger.debug(`Error creating account`, err);
                        }
                    }
                    instruction = (0, spl_token_1.createTransferInstruction)(fromTokenAccount, toTokenAccount, this._signer.publicKey, Number(txRequest.value));
                }
                else {
                    // Handle SOL Transactions
                    instruction = web3_js_1.SystemProgram.transfer({
                        fromPubkey: this._signer.publicKey,
                        toPubkey: to,
                        lamports: txRequest.value.toNumber(),
                    });
                }
                transaction = new web3_js_1.Transaction({ recentBlockhash: latestBlockhash.blockhash }).add(instruction);
            }
            const hash = yield this.chainProvider.getProvider().sendTransaction(transaction, [this._signer], {
                preflightCommitment: 'confirmed',
            });
            return {
                hash,
                value: txRequest.value.toNumber(),
                to: txRequest.to,
                from: this._signer.publicKey.toBase58(),
                _raw: {},
                confirmations: 0,
                status: types_1.TxStatus.Pending,
            };
        });
    }
    sendBatchTransaction(txRequests) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const txRequest of txRequests) {
                const tx = yield this.sendTransaction(txRequest);
                result.push(tx);
            }
            return result;
        });
    }
    sendSweepTransaction(address, asset) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            const balance = yield this.chainProvider.getBalance(addresses, [asset]);
            return yield this.sendTransaction({ to: address, value: balance[0] });
        });
    }
    updateTransactionFee(_tx, _newFee) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnimplementedMethodError('Method not supported.');
        });
    }
    getBalance(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.getAddress();
            return yield this.chainProvider.getBalance([user], assets);
        });
    }
    exportPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.base58.encode(this._signer.secretKey);
        });
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses.length > 0;
        });
    }
    canUpdateFee() {
        return false;
    }
    onChainProviderUpdate(_chainProvider) {
        // do nothing
    }
    mnemonicToSeed(mnemonic) {
        if (!mnemonic) {
            throw new Error('Invalid seed words');
        }
        const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
        return Buffer.from(seed).toString('hex');
    }
    setSigner() {
        const seed = this.mnemonicToSeed(this._mnemonic);
        const derivedSeed = (0, ed25519_hd_key_1.derivePath)(this._derivationPath, seed).key;
        return web3_js_1.Keypair.fromSecretKey(tweetnacl_1.default.sign.keyPair.fromSeed(derivedSeed).secretKey);
    }
}
exports.SolanaWalletProvider = SolanaWalletProvider;
//# sourceMappingURL=SolanaWalletProvider.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaNftProvider = void 0;
const client_1 = require("@chainify/client");
const errors_1 = require("@chainify/errors");
const types_1 = require("@chainify/types");
const node_1 = __importDefault(require("moralis/node"));
class SolanaNftProvider extends client_1.Nft {
    constructor(walletProvider, config) {
        super(walletProvider);
        this._config = config;
        this._httpClient = new client_1.HttpClient({});
    }
    fetch() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!node_1.default.applicationId) {
                yield node_1.default.start({ masterKey: this._config.apiKey, serverUrl: this._config.url, appId: this._config.appId });
            }
            const [userAddress, network] = yield Promise.all([this.walletProvider.getAddress(), this.walletProvider.getConnectedNetwork()]);
            const nftsOptions = {
                address: userAddress.toString(),
                network: network.isTestnet ? 'devnet' : 'mainnet',
            };
            const nftBalance = yield node_1.default.SolanaAPI.account.getNFTs(nftsOptions);
            const nftAssets = [];
            for (const nft of nftBalance) {
                const metadataOptions = Object.assign(Object.assign({}, nftsOptions), { address: nft.mint });
                const nftMetadata = yield node_1.default.SolanaAPI.nft.getNFTMetadata(metadataOptions);
                const { mint, symbol } = nftMetadata;
                try {
                    const data = yield this._httpClient.nodeGet(nftMetadata.metaplex.metadataUri);
                    const nftAsset = {
                        token_id: data.edition,
                        asset_contract: {
                            address: mint,
                            name: data.name,
                            symbol: symbol,
                            image_url: data.image,
                            external_link: data.external_url,
                        },
                        collection: {
                            name: ((_a = data.collection) === null || _a === void 0 ? void 0 : _a.name) || data.name,
                        },
                        description: data.description,
                        external_link: data.external_url,
                        image_original_url: data.image,
                        image_preview_url: data.image,
                        image_thumbnail_url: data.image,
                        name: data.name,
                    };
                    nftAssets.push(nftAsset);
                }
                catch (err) {
                    nftAssets.push({ asset_contract: { address: mint, symbol }, collection: { name: symbol } });
                }
            }
            return nftAssets;
        });
    }
    transfer(contract, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.walletProvider.sendTransaction({
                to: receiver,
                value: new types_1.BigNumber(1),
                asset: {
                    contractAddress: contract.toString(),
                    chain: types_1.ChainId.Solana,
                    decimals: 0,
                    code: '',
                    name: '',
                    type: types_1.AssetTypes.nft,
                },
            });
        });
    }
    balanceOf(_contractAddress, _owners, _tokenIDs) {
        throw new errors_1.UnsupportedMethodError('Method not supported');
    }
    approve(_contract, _operator, _tokenID) {
        throw new errors_1.UnsupportedMethodError('Method not supported');
    }
    approveAll(_contract, _operator, _state) {
        throw new errors_1.UnsupportedMethodError('Method not supported');
    }
    isApprovedForAll(_contract, _operator) {
        throw new errors_1.UnsupportedMethodError('Method not supported');
    }
}
exports.SolanaNftProvider = SolanaNftProvider;
//# sourceMappingURL=SolanaNftProvider.js.map
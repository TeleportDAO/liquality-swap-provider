"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinLedgerProvider = void 0;
const bitcoin_1 = require("@chainify/bitcoin");
const errors_1 = require("@chainify/errors");
const hw_ledger_1 = require("@chainify/hw-ledger");
const types_1 = require("@chainify/types");
const utils_1 = require("@chainify/utils");
const hw_app_btc_1 = __importDefault(require("@ledgerhq/hw-app-btc"));
const bip32_1 = require("bip32");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
class BitcoinLedgerProvider extends bitcoin_1.BitcoinBaseWalletProvider {
    constructor(options, chainProvider) {
        super(options, chainProvider);
        this._ledgerProvider = new hw_ledger_1.LedgerProvider(hw_app_btc_1.default, Object.assign(Object.assign({}, options), { scrambleKey: options.scrambleKey || 'BTC' }));
        this._walletPublicKeyCache = {};
        if (options.basePublicKey && options.baseChainCode) {
            this._walletPublicKeyCache = {
                [options.baseDerivationPath]: {
                    publicKey: options.basePublicKey,
                    chainCode: options.baseChainCode,
                },
            };
        }
    }
    signMessage(message, from) {
        return __awaiter(this, void 0, void 0, function* () {
            const app = yield this._ledgerProvider.getApp();
            const address = yield this.getWalletAddress(from);
            const hex = Buffer.from(message).toString('hex');
            const sig = yield app.signMessage(address.derivationPath, hex);
            return sig.r + sig.s;
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainProvider.getNetwork();
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses[0];
        });
    }
    getBalance(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return this.chainProvider.getBalance(addresses, assets);
        });
    }
    exportPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnimplementedMethodError('Method not supported.');
        });
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            return Boolean(this.getAddress());
        });
    }
    canUpdateFee() {
        return true;
    }
    signPSBT(data, inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const psbt = bitcoinjs_lib_1.Psbt.fromBase64(data, { network: this._network });
            const app = yield this._ledgerProvider.getApp();
            const inputsArePubkey = psbt.txInputs.every((input, index) => ['witnesspubkeyhash', 'pubkeyhash', 'p2sh-witnesspubkeyhash'].includes(psbt.getInputType(index)));
            if (inputsArePubkey && psbt.txInputs.length !== inputs.length) {
                throw new Error('signPSBT: Ledger must sign all inputs when they are all regular pub key hash payments.');
            }
            if (inputsArePubkey) {
                const ledgerInputs = yield this.getLedgerInputs(psbt.txInputs.map((input) => ({ txid: input.hash.reverse().toString('hex'), vout: input.index })));
                const getInputDetails = (input) => __awaiter(this, void 0, void 0, function* () {
                    const txHex = yield this.chainProvider.getProvider().getRawTransactionByHash(input.hash.reverse().toString('hex'));
                    const tx = bitcoin_1.BitcoinUtils.decodeRawTransaction(txHex, this._network);
                    const address = tx.vout[input.index].scriptPubKey.addresses[0];
                    const walletAddress = yield this.getWalletAddress(address);
                    return walletAddress;
                });
                const inputDetails = yield Promise.all(psbt.txInputs.map(getInputDetails));
                const paths = inputDetails.map((i) => i.derivationPath);
                const outputScriptHex = app
                    .serializeTransactionOutputs({
                    outputs: psbt.txOutputs.map((output) => ({
                        script: output.script,
                        amount: this.getAmountBuffer(output.value),
                    })),
                    version: null,
                    inputs: null,
                })
                    .toString('hex');
                const isSegwit = [bitcoin_1.BitcoinTypes.AddressType.BECH32, bitcoin_1.BitcoinTypes.AddressType.P2SH_SEGWIT].includes(this._addressType);
                const changeAddress = yield this.findAddress(psbt.txOutputs.map((output) => output.address), true);
                const txHex = yield app.createPaymentTransaction({
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    inputs: ledgerInputs,
                    associatedKeysets: paths,
                    changePath: changeAddress && changeAddress.derivationPath,
                    outputScriptHex,
                    segwit: isSegwit,
                    useTrustedInputForSegwit: isSegwit,
                    additionals: this._addressType === 'bech32' ? ['bech32'] : [],
                });
                const signedTransaction = bitcoinjs_lib_1.Transaction.fromHex(txHex);
                psbt.setVersion(1); // Ledger payment txs use v1 and there is no option to change it - fuck knows why
                for (const input of inputs) {
                    const signer = {
                        network: this._network,
                        publicKey: Buffer.from(inputDetails[input.index].publicKey, 'hex'),
                        sign: () => __awaiter(this, void 0, void 0, function* () {
                            const sigInput = signedTransaction.ins[input.index];
                            if (sigInput.witness.length) {
                                return bitcoinjs_lib_1.script.signature.decode(sigInput.witness[0]).signature;
                            }
                            else
                                return sigInput.script;
                        }),
                    };
                    yield psbt.signInputAsync(input.index, signer);
                }
                return psbt.toBase64();
            }
            const ledgerInputs = [];
            const walletAddresses = [];
            let isSegwit = false;
            for (const input of inputs) {
                const walletAddress = yield this.getDerivationPathAddress(input.derivationPath);
                walletAddresses.push(walletAddress);
                const { witnessScript, redeemScript } = psbt.data.inputs[input.index];
                const { hash: inputHash, index: inputIndex } = psbt.txInputs[input.index];
                const outputScript = witnessScript || redeemScript;
                const inputTxHex = yield this.chainProvider.getProvider().getRawTransactionByHash(inputHash.reverse().toString('hex'));
                const ledgerInputTx = app.splitTransaction(inputTxHex, true);
                ledgerInputs.push([ledgerInputTx, inputIndex, outputScript.toString('hex'), 0]);
                if (witnessScript)
                    isSegwit = true;
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - accessing private method required
            const ledgerTx = app.splitTransaction(psbt.__CACHE.__TX.toHex(), true);
            const ledgerOutputs = app.serializeTransactionOutputs(ledgerTx);
            const ledgerSigs = yield app.signP2SHTransaction({
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                inputs: ledgerInputs,
                associatedKeysets: walletAddresses.map((address) => address.derivationPath),
                outputScriptHex: ledgerOutputs.toString('hex'),
                lockTime: psbt.locktime,
                segwit: isSegwit,
                transactionVersion: 2,
            });
            for (const input of inputs) {
                const signer = {
                    network: this._network,
                    publicKey: Buffer.from(walletAddresses[input.index].publicKey, 'hex'),
                    sign: () => __awaiter(this, void 0, void 0, function* () {
                        const finalSig = isSegwit ? ledgerSigs[input.index] : ledgerSigs[input.index] + '01'; // Is this a ledger bug? Why non segwit signs need the sighash appended?
                        const { signature } = bitcoinjs_lib_1.script.signature.decode(Buffer.from(finalSig, 'hex'));
                        return signature;
                    }),
                };
                yield psbt.signInputAsync(input.index, signer);
            }
            return psbt.toBase64();
        });
    }
    signBatchP2SHTransaction(inputs, addresses, tx, lockTime, segwit) {
        return __awaiter(this, void 0, void 0, function* () {
            const app = yield this._ledgerProvider.getApp();
            const walletAddressDerivationPaths = [];
            for (const address of addresses) {
                const walletAddress = yield this.getWalletAddress(address);
                walletAddressDerivationPaths.push(walletAddress.derivationPath);
            }
            if (!segwit) {
                for (const input of inputs) {
                    tx.setInputScript(input.vout.n, input.outputScript);
                }
            }
            const ledgerTx = yield app.splitTransaction(tx.toHex(), true);
            const ledgerOutputs = (yield app.serializeTransactionOutputs(ledgerTx)).toString('hex');
            const ledgerInputs = [];
            for (const input of inputs) {
                const ledgerInputTx = yield app.splitTransaction(input.inputTxHex, true);
                ledgerInputs.push([ledgerInputTx, input.index, input.outputScript.toString('hex'), 0]);
            }
            const ledgerSigs = yield app.signP2SHTransaction({
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                inputs: ledgerInputs,
                associatedKeysets: walletAddressDerivationPaths,
                outputScriptHex: ledgerOutputs,
                lockTime,
                segwit,
                transactionVersion: 2,
            });
            const finalLedgerSigs = [];
            for (const ledgerSig of ledgerSigs) {
                const finalSig = segwit ? ledgerSig : ledgerSig + '01';
                finalLedgerSigs.push(Buffer.from(finalSig, 'hex'));
            }
            return finalLedgerSigs;
        });
    }
    getWalletPublicKey(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (path in this._walletPublicKeyCache) {
                return this._walletPublicKeyCache[path];
            }
            const walletPublicKey = yield this._getWalletPublicKey(path);
            this._walletPublicKeyCache[path] = walletPublicKey;
            return walletPublicKey;
        });
    }
    buildSweepTransaction(_externalChangeAddress, _feePerByte) {
        throw new errors_1.UnimplementedMethodError('Method not supported.');
    }
    baseDerivationNode() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._baseDerivationNode) {
                return this._baseDerivationNode;
            }
            const walletPubKey = yield this.getWalletPublicKey(this._baseDerivationPath);
            const compressedPubKey = bitcoin_1.BitcoinUtils.compressPubKey(walletPubKey.publicKey);
            this._baseDerivationNode = (0, bip32_1.fromPublicKey)(Buffer.from(compressedPubKey, 'hex'), Buffer.from(walletPubKey.chainCode, 'hex'), this._network);
            return this._baseDerivationNode;
        });
    }
    buildTransaction(targets, feePerByte, fixedInputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const app = yield this._ledgerProvider.getApp();
            const unusedAddress = yield this.getUnusedAddress(true);
            const { inputs, change, fee } = yield this.getInputsForAmount(targets, feePerByte, fixedInputs);
            const ledgerInputs = yield this.getLedgerInputs(inputs);
            const paths = inputs.map((utxo) => utxo.derivationPath);
            const outputs = targets.map((output) => {
                const outputScript = output.script || bitcoinjs_lib_1.address.toOutputScript(output.address, this._network);
                return { amount: this.getAmountBuffer(output.value), script: outputScript };
            });
            if (change) {
                outputs.push({
                    amount: this.getAmountBuffer(change.value),
                    script: bitcoinjs_lib_1.address.toOutputScript(unusedAddress.address, this._network),
                });
            }
            const transactionOutput = yield app.serializeTransactionOutputs({
                outputs,
                version: null,
                inputs: null,
            });
            const outputScriptHex = transactionOutput.toString('hex');
            const isSegwit = [bitcoin_1.BitcoinTypes.AddressType.BECH32, bitcoin_1.BitcoinTypes.AddressType.P2SH_SEGWIT].includes(this._addressType);
            const txHex = yield app.createPaymentTransaction({
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                inputs: ledgerInputs,
                associatedKeysets: paths,
                changePath: unusedAddress.derivationPath,
                outputScriptHex,
                segwit: isSegwit,
                useTrustedInputForSegwit: isSegwit,
                additionals: this._addressType === bitcoin_1.BitcoinTypes.AddressType.BECH32 ? ['bech32'] : [],
            });
            return { hex: txHex, fee };
        });
    }
    getAmountBuffer(amount) {
        let hexAmount = new types_1.BigNumber(Math.round(amount)).toString(16);
        hexAmount = (0, utils_1.padHexStart)(hexAmount, 8);
        const valueBuffer = Buffer.from(hexAmount, 'hex');
        return valueBuffer.reverse();
    }
    getLedgerInputs(unspentOutputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const app = yield this._ledgerProvider.getApp();
            return Promise.all(unspentOutputs.map((utxo) => __awaiter(this, void 0, void 0, function* () {
                const hex = yield this.chainProvider.getProvider().getTransactionHex(utxo.txid);
                const tx = app.splitTransaction(hex, true);
                return [tx, utxo.vout, undefined, 0];
            })));
        });
    }
    _getWalletPublicKey(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const app = yield this._ledgerProvider.getApp();
            const format = this._addressType === bitcoin_1.BitcoinTypes.AddressType.P2SH_SEGWIT ? 'p2sh' : this._addressType;
            return app.getWalletPublicKey(path, { format });
        });
    }
}
exports.BitcoinLedgerProvider = BitcoinLedgerProvider;
//# sourceMappingURL=BitcoinLedgerProvider.js.map
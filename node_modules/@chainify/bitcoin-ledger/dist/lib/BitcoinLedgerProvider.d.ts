/// <reference types="node" />
import { BitcoinBaseChainProvider, BitcoinBaseWalletProvider, BitcoinTypes } from '@chainify/bitcoin';
import { Chain } from '@chainify/client';
import { AddressType, Asset, BigNumber } from '@chainify/types';
import { BIP32Interface } from 'bip32';
import { BitcoinLedgerProviderOptions } from './types';
export declare class BitcoinLedgerProvider extends BitcoinBaseWalletProvider {
    private _ledgerProvider;
    private _walletPublicKeyCache;
    private _baseDerivationNode;
    constructor(options: BitcoinLedgerProviderOptions, chainProvider: Chain<BitcoinBaseChainProvider>);
    signMessage(message: string, from: string): Promise<string>;
    getConnectedNetwork(): Promise<import("@chainify/types").Network>;
    getSigner(): Promise<null>;
    getAddress(): Promise<AddressType>;
    getBalance(assets: Asset[]): Promise<BigNumber[]>;
    exportPrivateKey(): Promise<string>;
    isWalletAvailable(): Promise<boolean>;
    canUpdateFee(): boolean;
    signPSBT(data: string, inputs: BitcoinTypes.PsbtInputTarget[]): Promise<string>;
    signBatchP2SHTransaction(inputs: [{
        inputTxHex: string;
        index: number;
        vout: any;
        outputScript: Buffer;
    }], addresses: string, tx: any, lockTime?: number, segwit?: boolean): Promise<Buffer[]>;
    getWalletPublicKey(path: string): Promise<any>;
    protected buildSweepTransaction(_externalChangeAddress: string, _feePerByte?: number): Promise<{
        hex: string;
        fee: number;
    }>;
    protected baseDerivationNode(): Promise<BIP32Interface>;
    protected buildTransaction(targets: BitcoinTypes.OutputTarget[], feePerByte?: number, fixedInputs?: BitcoinTypes.Input[]): Promise<{
        hex: string;
        fee: number;
    }>;
    private getAmountBuffer;
    private getLedgerInputs;
    private _getWalletPublicKey;
}

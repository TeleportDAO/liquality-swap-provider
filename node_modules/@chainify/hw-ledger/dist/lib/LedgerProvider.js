"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerProvider = void 0;
const errors_1 = require("@chainify/errors");
const logger_1 = require("@chainify/logger");
const utils_1 = require("@chainify/utils");
const logger = new logger_1.Logger('LedgerProvider');
class LedgerProvider {
    constructor(appType, options) {
        this._appType = appType;
        this._transportCreator = options.transportCreator;
        this._network = options.network;
        // The ledger scramble key is required to be set on the ledger transport
        // if communicating with the device using `transport.send` for the first time
        this._scrambleKey = options.scrambleKey;
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getApp();
            // keep current exchange timeout
            const prevExchangeTimeout = this._transport.exchangeTimeout;
            // set exchange timeout to 2 seconds
            this._transport.setExchangeTimeout(2000);
            try {
                // https://ledgerhq.github.io/btchip-doc/bitcoin-technical-beta.html#_get_random
                yield this._transport.send(0xe0, 0xc0, 0x00, 0x00);
            }
            catch (e) {
                logger.debug('isWalletAvailable.error', e);
                logger.debug('isWalletAvailable.error.message', e.message);
                return false;
            }
            finally {
                // set exchange timeout to previous value
                this._transport.setExchangeTimeout(prevExchangeTimeout);
            }
            return true;
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            // Ledger apps do not provide connected network. It is separated in firmware.
            return this._network;
        });
    }
    getWalletAddress(address, getAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            let index = 0;
            let change = false;
            // A maximum number of addresses to lookup after which it is deemed
            // that the wallet does not contain this address
            const maxAddresses = 5000;
            const addressesPerCall = 50;
            while (index < maxAddresses) {
                const addrs = yield getAddresses(index, addressesPerCall, change);
                const addr = addrs.find((addr) => (0, utils_1.compare)(addr.toString(), address));
                if (addr) {
                    return addr;
                }
                index += addressesPerCall;
                if (index === maxAddresses && change === false) {
                    index = 0;
                    change = true;
                }
            }
            throw new Error('Ledger: Wallet does not contain address');
        });
    }
    getApp() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.createTransport();
            }
            catch (e) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { name } = e, errorNoName = __rest(e, ["name"]);
                throw new errors_1.WalletError(e.toString(), errorNoName);
            }
            if (!this._appInstance) {
                this._appInstance = new Proxy(new this._appType(this._transport, this._scrambleKey), { get: this.errorProxy.bind(this) });
            }
            return this._appInstance;
        });
    }
    errorProxy(target, func) {
        const method = target[func];
        if (Object.getOwnPropertyNames(target).includes(func) && typeof method === 'function') {
            return (...args) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield method.bind(target)(...args);
                    return result;
                }
                catch (e) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { name } = e, errorNoName = __rest(e, ["name"]);
                    this._transport = null;
                    this._appInstance = null;
                    throw new errors_1.WalletError(e.toString(), errorNoName);
                }
            });
        }
        else {
            return method;
        }
    }
    createTransport() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._transport) {
                this._transport = yield this._transportCreator.create(() => {
                    this._appInstance = null;
                    this._transport = null;
                });
            }
        });
    }
}
exports.LedgerProvider = LedgerProvider;
//# sourceMappingURL=LedgerProvider.js.map
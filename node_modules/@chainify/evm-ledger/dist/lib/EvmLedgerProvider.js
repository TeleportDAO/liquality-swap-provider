"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmLedgerProvider = void 0;
const errors_1 = require("@chainify/errors");
const evm_1 = require("@chainify/evm");
const hw_ledger_1 = require("@chainify/hw-ledger");
const types_1 = require("@chainify/types");
const address_1 = require("@ethersproject/address");
const hw_app_eth_1 = __importDefault(require("@ledgerhq/hw-app-eth"));
const EvmLedgerSigner_1 = require("./EvmLedgerSigner");
const defaultPath = "m/44'/60'/0'/0/0";
class EvmLedgerProvider extends evm_1.EvmBaseWalletProvider {
    constructor(options, chainProvider) {
        super(chainProvider);
        this._ledgerProvider = new hw_ledger_1.LedgerProvider(hw_app_eth_1.default, Object.assign(Object.assign({}, options), { scrambleKey: options.scrambleKey || 'w0w' }));
        this._derivationPath = options.derivationPath || defaultPath;
        this._addressCache = {};
        if (options.addressCache) {
            const { publicKey, address } = options.addressCache;
            this._addressCache = {
                [options.derivationPath]: {
                    publicKey,
                    address,
                },
            };
        }
        this._ledgerSigner = new EvmLedgerSigner_1.EvmLedgerSigner(this._ledgerProvider.getApp.bind(this._ledgerProvider), this._derivationPath, null, options.addressCache);
        if (chainProvider) {
            this._ledgerSigner = this._ledgerSigner.connect(chainProvider.getProvider());
        }
        this.signer = this._ledgerSigner;
    }
    onChainProviderUpdate(chainProvider) {
        this._ledgerSigner = this._ledgerSigner.connect(chainProvider.getProvider());
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = yield this.getAddresses();
            return addresses[0];
        });
    }
    getUnusedAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getAddress();
        });
    }
    getUsedAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getAddresses();
        });
    }
    getAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._addressCache[this._derivationPath]) {
                const { address, publicKey } = this._addressCache[this._derivationPath];
                return [new types_1.Address({ address, derivationPath: this._derivationPath, publicKey })];
            }
            const ledgerAddress = yield this.getLedgerAddress();
            const { address, publicKey } = ledgerAddress;
            const _address = (0, address_1.getAddress)(address.toLowerCase());
            this._addressCache[this._derivationPath] = { publicKey, address: _address };
            return [new types_1.Address({ address: _address, derivationPath: this._derivationPath, publicKey })];
        });
    }
    getLedgerAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const app = yield this._ledgerProvider.getApp();
            return yield app.getAddress(this._derivationPath);
        });
    }
    exportPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new errors_1.UnimplementedMethodError('Method not supported.');
        });
    }
    isWalletAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            return Boolean(this.getAddress());
        });
    }
    getConnectedNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._ledgerProvider.getConnectedNetwork();
        });
    }
    canUpdateFee() {
        return true;
    }
}
exports.EvmLedgerProvider = EvmLedgerProvider;
//# sourceMappingURL=EvmLedgerProvider.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmLedgerSigner = void 0;
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const address_1 = require("@ethersproject/address");
const bignumber_1 = require("@ethersproject/bignumber");
const bytes_1 = require("@ethersproject/bytes");
const properties_1 = require("@ethersproject/properties");
const strings_1 = require("@ethersproject/strings");
const transactions_1 = require("@ethersproject/transactions");
const ledger_1 = __importDefault(require("@ledgerhq/hw-app-eth/lib/services/ledger"));
const defaultPath = "m/44'/60'/0'/0/0";
const loadConfig = {
    nftExplorerBaseURL: null,
    // example of payload https://cdn.live.ledger.com/plugins/ethereum/1.json
    // fetch against an api (base url is an api that hosts /plugins/ethereum/${chainId}.json )
    // set to null will disable it
    pluginBaseURL: null,
    // provide manually some extra plugins to add for the resolution (e.g. for dev purpose)
    // object will be merged with the returned value of the Ledger cdn payload
    extraPlugins: null,
};
const resolutionConfig = {
    // NFT resolution service
    nft: false,
    // external plugins resolution service (e.G. LIDO)
    externalPlugins: false,
    // ERC20 resolution service (to clear sign erc20 transfers & other actions)
    erc20: false,
};
class EvmLedgerSigner extends abstract_signer_1.Signer {
    constructor(getApp, derivationPath, provider, addressCache) {
        super();
        this.provider = provider;
        this.addressCache = {};
        this.getApp = getApp;
        this.derivationPath = derivationPath || defaultPath;
        if (addressCache) {
            const { publicKey, address } = addressCache;
            this.addressCache = {
                [this.derivationPath]: { publicKey, address },
            };
        }
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.addressCache[this.derivationPath]) {
                return (0, address_1.getAddress)(this.addressCache[this.derivationPath].address.toLowerCase());
            }
            const { address, publicKey } = yield this._retry((eth) => __awaiter(this, void 0, void 0, function* () { return yield eth.getAddress(this.derivationPath); }));
            this.addressCache[this.derivationPath] = { address, publicKey };
            return (0, address_1.getAddress)(address === null || address === void 0 ? void 0 : address.toLowerCase());
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof message === 'string') {
                message = (0, strings_1.toUtf8Bytes)(message);
            }
            const messageHex = (0, bytes_1.hexlify)(message).substring(2);
            const sig = yield this._retry((eth) => eth.signPersonalMessage(this.derivationPath, messageHex));
            sig.r = '0x' + sig.r;
            sig.s = '0x' + sig.s;
            return (0, bytes_1.joinSignature)(sig);
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield (0, properties_1.resolveProperties)(transaction);
            const baseTx = {
                chainId: tx.chainId || undefined,
                data: tx.data || undefined,
                gasLimit: tx.gasLimit || undefined,
                gasPrice: tx.gasPrice || undefined,
                nonce: tx.nonce ? bignumber_1.BigNumber.from(tx.nonce).toNumber() : undefined,
                type: tx.type,
                to: tx.to || undefined,
                value: tx.value || undefined,
            };
            if (transaction.type === transactions_1.TransactionTypes.eip1559) {
                baseTx.maxFeePerGas = tx.maxFeePerGas;
                baseTx.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
            }
            const unsignedTx = (0, transactions_1.serialize)(baseTx).substring(2);
            const resolution = yield ledger_1.default.resolveTransaction(unsignedTx, loadConfig, resolutionConfig);
            const sig = yield this._retry((eth) => __awaiter(this, void 0, void 0, function* () { return yield eth.signTransaction(this.derivationPath, unsignedTx, resolution); }));
            return (0, transactions_1.serialize)(baseTx, {
                v: bignumber_1.BigNumber.from('0x' + sig.v).toNumber(),
                r: '0x' + sig.r,
                s: '0x' + sig.s,
            });
        });
    }
    connect(provider) {
        return new EvmLedgerSigner(this.getApp, this.derivationPath, provider);
    }
    _retry(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const eth = yield this.getApp();
            try {
                return yield callback(eth);
            }
            catch (error) {
                if (error.id !== 'TransportLocked') {
                    throw Error(error);
                }
            }
        });
    }
}
exports.EvmLedgerSigner = EvmLedgerSigner;
//# sourceMappingURL=EvmLedgerSigner.js.map
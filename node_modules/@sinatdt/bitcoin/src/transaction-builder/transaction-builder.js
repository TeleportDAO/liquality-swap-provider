const bitcoin = require("bitcoinjs-lib")
const BaseBitcoinLikeTransactionBuilderCommon = require("./transaction-builder-common")
const { getAddressType } = require("../bitcoin-utils")

class BaseBitcoinLikeTransaction extends BaseBitcoinLikeTransactionBuilderCommon {
  async convertBaseInputsToInputs(baseInputs = []) {
    let inputs = baseInputs
    let transactionId = null
    let transactionHex = null
    for (let i in inputs) {
      let { address, publicKey, addressType } = inputs[i].signerInfo
      let addressObject = this.createAddressObject({
        address,
        publicKey: publicKey ? Buffer.from(publicKey, "hex") : null,
        addressType,
      })
      if (addressType === "p2pkh") {
        // add p2pkh data
        if (transactionId === inputs[i].hash) {
          inputs[i].nonWitnessUtxo = Buffer.from(transactionHex, "hex")
        } else {
          transactionHex = await this._getTransactionHex(inputs[i].hash)
          inputs[i].nonWitnessUtxo = Buffer.from(transactionHex, "hex")
          transactionId = inputs[i].hash
        }
      } else if (addressType === "p2wpkh") {
        // add p2wpkh data
        inputs[i].witnessUtxo = {
          script: addressObject.output,
          value: inputs[i].value,
        }
      } else if (addressType === "p2sh-p2wpkh") {
        // add p2sh-p2wpkh data
        inputs[i].witnessUtxo = {
          script: addressObject.output,
          value: inputs[i].value,
        }
        inputs[i].redeemScript = addressObject.redeem.output
      }
    }

    return inputs
  }

  createUnsignedTransaction({
    inputs,
    outputs,
    change,
    fee, // not used  in this section - just returned
    feeRate,
  }) {
    const { network } = this
    const newPsbt = new bitcoin.Psbt({ network })
    newPsbt.setMaximumFeeRate = feeRate + feeRate / 100
    // add input
    for (const input of inputs) {
      let { addressType } = input.signerInfo
      switch (addressType) {
        case "p2pkh":
          newPsbt.addInput({
            hash: input.hash,
            index: Number(input.index),
            nonWitnessUtxo: input.nonWitnessUtxo,
            sequence: 0xffffffff - 1,
          })
          break
        case "p2wpkh":
          newPsbt.addInput({
            hash: input.hash,
            index: Number(input.index),
            witnessUtxo: input.witnessUtxo,
            sequence: 0xffffffff - 1,
          })
          break
        case "p2sh-p2wpkh":
          newPsbt.addInput({
            hash: input.hash,
            index: Number(input.index),
            witnessUtxo: input.witnessUtxo,
            redeemScript: input.redeemScript,
            sequence: 0xffffffff - 1,
          })
          break
        default:
          throw new Error("address type is incorrect")
      }
    }

    // add outputs
    for (const target of outputs) {
      newPsbt.addOutput(target)
    }

    // add changeAddress
    if (change && Object.keys(change).length !== 0) {
      newPsbt.addOutput({
        address: change.address,
        value: Number(change.value),
      })
    }

    // check created outputs with targets
    for (let i in outputs) {
      if (newPsbt.txOutputs[i].address !== outputs[i].address) {
        throw new Error("error address")
      }
      if (newPsbt.txOutputs[i].value !== outputs[i].value) {
        throw new Error("error value")
      }
    }
    if (change && Object.keys(change).length !== 0) {
      if (newPsbt.txOutputs[outputs.length].address !== change.address) {
        throw new Error("error change address")
      }
      if (newPsbt.txOutputs[outputs.length].value !== change.value) {
        throw new Error("error change value")
      }
    }

    const unsignedPsbtBaseText = newPsbt.toBase64()
    return {
      unsignedTransaction: unsignedPsbtBaseText,
      outputs,
      inputs: inputs.map((tx) => ({
        hash: tx.hash,
        value: Number(tx.value),
        index: tx.index,
        signerInfo: tx.signerInfo,
      })),
      fee,
      change,
    }
  }
}

module.exports = BaseBitcoinLikeTransaction

/* eslint-disable no-underscore-dangle */

const bitcoin = require('bitcoinjs-lib')
const coinselect = require('coinselect')
const coinselectSplit = require('coinselect/split')
const { createAddressObjectByPublicKey } = require('../bitcoin-utils')

const TX_EMPTY_SIZE = 4 + 1 + 1 + 4
const TX_INPUT_BASE = 32 + 4 + 1 + 4
const TX_INPUT_P2PKH = 107
const TX_INPUT_P2SH_P2PKH = 50
const TX_INPUT_P2WPKH = 47
const TX_OUTPUT_BASE = 8 + 1
const TX_OUTPUT_P2PKH = 25

const componentBytes = {
  bytePerInput: {
    p2pkh: TX_INPUT_BASE + TX_INPUT_P2PKH,
    p2wpkh: TX_INPUT_BASE + TX_INPUT_P2WPKH,
    p2shp2wpkh: TX_INPUT_BASE + TX_INPUT_P2SH_P2PKH,
  },
  baseTxBytes: TX_EMPTY_SIZE,
  bytePerOutput: TX_OUTPUT_BASE + TX_OUTPUT_P2PKH,
}

class BaseBitcoinLikeTransaction {
  // abstract
  constructor({
    network,
    testnet,
    feeMin = 0,
    dustLimit,
    maximumNumberOfOutputsInTransaction = 50,
  }) {
    this.testnet = testnet
    this.network = network
    this.maximumNumberOfOutputsInTransaction = maximumNumberOfOutputsInTransaction
    this.feeMin = feeMin
    this.dustLimit = dustLimit || 1 * 2 * componentBytes.bytePerInput.p2pkh
  }

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  createAddressObject({ addressType, publicKey }) {
    return createAddressObjectByPublicKey({ addressType, publicKey }, this.network)
  }

  validateAddress(address) {
    try {
      let isValid = false
      let network = this.network
      let isAddressSegwit = address.startsWith(network.bech32)
      if (isAddressSegwit) {
        bitcoin.address.fromBech32(address)
        isValid = true
      } else {
        let base58Data = bitcoin.address.fromBase58Check(address)
        isValid =
          base58Data.version === Number(network.scriptHash) ||
          base58Data.version === Number(network.pubKeyHash)
      }
      return isValid
    } catch (error) {
      return false
    }
  }

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  async _getUtxo(userAddress) {
    // The child has implemented this method.
    throw new Error('Do not call abstract method directly')
    // return utxo
  }

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  async _getTransactionHex(transactionId) {
    // The child has implemented this method.
    throw new Error('Do not call abstract method directly')
    // return utxo
  }

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  async convertBaseInputsToInputs(baseInputs) {
    // The child has implemented this method.
    throw new Error('Do not call abstract method directly')
    // return utxo
  }

  // eslint-disable-next-line no-unused-vars, class-methods-use-this
  async createUnsignedTransaction(baseInputs) {
    // The child has implemented this method.
    throw new Error('Do not call abstract method directly')
    // return utxo
  }

  static helperHandleInputsAndOutputs({
    targets,
    extendedUtxo,
    feeRate,
    changeAddress,
    fullAmount,
  }) {
    let { inputs, outputs, fee } = fullAmount
      ? coinselectSplit(extendedUtxo, [{ address: targets[0].address }], Number(feeRate))
      : coinselect(extendedUtxo, targets, Number(feeRate))

    if (!inputs || !outputs) {
      throw new Error('not enough balance')
    }
    let changeIndex = outputs.findIndex((x) => !x.address && !x.script && x.value > 0)
    let change
    if (changeIndex >= 0) {
      change = {
        address: changeAddress,
        value: outputs[changeIndex].value,
      }
      outputs.splice(changeIndex, 1)
    }

    return {
      inputs,
      fee,
      outputs,
      change,
    }
  }

  /**
   *
   * @param {Object} signerInfo
   * @param {String} signerInfo.address
   * @param {String} signerInfo.addressType
   * @param {String?} signerInfo.publicKey
   * *@param {Array?} signerInfo.publicKeys // todo not used yet- used in multi sig
   * @param {String?} signerInfo.privateKeyId
   * @param {String?} signerInfo.derivationPath
   * @returns
   */
  async getExtendedUtxo(signerInfo) {
    let utxo = await this._getUtxo(signerInfo.address)
    const extendedUtxo = utxo.map((input) => ({
      ...input,
      signerInfo,
    }))
    if (!extendedUtxo || extendedUtxo.length === 0) {
      throw new Error('no utxo found')
    }
    return extendedUtxo
  }

  /**
   *
   * @param {Object[]} extendedUtxo
   * @param {String} extendedUtxo[].hash
   * @param {Number} extendedUtxo[].index
   * @param {Number} extendedUtxo[].value
   * @param {Object} extendedUtxo[].signerInfo
   * @param {Object} extendedUtxo[].signerInfo.address
   * @param {Object} extendedUtxo[].signerInfo.publicKey
   * @param {String} extendedUtxo[].signerInfo.addressType
   * @param {Number} extendedUtxo[].signerInfo.privateKeyId
   */
  async convertUtxoToInput({ extendedUtxo, targets, changeAddress, fullAmount = false, feeRate }) {
    let {
      inputs: filteredInputs,
      outputs,
      change,
      fee,
    } = BaseBitcoinLikeTransaction.helperHandleInputsAndOutputs({
      targets,
      extendedUtxo,
      fullAmount,
      feeRate,
      changeAddress,
    })

    let inputs = await this.convertBaseInputsToInputs(filteredInputs)

    return {
      inputs,
      outputs,
      change,
      fee,
      feeRate,
    }
  }

  async processUnsignedTransaction({
    extendedUtxo,
    targets = [],
    changeAddress = undefined,
    fullAmount = false,
    feeRate,
    selfTransaction = false,
  }) {
    if (!selfTransaction && targets.length === 0) throw new Error('no target')

    const { inputs, outputs, change, fee } = await this.convertUtxoToInput({
      extendedUtxo,
      targets,
      changeAddress,
      fullAmount,
      feeRate,
    })
    let unsignedTransaction = await this.createUnsignedTransaction({
      inputs,
      outputs,
      change,
      fee,
      feeRate,
    })

    return unsignedTransaction
  }

  getOpReturnTarget(dataHex) {
    if (!dataHex.length > 0) throw new Error('invalid data in hex')
    const embed = bitcoin.payments.embed({
      data: [Buffer.from(dataHex, 'hex')],
      network: this.network,
    })
    return {
      script: embed.output,
      value: 0,
    }
  }
}

module.exports = BaseBitcoinLikeTransaction

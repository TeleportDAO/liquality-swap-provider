const bip39 = require("bip39")
const bip32 = require("bip32")

const hdWalletNetworksPath = require("@sinatdt/configs").hdWalletPath

const networks = require("./utils/networks")

const TransactionBuilder = require("./transaction-builder/bitcoin-transaction-builder")
const BitcoinSign = require("./sign/sign-transaction")

class BitcoinBase {
  constructor(
    // eslint-disable-next-line default-param-last
    connectionInfo = {
      api: {
        enabled: true,
        provider: "BlockStream",
      },
    },
    networkName,
  ) {
    this.network = networks[networkName]
    this.hdWalletPath = hdWalletNetworksPath[networkName.replace("_testnet", "")]

    this.transactionBuilder = new TransactionBuilder(connectionInfo, networkName, this.network)
    this.btcInterface = this.transactionBuilder.btcInterface

    this.signer = new BitcoinSign(this.network)

    this.currentAccount = null
    this.currentAccountType = null

    this.privateKey = null
    this.publicKey = null
    // todo multisig
    this.publicKeys = []
  }

  setMultiSigAccount(accountType = "p2sh") {
    /* eslint-disable no-unreachable */
    // todo : not completed
    switch (accountType) {
      // case 'p2sh':
      //   this.currentAccount = ''
      //   break
      // case 'p2wsh':
      //   this.currentAccount = ''
      //   break
      // case 'p2sh-p2wsh':
      //   this.currentAccount = ''
      //   break
      default:
        throw new Error("accountType is incorrect")
    }
    this.currentAccountType = accountType
  }

  setAccountPrivateKey(privateKeyHex) {
    this.privateKey = Buffer.from(privateKeyHex, "hex")
  }

  setAccountPublicKey(publicKeyHex) {
    this.publicKey = Buffer.from(publicKeyHex, "hex")
  }

  setAccountPrivateKeyByMnemonic({
    mnemonic,
    mnemonicPassword = "",
    index = 0,
    walletNumber = 0,
    addressType = "p2sh-p2wpkh",
  }) {
    if (!bip39.validateMnemonic(mnemonic)) throw new Error("invalid mnemonic")
    const seed = bip39.mnemonicToSeedSync(mnemonic, mnemonicPassword)
    const node = bip32.fromSeed(seed)

    if (!this.hdWalletPath[addressType]) throw new Error("incorrect path or addressType")

    const path = `${this.hdWalletPath[addressType]}/${walletNumber}`
    const account = node.derivePath(path)
    const userKeyPair = account.derive(index)
    this.setAccountPrivateKey(userKeyPair.privateKey.toString("hex"))
    this.setAccountPublicKey(userKeyPair.publicKey.toString("hex"))
  }

  setAccount(accountType = "p2pkh") {
    let addressObj = this.transactionBuilder.createAddressObject({
      addressType: accountType,
      publicKey: this.publicKey,
    })
    this.currentAccount = addressObj.address
    this.currentAccountType = accountType
    this.addressObj = addressObj
    return addressObj.address
  }

  /**
   *
   * @param {Object} signerInfo
   * @param {String} signerInfo.address
   * @param {String} signerInfo.addressType
   * @param {String?} signerInfo.publicKey
   * *@param {Array?} signerInfo.publicKeys // todo not used yet- used in multi sig
   * @param {String?} signerInfo.derivationPath
   * @param {String?} signerInfo.privateKeyId
   * @returns
   */
  async getExtendedUtxo({ address, addressType, publicKey, derivationPath }) {
    return this.transactionBuilder.getExtendedUtxo({
      address,
      addressType,
      publicKey,
      derivationPath,
    })
  }

  static checkBalanceIsSufficient({
    targets,
    extendedUtxo,
    changeAddress,
    feeRate,
    fullAmount = false,
  }) {
    try {
      TransactionBuilder.helperHandleInputsAndOutputs({
        targets,
        extendedUtxo,
        changeAddress,
        feeRate,
        fullAmount,
      })
      return true
    } catch (err) {
      return false
    }
  }

  async send({ receiverAddress, amount, fullAmount = false, speed = "normal" }) {
    let extendedUtxo = await this.getExtendedUtxo({
      address: this.currentAccount,
      addressType: this.currentAccountType,
      publicKey: this.publicKey.toString("hex"),
    })
    let feeRate = this.transactionBuilder._getFeeRate(speed)
    let unsignedTx = await this.transactionBuilder.processUnsignedTransaction({
      extendedUtxo,
      targets: [
        {
          address: receiverAddress,
          value: amount,
        },
      ],
      changeAddress: this.currentAccount,
      feeRate,
      fullAmount,
    })
    let signedPsbt = await this.signer.signPsbt(unsignedTx, this.privateKey)
    let signedTx = this.signer.finalizePsbts([signedPsbt])
    let txId = await this.transactionBuilder.sendTx(signedTx)
    return txId
  }

  async sendSignedPsbt(signedPsbt) {
    let signedTx = this.signer.finalizePsbts([signedPsbt])
    let txId = await this.transactionBuilder.sendTx(signedTx)
    return txId
  }

  async sendMultiSignedPsbt(signedPsbts = []) {
    let signedTx = this.signer.finalizePsbts(signedPsbts)
    let txId = await this.transactionBuilder.sendTx(signedTx)
    return txId
  }
}

module.exports = BitcoinBase

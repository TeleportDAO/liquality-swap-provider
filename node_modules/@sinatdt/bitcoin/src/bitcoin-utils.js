let { ECPairFactory } = require("ecpair")
let ecc = require("tiny-secp256k1")
let varUnit = require("varuint-bitcoin")
const fastRoot = require("merkle-lib/fastRoot")
const merkle = require("merkle-lib")
const merkleProof = require("merkle-lib/proof")
const bitcoin = require("bitcoinjs-lib")
const networks = require("./utils/networks")

function parseRawTransaction(rawTransaction) {
  const size = {
    version: 4,
    flag: 2,
    tx: 32,
    index: 4,
    sequence: 4,
    amount: 8,
  }

  let offset = 0
  let version = rawTransaction.slice(offset, size.version * 2)
  offset += size.version * 2
  let flag = rawTransaction.slice(offset, offset + size.flag * 2)
  offset = flag === "0001" ? offset + size.flag * 2 : offset // * 0x0001 is flag in segwit transactions

  let inputsStartIndex = offset

  let numberOfInputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
  let noiSize = varUnit.encodingLength(numberOfInputs)
  offset += noiSize * 2

  for (let i = 0; i < numberOfInputs; i += 1) {
    offset += size.tx * 2
    offset += size.index * 2
    let sigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
    let sigLengthSize = varUnit.encodingLength(sigLength)
    offset += sigLengthSize * 2
    offset += sigLength * 2
    offset += size.sequence * 2
  }
  let inputLastIndex = offset
  let outputStartIndex = offset

  let numberOfOutputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
  let nooSize = varUnit.encodingLength(numberOfOutputs)
  offset += nooSize * 2

  for (let i = 0; i < numberOfOutputs; i += 1) {
    offset += size.amount * 2
    let unlockSigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"))
    let unlockSigLengthSize = varUnit.encodingLength(unlockSigLength)
    offset += unlockSigLengthSize * 2
    offset += unlockSigLength * 2
  }
  let outputLastIndex = offset

  version = `0x${version}`
  flag = `0x${flag}`
  const vin = `0x${rawTransaction.slice(inputsStartIndex, inputLastIndex)}`
  const vout = `0x${rawTransaction.slice(outputStartIndex, outputLastIndex)}`
  let witness = `0x${rawTransaction.slice(outputLastIndex, rawTransaction.length - 8)}`
  let locktime = `0x${rawTransaction.slice(rawTransaction.length - 8, rawTransaction.length)}`
  return { version, flag, vin, vout, witness, locktime }
}

function reverseBytes(hexInput) {
  return Buffer.from(hexInput, "hex").reverse().toString("hex")
}

function getAddressType(address, network) {
  if (address.startsWith(network.bech32)) {
    // todo : check length - it could be p2wsh
    return "p2wpkh"
  }
  let base58Data = bitcoin.address.fromBase58Check(address)
  if (base58Data.version === Number(network.scriptHash)) {
    return "p2sh"
  }
  if (base58Data.version === Number(network.pubKeyHash)) {
    return "p2pkh"
  }

  throw new Error("invalid address")
}

function createAddressObjectByHash({ addressType, hash }, network) {
  let addressObject
  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        hash,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        hash,
        network,
      })
      break
    case "p2sh":
      addressObject = bitcoin.payments.p2sh({
        hash,
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return addressObject
}

function createAddressObjectByScript({ addressType, script }, network) {
  let addressObject
  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        output: script,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        output: script,
        network,
      })
      break
    case "p2sh":
      addressObject = bitcoin.payments.p2sh({
        output: script,
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return addressObject
}

function createAddressObjectByPublicKey({ addressType, publicKey }, network) {
  let addressObject

  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        pubkey: publicKey,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        pubkey: publicKey,
        network,
      })
      break
    case "p2sh-p2wpkh":
      addressObject = bitcoin.payments.p2sh({
        redeem: bitcoin.payments.p2wpkh({
          pubkey: publicKey,
          network,
        }),
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return addressObject
}

function createAddressObjectByAddress(address, network) {
  let addressType = getAddressType(address, network)
  let addressObject

  switch (addressType) {
    case "p2pkh":
      addressObject = bitcoin.payments.p2pkh({
        address,
        network,
      })
      break
    case "p2wpkh":
      addressObject = bitcoin.payments.p2wpkh({
        address,
        network,
      })
      break
    case "p2sh":
      addressObject = bitcoin.payments.p2sh({
        address,
        network,
      })
      break
    default:
      throw new Error("address type is incorrect")
  }
  return { addressObject, addressType }
}

// not used

async function deriveAddressFromPubKey(pubKey, network) {
  let { address } = this.bitcoinJS.payments.p2pkh({
    network,
    pubkey: Buffer.from(pubKey, "hex"),
  })
  return address
}

async function deriveAddressFromBufferPubKey(pubKey, network) {
  let { address } = this.bitcoinJS.payments.p2pkh({ network, pubkey: pubKey })
  return address
}

async function getPubKeyFromPrivateKey(privateKey, network) {
  let ECPair = ECPairFactory(ecc)
  let key = ECPair.fromWIF(privateKey, network)
  return key.publicKey
}

function calculateMerkleProof(blockTransactions, txId, blockMerkleRoot = null) {
  let transactionIndex = blockTransactions.findIndex((tx) => tx === txId)
  if (transactionIndex < 0) throw new Error("txId is not in this tree")
  let data = blockTransactions.map((a) => Buffer.from(a, "hex").reverse())

  if (
    blockMerkleRoot &&
    blockMerkleRoot !== fastRoot(data, bitcoin.crypto.hash256).toString("hex")
  ) {
    throw new Error("calculated anf block merkleRoot not matched")
  }

  let tree = merkle(data, bitcoin.crypto.hash256)
  let proof = merkleProof(tree, data[transactionIndex])

  let intermediateNodesArray = proof
    .map((_id) => _id && _id.toString("hex"))
    .filter((_id) => _id != null)
  let intermediateNodes = intermediateNodesArray.reduce(
    (a, value, index) =>
      index !== transactionIndex % 2 && index < intermediateNodesArray.length - 1 ? a + value : a,
    "0x",
  )
  return {
    intermediateNodes,
    transactionIndex,
  }
}

function parseBlockHeader(headerHex) {
  const size = {
    version: 4,
    previousBlockHash: 32,
    merkleRoot: 32,
    timestamp: 4,
    difficulty: 4,
    nonce: 4,
  }
  let offset = 0
  let result = {}
  for (let key in size) {
    result[key] = headerHex.slice(offset, offset + size[key] * 2)
    offset += size[key] * 2
  }
  return result
}

function convertBitcoinScriptToAddress(script, network) {
  try {
    return bitcoin.address?.fromOutputScript(script, network)
  } catch (error) {
    return null
  }
}

function parseRawBlock(rawBlockHex, blockNumber = null, network = bitcoin.networks.network) {
  let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"))
  let blockHash = block.getHash().toString("hex")
  let merkleRoot = block.merkleRoot.toString("hex")
  let prvBlockHash = block.prevHash.toString("hex")
  return {
    blockNumber,
    merkleRoot,
    prvBlockHash,
    transactions: block.transactions.map((tx) => ({
      txId: tx.getId(),
      version: tx.version,
      locktime: tx.locktime,
      blockNumber,
      blockHash,
      vout: tx.outs.map((vo) => ({
        address: convertBitcoinScriptToAddress(vo.script, network),
        script: vo.script.toString("hex"),
        value: vo.value,
      })),
      vin: tx.ins.map((vi) => ({
        txId: vi.hash.reverse().toString("hex"),
        index: vi.index,
        // // todo optional get from utxo
        // address: null,
        // script: null,
        // value: null,
      })),
    })),
  }
}

function extractTransactionsAndBlockInfoFromRawBlock(
  rawBlockHex,
  blockNumber,
  addresses = [],
  inputs = [],
  network = bitcoin.networks.bitcoin,
) {
  let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"))
  let blockHash = block.getHash().reverse().toString("hex")
  let merkleRoot = block.merkleRoot.toString("hex")
  let prvBlockHash = block.prevHash.toString("hex")

  let blockInfo = {
    blockNumber,
    blockHash,
    merkleRoot,
    prvBlockHash,
  }

  let addressScript = addresses.map((address) =>
    createAddressObjectByAddress(address, network).addressObject.output.toString("hex"),
  )

  let blockTxIds = block.transactions.map((tx) => tx.getId())

  let withdrawTxs = []
  let depositTxs = []
  block.transactions.forEach((tx) => {
    let txId = tx.getId()
    let transactionAddressIndex

    let txVinInput = inputs.find((vin) => vin.txId === txId)
    if (txVinInput) {
      let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot)

      withdrawTxs.push({
        txId: tx.getId(),
        version: tx.version,
        locktime: tx.locktime,
        blockNumber,
        blockHash,
        merkleProof: txMerkleProof,
        vout: tx.outs.map((vo) => ({
          address: convertBitcoinScriptToAddress(vo.script, network),
          script: vo.script.toString("hex"),
          value: vo.value,
        })),
        vin: tx.ins.map((vi) => {
          let viInput = inputs.find((vin) => vin.txId === txId)
          return {
            txId: vi.hash.reverse().toString("hex"),
            index: vi.index,
            address: viInput.address || null,
            script: viInput.script || null,
            value: viInput.value || null,
          }
        }),
        address: txVinInput.address,
        addressScript: createAddressObjectByAddress(
          txVinInput.address,
          network,
        ).addressObject.output.toString("hex"),
      })
    } else if (
      tx.outs.findIndex((blockTxVo) => {
        let sIndex = addressScript.findIndex(
          (addScript) => addScript === blockTxVo.script.toString("hex"),
        )
        if (sIndex >= 0) {
          transactionAddressIndex = sIndex
          return true
        }
        return false
      }) >= 0
    ) {
      // todo we can optimize this calculation (in following function, merkle tree calculate each times but we can do this once for this block)
      let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot)
      depositTxs.push({
        txId: tx.getId(),
        version: tx.version,
        locktime: tx.locktime,
        blockNumber,
        blockHash,
        merkleProof: txMerkleProof,
        vout: tx.outs.map((vo) => ({
          address: convertBitcoinScriptToAddress(vo.script, network),
          script: vo.script.toString("hex"),
          value: vo.value,
        })),
        vin: tx.ins.map((vi) => ({
          txId: vi.hash.reverse().toString("hex"),
          index: vi.index,
          // // todo optional get from utxo
          // address: null,
          // script: null,
          // value: null,
        })),
        addressScript: addressScript[transactionAddressIndex],
        address: addresses[transactionAddressIndex],
      })
    }
  })
  return {
    blockInfo,
    withdrawTxs,
    depositTxs,
  }
}

module.exports = {
  parseRawTransaction,
  calculateMerkleProof,
  createAddressObjectByHash,
  createAddressObjectByPublicKey,
  createAddressObjectByAddress,
  createAddressObjectByScript,

  // ------------------------
  getAddressType,
  deriveAddressFromPubKey,
  deriveAddressFromBufferPubKey,
  getPubKeyFromPrivateKey,
  reverseBytes,

  parseBlockHeader,

  // ---------------------------
  parseRawBlock,
  extractTransactionsAndBlockInfoFromRawBlock,

  // -----------------------------
  networks,
}

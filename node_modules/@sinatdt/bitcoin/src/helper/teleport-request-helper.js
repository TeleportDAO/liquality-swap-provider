const { requestTypes: teleportRequestsType } =
  require("@sinatdt/configs").teleswap;

function parseTeleportAndExchangeRequest(data) {
  let parsedData = {};
  parsedData.requestType = "transfer";

  let offset = 0;
  parsedData.chainId = Number(`0x${data.slice(offset, (offset += 2))}`); // 1 bytes
  parsedData.appId = Number(`0x${data.slice(offset, (offset += 4))}`); // 2 bytes
  parsedData.recipientAddress = `0x${data.slice(offset, (offset += 40))}`; // 20 bytes
  parsedData.percentageFee =
    Number(`0x${data.slice(offset, (offset += 4))}`) / 100; // 2 bytes
  parsedData.speed = data.slice(offset, (offset += 2)) === "01"; // 1 byte
  if (data.length === offset) return parsedData;
  parsedData.requestType = "exchange";
  parsedData.exchangeTokenAddress = `0x${data.slice(offset, (offset += 40))}`; // 20 bytes
  parsedData.outputAmount = Number(`0x${data.slice(offset, (offset += 56))}`); // 28 bytes
  parsedData.deadline = Number(`0x${data.slice(offset, (offset += 8))}`); // 4 bytes
  parsedData.isFixedToken = data.slice(offset, (offset += 2)) === "01"; // 1 byte
  if (data.length === offset) return parsedData;

  console.error(
    `invalid OP Return data. data length : ${data.length} - actual length : ${offset}`
  );
  return null;
}

function parseLendAndBorrowRequest(data) {
  let parsedData = {};
  parsedData.requestType = "lend";

  let offset = 0;
  parsedData.chainId = Number(`0x${data.slice(offset, (offset += 2))}`); // 1 bytes
  parsedData.appId = Number(`0x${data.slice(offset, (offset += 4))}`); // 2 bytes
  parsedData.recipientAddress = `0x${data.slice(offset, (offset += 40))}`; // 20 bytes
  parsedData.percentageFee =
    Number(`0x${data.slice(offset, (offset += 4))}`) / 100; // 2 bytes
  parsedData.mode = Number(`0x${data.slice(offset, (offset += 2))}`); // 1 byte
  if (data.length === offset) return parsedData;
  parsedData.requestType = "borrow";
  parsedData.tokenAddress = `0x${data.slice(offset, (offset += 40))}`; // 20 bytes
  parsedData.borrowAmount = Number(`0x${data.slice(offset, (offset += 56))}`); // 28 bytes
  if (data.length === offset) return parsedData;
  console.error(
    `invalid OP Return data. data length : ${data.length} - actual length : ${offset}`
  );
  return null;
}

function parseRawRequest(opReturnData) {
  let data =
    opReturnData.slice(2, 4) === "4c"
      ? opReturnData.slice(6)
      : opReturnData.slice(4);
  // eslint-disable-next-line no-unused-vars
  let _chainId = Number(`0x${data.slice(0, 2)}`); // 1 bytes
  let appId = Number(`0x${data.slice(2, 6)}`); // 2 bytes

  //   get type base on appId
  let requestType = teleportRequestsType.find(
    (rs) => appId >= rs.appIdRange[0] && appId < rs.appIdRange[1]
  )?.type;

  switch (requestType) {
    case "teleport":
    case "exchange":
      return parseTeleportAndExchangeRequest(data);
    case "lend":
      return parseLendAndBorrowRequest(data);
    default:
      console.error(`invalid request appId : ${appId}`);
  }

  return null;
}

function validateRequestAndValue(data, value) {
  // todo : fix it
  let minAmount = 0;
  // * request not null and value > min and teleport profit > min
  let validate =
    data &&
    +value > minAmount &&
    (data.percentageFee / 100) * +value > minAmount &&
    +data.percentageFee < 100;
  return validate;
}

function checkAndParseRequest(vouts, address) {
  let opReturnData =
    vouts.find((vout_) => vout_.script.startsWith("6a"))?.script || null;
  if (opReturnData) {
    let value = vouts.find((vout_) => vout_.address === address)?.value || 0;
    let data = parseRawRequest(opReturnData);

    if (validateRequestAndValue(data, value)) return { data, value };
  }
  return null;
}

module.exports = {
  checkAndParseRequest,
};

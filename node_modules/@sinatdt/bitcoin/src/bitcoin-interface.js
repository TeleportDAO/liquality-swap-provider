const { getRpcProvider, getApiProvider } = require('@sinatdt/providers').bitcoin
const { runWithRetries, sleep } = require('./utils/tools')
const networks = require('./utils/networks')
const {
  parseRawTransaction,
  createAddressObjectByHash,
  createAddressObjectByAddress,
  createAddressObjectByPublicKey,
  calculateMerkleProof,
  parseBlockHeader,
  extractTransactionsAndBlockInfoFromRawBlock,
} = require('./bitcoin-utils')
const { checkAndParseRequest } = require('./helper/teleport-request-helper')
const { getBurnTransactionInfo } = require('./helper/burn-request-helper')

class BitcoinInterface {
  constructor(connectionInfo, networkName) {
    this.testnet = networkName.includes('_testnet')

    if (connectionInfo.rpc?.enabled) {
      this.rpcProvider = getRpcProvider(connectionInfo.rpc)
    }

    if (connectionInfo.api.enabled) {
      this.apiProviderName = connectionInfo.api.provider
      this.apiProvider = getApiProvider(connectionInfo.api, networkName)
    }

    this.provider = this.rpcProvider || this.apiProvider
    this.network = networks[networkName]
  }

  // general
  async getLatestBlockNumber() {
    let latestHeight = await this.provider.getLatestBlockNumber()
    return latestHeight
  }

  async getBlockHash(blockNumber) {
    let headerHash = await runWithRetries(() => this.provider.getBlockHash(blockNumber))
    return headerHash
  }

  async getBlockHeaderHex(blockNumber) {
    let headerHex = await runWithRetries(() => this.provider.getBlockHeaderHex(blockNumber))
    return headerHex
  }

  async getTransaction(txId) {
    return this.provider.getTransaction(txId)
  }

  // speed : low normal fast
  async getFeeRate(speed = 'normal') {
    if (!(speed === 'normal' || speed === 'slow' || speed === 'fast')) {
      throw new Error('incorrect speed')
    }
    let fee = await this.provider.getFeeRate(speed)
    return fee
  }

  // ----------- specific

  // teleporter
  async getBlockTransactions(addresses, blockNumber) {
    let utxos = await this.getAddressesUtxo(addresses)
    let rawBlockHex = await this.rpcProvider.getBlockByBlockNumber(blockNumber, 0)
    let { withdrawTxs, depositTxs } = extractTransactionsAndBlockInfoFromRawBlock(
      rawBlockHex,
      blockNumber,
      addresses,
      utxos,
      this.network,
    )
    // todo : check
    return depositTxs.concat(withdrawTxs)
  }

  // teleporter
  async getMultipleBlocksTransactions(addresses, startBlockNumber, endBlockNumber) {
    if (endBlockNumber - startBlockNumber > 20) {
      throw new Error('cant get more than 20 block per function call')
    }
    let blockTxs = []
    for (let blockNumber = +startBlockNumber + 1; blockNumber <= endBlockNumber; blockNumber += 1) {
      const response = this.getBlockTransactions(addresses, blockNumber)
      blockTxs.push(response)
      await sleep(200)
    }
    blockTxs = await Promise.all(blockTxs)
    return blockTxs.flat(1)
  }

  // teleporter
  async getTransactionHistory(addresses, startBlockNumber, endBlockNumber) {
    if (this.rpcProvider) {
      let endBlock = endBlockNumber || (await this.getLatestBlockNumber())
      let startBlock = Math.max(+startBlockNumber, +endBlock - 20)
      console.log('startBlock , endBlock ', startBlock, endBlock)
      return this.getMultipleBlocksTransactions(addresses, startBlock, endBlock)
    }
    if (this.apiProviderName !== 'BlockStream') {
      throw new Error('teleporter just support BlockStream as api provider')
    }
    let txs = await this.apiProvider.getTransactionHistoryForMultipleAddresses(
      addresses,
      startBlockNumber,
    )
    return txs.flat(1)
  }

  // used in script
  async getMempoolTransactionHistory(addresses) {
    if (this.apiProviderName !== 'BlockStream') {
      throw new Error('teleporter just support BlockStream as api provider')
    }
    let txs = await this.apiProvider.getMempoolTransactionHistoryForMultipleAddresses(addresses)
    return txs.flat(1)
  }

  // teleporter + locker
  async getAddressesUtxo(addresses) {
    const allPromises = []
    for (let address of addresses) {
      let promise = await this.apiProvider.getUtxos(address)
      allPromises.push(promise)
    }
    let result = await Promise.all(allPromises)
    return result.flat(1)
  }

  // relayer
  async getHexBlockHeaders(startBlockNumber, endBlockNumber) {
    const blockHeaders = []
    let difficulty = null
    let hexBlockHeaders = ''

    let fromBlockNumber = startBlockNumber
    for (let blockNumber = startBlockNumber; blockNumber <= endBlockNumber; blockNumber += 1) {
      let blockHeader = await this.getBlockHeaderHex(blockNumber)
      console.log('block', blockNumber)
      let parsedBlockHeader = parseBlockHeader(blockHeader)
      if (difficulty && parsedBlockHeader.difficulty !== difficulty) {
        blockHeaders.push({
          hexBlockHeaders,
          fromBlockNumber,
          toBlockNumber: blockNumber - 1,
          difficulty,
        })
        hexBlockHeaders = blockHeader
        fromBlockNumber = blockNumber
      } else {
        hexBlockHeaders += blockHeader
      }
      difficulty = parsedBlockHeader.difficulty
    }
    if (hexBlockHeaders) {
      blockHeaders.push({
        hexBlockHeaders,
        fromBlockNumber,
        toBlockNumber: endBlockNumber,
        difficulty,
      })
    }

    return blockHeaders
  }

  // -------------
  async getTeleporterRequests(addresses, startblockNumber, endBlockNumber, mempool = false) {
    // transaction in StartBlock is not returned --> (startblockNumber,endBlockNumber]
    let transactions = mempool
      ? await this.getMempoolTransactionHistory(addresses)
      : await this.getTransactionHistory(addresses, startblockNumber, endBlockNumber)

    let requests = []
    for (let transaction of transactions) {
      let address = transaction.address
      console.log(`received tx to add for teleport: ${transaction.txId}`)
      let request = checkAndParseRequest(transaction.vout, address)
      if (request) {
        requests.push({
          transaction,
          request,
          lockerAddress: address,
          lockerLockingScript:
            transaction.addressScript ||
            this.convertAddressToScript(address).script.toString('hex'),
        })
      }
    }
    return requests
  }

  async getLockersBurnTransactions(addresses, startBlockNumber, endBlockNumber, mempool = false) {
    let transactions = mempool
      ? await this.getMempoolTransactionHistory(addresses)
      : await this.getTransactionHistory(addresses, startBlockNumber, endBlockNumber)

    let validTxs = []
    for (let transaction of transactions) {
      let address = transaction.address
      console.log(`received tx to check burn: ${transaction.txId}`)
      // check if its a transaction to spend btc
      let burnInfo = getBurnTransactionInfo(address, transaction.vin, transaction.vout)
      if (burnInfo) {
        validTxs.push({
          transaction,
          burnInfo,
          lockerAddress: address,
          lockerLockingScript:
            transaction.addressScript ||
            this.convertAddressToScript(address).script.toString('hex'),
        })
      }
    }
    return validTxs
  }

  async getRequestProof(transaction) {
    let transactionHex =
      transaction.hex || (await this.provider.getRawTransaction(transaction.txId))

    let txInfo
    if (!(transaction.blockHash && transaction.blockNumber)) {
      txInfo = await this.provider.getTransaction(transaction.txId)
    }
    let blockHash = transaction.blockHash || txInfo.blockHash
    let blockNumber = transaction.blockNumber || txInfo.blockNumber
    let parsedTx = parseRawTransaction(transactionHex)
    let merkleProof =
      transaction.merkleProof || (await this.getMerkleProof(transaction.txId, blockHash))

    return {
      parsedTx,
      merkleProof,
      blockNumber,
      blockHash,
    }
  }

  async getMerkleProof(txId, blockHash) {
    let txIds = await this.provider.getBlockTransactionIds(blockHash)
    // let a = await this.provider.getMerkleProof(txId)
    let proof = calculateMerkleProof(txIds, txId)
    // console.log(a.intermediateNodes === proof.intermediateNodes)
    return proof
  }

  convertHashToAddress(hashHex, addressType) {
    let addressObj = createAddressObjectByHash(
      { addressType, hash: Buffer.from(hashHex, 'hex') },
      this.network,
    )
    return addressObj.address
  }

  convertAddressToScript(address) {
    let { addressObject, addressType } = createAddressObjectByAddress(address, this.network)
    return {
      script: addressObject.output,
      hash: addressObject.output,
      addressType,
    }
  }

  convertAddressToObject(address) {
    let addObj = createAddressObjectByAddress(address, this.network)
    return addObj
  }

  createAddressObjectByPublicKey(address, addressType) {
    let addObj = createAddressObjectByPublicKey({ address, addressType }, this.network)
    return addObj
  }

  async getBalance(address) {
    let utxos = (await this.apiProvider.getUtxos(address)) ?? []
    return utxos.reduce((a, tx) => a + Number(tx.value), 0)
  }
}

module.exports = BitcoinInterface

export = BitcoinInterface;
declare class BitcoinInterface {
    constructor(connectionInfo: any, networkName: any);
    testnet: any;
    rpcProvider: any;
    apiProviderName: any;
    apiProvider: any;
    provider: any;
    network: any;
    getLatestBlockNumber(): Promise<any>;
    getBlockHash(blockNumber: any): Promise<any>;
    getBlockHeaderHex(blockNumber: any): Promise<any>;
    getTransaction(txId: any): Promise<any>;
    getFeeRate(speed?: string): Promise<any>;
    getBlockTransactions(addresses: any, blockNumber: any): Promise<any[]>;
    getMultipleBlocksTransactions(addresses: any, startBlockNumber: any, endBlockNumber: any): Promise<any[]>;
    getTransactionHistory(addresses: any, startBlockNumber: any, endBlockNumber: any): Promise<any>;
    getMempoolTransactionHistory(addresses: any): Promise<any>;
    getAddressesUtxo(addresses: any): Promise<any[]>;
    getHexBlockHeaders(startBlockNumber: any, endBlockNumber: any): Promise<{
        hexBlockHeaders: string;
        fromBlockNumber: any;
        toBlockNumber: any;
        difficulty: any;
    }[]>;
    getTeleporterRequests(addresses: any, startblockNumber: any, endBlockNumber: any, mempool?: boolean): Promise<{
        transaction: any;
        request: {
            data: {
                requestType: string;
                chainId: number;
                appId: number;
                recipientAddress: string;
                percentageFee: number;
                speed: boolean;
                exchangeTokenAddress: string;
                outputAmount: number;
                deadline: number;
                isFixedToken: boolean;
            } | {
                requestType: string;
                chainId: number;
                appId: number;
                recipientAddress: string;
                percentageFee: number;
                mode: number;
                tokenAddress: string;
                borrowAmount: number;
            } | null;
            value: any;
        };
        lockerAddress: any;
        lockerLockingScript: any;
    }[]>;
    getLockersBurnTransactions(addresses: any, startBlockNumber: any, endBlockNumber: any, mempool?: boolean): Promise<{
        transaction: any;
        burnInfo: {
            receivers: any[];
            changes: any[];
            totalInputValue: any;
            lockerVin: any;
        };
        lockerAddress: any;
        lockerLockingScript: any;
    }[]>;
    getRequestProof(transaction: any): Promise<{
        parsedTx: {
            version: any;
            flag: any;
            vin: string;
            vout: string;
            witness: string;
            locktime: string;
        };
        merkleProof: any;
        blockNumber: any;
        blockHash: any;
    }>;
    getMerkleProof(txId: any, blockHash: any): Promise<{
        intermediateNodes: any;
        transactionIndex: any;
    }>;
    convertHashToAddress(hashHex: any, addressType: any): string | undefined;
    convertAddressToScript(address: any): {
        script: Buffer | undefined;
        hash: Buffer | undefined;
        addressType: "p2wpkh" | "p2sh" | "p2pkh";
    };
    convertAddressToObject(address: any): {
        addressObject: import("bitcoinjs-lib").Payment;
        addressType: "p2wpkh" | "p2sh" | "p2pkh";
    };
    createAddressObjectByPublicKey(address: any, addressType: any): import("bitcoinjs-lib").Payment;
    getBalance(address: any): Promise<any>;
}
//# sourceMappingURL=bitcoin-interface.d.ts.map
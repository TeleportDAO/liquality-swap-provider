"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const bitcoin = require('bitcoinjs-lib');
const coinselect = require('coinselect');
const coinselectSplit = require('coinselect/split');
const { createAddressObjectByPublicKey } = require('../bitcoin-utils');
const TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
const TX_INPUT_BASE = 32 + 4 + 1 + 4;
const TX_INPUT_P2PKH = 107;
const TX_INPUT_P2SH_P2PKH = 50;
const TX_INPUT_P2WPKH = 47;
const TX_OUTPUT_BASE = 8 + 1;
const TX_OUTPUT_P2PKH = 25;
const componentBytes = {
    bytePerInput: {
        p2pkh: TX_INPUT_BASE + TX_INPUT_P2PKH,
        p2wpkh: TX_INPUT_BASE + TX_INPUT_P2WPKH,
        p2shp2wpkh: TX_INPUT_BASE + TX_INPUT_P2SH_P2PKH,
    },
    baseTxBytes: TX_EMPTY_SIZE,
    bytePerOutput: TX_OUTPUT_BASE + TX_OUTPUT_P2PKH,
};
class BaseBitcoinLikeTransaction {
    constructor({ network, testnet, feeMin = 0, dustLimit, maximumNumberOfOutputsInTransaction = 50, }) {
        this.testnet = testnet;
        this.network = network;
        this.maximumNumberOfOutputsInTransaction = maximumNumberOfOutputsInTransaction;
        this.feeMin = feeMin;
        this.dustLimit = dustLimit || 1 * 2 * componentBytes.bytePerInput.p2pkh;
    }
    createAddressObject({ addressType, publicKey }) {
        return createAddressObjectByPublicKey({ addressType, publicKey }, this.network);
    }
    validateAddress(address) {
        try {
            let isValid = false;
            let network = this.network;
            let isAddressSegwit = address.startsWith(network.bech32);
            if (isAddressSegwit) {
                bitcoin.address.fromBech32(address);
                isValid = true;
            }
            else {
                let base58Data = bitcoin.address.fromBase58Check(address);
                isValid =
                    base58Data.version === Number(network.scriptHash) ||
                        base58Data.version === Number(network.pubKeyHash);
            }
            return isValid;
        }
        catch (error) {
            return false;
        }
    }
    _getUtxo(userAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Do not call abstract method directly');
        });
    }
    _getTransactionHex(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Do not call abstract method directly');
        });
    }
    convertBaseInputsToInputs(baseInputs) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Do not call abstract method directly');
        });
    }
    createUnsignedTransaction(baseInputs) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Do not call abstract method directly');
        });
    }
    static helperHandleInputsAndOutputs({ targets, extendedUtxo, feeRate, changeAddress, fullAmount, }) {
        let { inputs, outputs, fee } = fullAmount
            ? coinselectSplit(extendedUtxo, [{ address: targets[0].address }], Number(feeRate))
            : coinselect(extendedUtxo, targets, Number(feeRate));
        if (!inputs || !outputs) {
            throw new Error('not enough balance');
        }
        let changeIndex = outputs.findIndex((x) => !x.address && !x.script && x.value > 0);
        let change;
        if (changeIndex >= 0) {
            change = {
                address: changeAddress,
                value: outputs[changeIndex].value,
            };
            outputs.splice(changeIndex, 1);
        }
        return {
            inputs,
            fee,
            outputs,
            change,
        };
    }
    getExtendedUtxo(signerInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            let utxo = yield this._getUtxo(signerInfo.address);
            const extendedUtxo = utxo.map((input) => (Object.assign(Object.assign({}, input), { signerInfo })));
            if (!extendedUtxo || extendedUtxo.length === 0) {
                throw new Error('no utxo found');
            }
            return extendedUtxo;
        });
    }
    convertUtxoToInput({ extendedUtxo, targets, changeAddress, fullAmount = false, feeRate }) {
        return __awaiter(this, void 0, void 0, function* () {
            let { inputs: filteredInputs, outputs, change, fee, } = BaseBitcoinLikeTransaction.helperHandleInputsAndOutputs({
                targets,
                extendedUtxo,
                fullAmount,
                feeRate,
                changeAddress,
            });
            let inputs = yield this.convertBaseInputsToInputs(filteredInputs);
            return {
                inputs,
                outputs,
                change,
                fee,
                feeRate,
            };
        });
    }
    processUnsignedTransaction({ extendedUtxo, targets = [], changeAddress = undefined, fullAmount = false, feeRate, selfTransaction = false, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!selfTransaction && targets.length === 0)
                throw new Error('no target');
            const { inputs, outputs, change, fee } = yield this.convertUtxoToInput({
                extendedUtxo,
                targets,
                changeAddress,
                fullAmount,
                feeRate,
            });
            let unsignedTransaction = yield this.createUnsignedTransaction({
                inputs,
                outputs,
                change,
                fee,
                feeRate,
            });
            return unsignedTransaction;
        });
    }
    getOpReturnTarget(dataHex) {
        if (!dataHex.length > 0)
            throw new Error('invalid data in hex');
        const embed = bitcoin.payments.embed({
            data: [Buffer.from(dataHex, 'hex')],
            network: this.network,
        });
        return {
            script: embed.output,
            value: 0,
        };
    }
}
module.exports = BaseBitcoinLikeTransaction;
//# sourceMappingURL=transaction-builder-common.js.map
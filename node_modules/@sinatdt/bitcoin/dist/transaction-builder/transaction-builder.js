"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const bitcoin = require("bitcoinjs-lib");
const BaseBitcoinLikeTransactionBuilderCommon = require("./transaction-builder-common");
const { getAddressType } = require("../bitcoin-utils");
class BaseBitcoinLikeTransaction extends BaseBitcoinLikeTransactionBuilderCommon {
    convertBaseInputsToInputs(baseInputs = []) {
        return __awaiter(this, void 0, void 0, function* () {
            let inputs = baseInputs;
            let transactionId = null;
            let transactionHex = null;
            for (let i in inputs) {
                let { address, publicKey, addressType } = inputs[i].signerInfo;
                let addressObject = this.createAddressObject({
                    address,
                    publicKey: publicKey ? Buffer.from(publicKey, "hex") : null,
                    addressType,
                });
                if (addressType === "p2pkh") {
                    if (transactionId === inputs[i].hash) {
                        inputs[i].nonWitnessUtxo = Buffer.from(transactionHex, "hex");
                    }
                    else {
                        transactionHex = yield this._getTransactionHex(inputs[i].hash);
                        inputs[i].nonWitnessUtxo = Buffer.from(transactionHex, "hex");
                        transactionId = inputs[i].hash;
                    }
                }
                else if (addressType === "p2wpkh") {
                    inputs[i].witnessUtxo = {
                        script: addressObject.output,
                        value: inputs[i].value,
                    };
                }
                else if (addressType === "p2sh-p2wpkh") {
                    inputs[i].witnessUtxo = {
                        script: addressObject.output,
                        value: inputs[i].value,
                    };
                    inputs[i].redeemScript = addressObject.redeem.output;
                }
            }
            return inputs;
        });
    }
    createUnsignedTransaction({ inputs, outputs, change, fee, feeRate, }) {
        const { network } = this;
        const newPsbt = new bitcoin.Psbt({ network });
        newPsbt.setMaximumFeeRate = feeRate + feeRate / 100;
        for (const input of inputs) {
            let { addressType } = input.signerInfo;
            switch (addressType) {
                case "p2pkh":
                    newPsbt.addInput({
                        hash: input.hash,
                        index: Number(input.index),
                        nonWitnessUtxo: input.nonWitnessUtxo,
                        sequence: 0xffffffff - 1,
                    });
                    break;
                case "p2wpkh":
                    newPsbt.addInput({
                        hash: input.hash,
                        index: Number(input.index),
                        witnessUtxo: input.witnessUtxo,
                        sequence: 0xffffffff - 1,
                    });
                    break;
                case "p2sh-p2wpkh":
                    newPsbt.addInput({
                        hash: input.hash,
                        index: Number(input.index),
                        witnessUtxo: input.witnessUtxo,
                        redeemScript: input.redeemScript,
                        sequence: 0xffffffff - 1,
                    });
                    break;
                default:
                    throw new Error("address type is incorrect");
            }
        }
        for (const target of outputs) {
            newPsbt.addOutput(target);
        }
        if (change && Object.keys(change).length !== 0) {
            newPsbt.addOutput({
                address: change.address,
                value: Number(change.value),
            });
        }
        for (let i in outputs) {
            if (newPsbt.txOutputs[i].address !== outputs[i].address) {
                throw new Error("error address");
            }
            if (newPsbt.txOutputs[i].value !== outputs[i].value) {
                throw new Error("error value");
            }
        }
        if (change && Object.keys(change).length !== 0) {
            if (newPsbt.txOutputs[outputs.length].address !== change.address) {
                throw new Error("error change address");
            }
            if (newPsbt.txOutputs[outputs.length].value !== change.value) {
                throw new Error("error change value");
            }
        }
        const unsignedPsbtBaseText = newPsbt.toBase64();
        return {
            unsignedTransaction: unsignedPsbtBaseText,
            outputs,
            inputs: inputs.map((tx) => ({
                hash: tx.hash,
                value: Number(tx.value),
                index: tx.index,
                signerInfo: tx.signerInfo,
            })),
            fee,
            change,
        };
    }
}
module.exports = BaseBitcoinLikeTransaction;
//# sourceMappingURL=transaction-builder.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { getRpcProvider, getApiProvider } = require('@sinatdt/providers').bitcoin;
const { runWithRetries, sleep } = require('./utils/tools');
const networks = require('./utils/networks');
const { parseRawTransaction, createAddressObjectByHash, createAddressObjectByAddress, createAddressObjectByPublicKey, calculateMerkleProof, parseBlockHeader, extractTransactionsAndBlockInfoFromRawBlock, } = require('./bitcoin-utils');
const { checkAndParseRequest } = require('./helper/teleport-request-helper');
const { getBurnTransactionInfo } = require('./helper/burn-request-helper');
class BitcoinInterface {
    constructor(connectionInfo, networkName) {
        var _a;
        this.testnet = networkName.includes('_testnet');
        if ((_a = connectionInfo.rpc) === null || _a === void 0 ? void 0 : _a.enabled) {
            this.rpcProvider = getRpcProvider(connectionInfo.rpc);
        }
        if (connectionInfo.api.enabled) {
            this.apiProviderName = connectionInfo.api.provider;
            this.apiProvider = getApiProvider(connectionInfo.api, networkName);
        }
        this.provider = this.rpcProvider || this.apiProvider;
        this.network = networks[networkName];
    }
    getLatestBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            let latestHeight = yield this.provider.getLatestBlockNumber();
            return latestHeight;
        });
    }
    getBlockHash(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let headerHash = yield runWithRetries(() => this.provider.getBlockHash(blockNumber));
            return headerHash;
        });
    }
    getBlockHeaderHex(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let headerHex = yield runWithRetries(() => this.provider.getBlockHeaderHex(blockNumber));
            return headerHex;
        });
    }
    getTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.provider.getTransaction(txId);
        });
    }
    getFeeRate(speed = 'normal') {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(speed === 'normal' || speed === 'slow' || speed === 'fast')) {
                throw new Error('incorrect speed');
            }
            let fee = yield this.provider.getFeeRate(speed);
            return fee;
        });
    }
    getBlockTransactions(addresses, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let utxos = yield this.getAddressesUtxo(addresses);
            let rawBlockHex = yield this.rpcProvider.getBlockByBlockNumber(blockNumber, 0);
            let { withdrawTxs, depositTxs } = extractTransactionsAndBlockInfoFromRawBlock(rawBlockHex, blockNumber, addresses, utxos, this.network);
            return depositTxs.concat(withdrawTxs);
        });
    }
    getMultipleBlocksTransactions(addresses, startBlockNumber, endBlockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            if (endBlockNumber - startBlockNumber > 20) {
                throw new Error('cant get more than 20 block per function call');
            }
            let blockTxs = [];
            for (let blockNumber = +startBlockNumber + 1; blockNumber <= endBlockNumber; blockNumber += 1) {
                const response = this.getBlockTransactions(addresses, blockNumber);
                blockTxs.push(response);
                yield sleep(200);
            }
            blockTxs = yield Promise.all(blockTxs);
            return blockTxs.flat(1);
        });
    }
    getTransactionHistory(addresses, startBlockNumber, endBlockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rpcProvider) {
                let endBlock = endBlockNumber || (yield this.getLatestBlockNumber());
                let startBlock = Math.max(+startBlockNumber, +endBlock - 20);
                console.log('startBlock , endBlock ', startBlock, endBlock);
                return this.getMultipleBlocksTransactions(addresses, startBlock, endBlock);
            }
            if (this.apiProviderName !== 'BlockStream') {
                throw new Error('teleporter just support BlockStream as api provider');
            }
            let txs = yield this.apiProvider.getTransactionHistoryForMultipleAddresses(addresses, startBlockNumber);
            return txs.flat(1);
        });
    }
    getMempoolTransactionHistory(addresses) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiProviderName !== 'BlockStream') {
                throw new Error('teleporter just support BlockStream as api provider');
            }
            let txs = yield this.apiProvider.getMempoolTransactionHistoryForMultipleAddresses(addresses);
            return txs.flat(1);
        });
    }
    getAddressesUtxo(addresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const allPromises = [];
            for (let address of addresses) {
                let promise = yield this.apiProvider.getUtxos(address);
                allPromises.push(promise);
            }
            let result = yield Promise.all(allPromises);
            return result.flat(1);
        });
    }
    getHexBlockHeaders(startBlockNumber, endBlockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockHeaders = [];
            let difficulty = null;
            let hexBlockHeaders = '';
            let fromBlockNumber = startBlockNumber;
            for (let blockNumber = startBlockNumber; blockNumber <= endBlockNumber; blockNumber += 1) {
                let blockHeader = yield this.getBlockHeaderHex(blockNumber);
                console.log('block', blockNumber);
                let parsedBlockHeader = parseBlockHeader(blockHeader);
                if (difficulty && parsedBlockHeader.difficulty !== difficulty) {
                    blockHeaders.push({
                        hexBlockHeaders,
                        fromBlockNumber,
                        toBlockNumber: blockNumber - 1,
                        difficulty,
                    });
                    hexBlockHeaders = blockHeader;
                    fromBlockNumber = blockNumber;
                }
                else {
                    hexBlockHeaders += blockHeader;
                }
                difficulty = parsedBlockHeader.difficulty;
            }
            if (hexBlockHeaders) {
                blockHeaders.push({
                    hexBlockHeaders,
                    fromBlockNumber,
                    toBlockNumber: endBlockNumber,
                    difficulty,
                });
            }
            return blockHeaders;
        });
    }
    getTeleporterRequests(addresses, startblockNumber, endBlockNumber, mempool = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactions = mempool
                ? yield this.getMempoolTransactionHistory(addresses)
                : yield this.getTransactionHistory(addresses, startblockNumber, endBlockNumber);
            let requests = [];
            for (let transaction of transactions) {
                let address = transaction.address;
                console.log(`received tx to add for teleport: ${transaction.txId}`);
                let request = checkAndParseRequest(transaction.vout, address);
                if (request) {
                    requests.push({
                        transaction,
                        request,
                        lockerAddress: address,
                        lockerLockingScript: transaction.addressScript ||
                            this.convertAddressToScript(address).script.toString('hex'),
                    });
                }
            }
            return requests;
        });
    }
    getLockersBurnTransactions(addresses, startBlockNumber, endBlockNumber, mempool = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactions = mempool
                ? yield this.getMempoolTransactionHistory(addresses)
                : yield this.getTransactionHistory(addresses, startBlockNumber, endBlockNumber);
            let validTxs = [];
            for (let transaction of transactions) {
                let address = transaction.address;
                console.log(`received tx to check burn: ${transaction.txId}`);
                let burnInfo = getBurnTransactionInfo(address, transaction.vin, transaction.vout);
                if (burnInfo) {
                    validTxs.push({
                        transaction,
                        burnInfo,
                        lockerAddress: address,
                        lockerLockingScript: transaction.addressScript ||
                            this.convertAddressToScript(address).script.toString('hex'),
                    });
                }
            }
            return validTxs;
        });
    }
    getRequestProof(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactionHex = transaction.hex || (yield this.provider.getRawTransaction(transaction.txId));
            let txInfo;
            if (!(transaction.blockHash && transaction.blockNumber)) {
                txInfo = yield this.provider.getTransaction(transaction.txId);
            }
            let blockHash = transaction.blockHash || txInfo.blockHash;
            let blockNumber = transaction.blockNumber || txInfo.blockNumber;
            let parsedTx = parseRawTransaction(transactionHex);
            let merkleProof = transaction.merkleProof || (yield this.getMerkleProof(transaction.txId, blockHash));
            return {
                parsedTx,
                merkleProof,
                blockNumber,
                blockHash,
            };
        });
    }
    getMerkleProof(txId, blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let txIds = yield this.provider.getBlockTransactionIds(blockHash);
            let proof = calculateMerkleProof(txIds, txId);
            return proof;
        });
    }
    convertHashToAddress(hashHex, addressType) {
        let addressObj = createAddressObjectByHash({ addressType, hash: Buffer.from(hashHex, 'hex') }, this.network);
        return addressObj.address;
    }
    convertAddressToScript(address) {
        let { addressObject, addressType } = createAddressObjectByAddress(address, this.network);
        return {
            script: addressObject.output,
            hash: addressObject.output,
            addressType,
        };
    }
    convertAddressToObject(address) {
        let addObj = createAddressObjectByAddress(address, this.network);
        return addObj;
    }
    createAddressObjectByPublicKey(address, addressType) {
        let addObj = createAddressObjectByPublicKey({ address, addressType }, this.network);
        return addObj;
    }
    getBalance(address) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let utxos = (_a = (yield this.apiProvider.getUtxos(address))) !== null && _a !== void 0 ? _a : [];
            return utxos.reduce((a, tx) => a + Number(tx.value), 0);
        });
    }
}
module.exports = BitcoinInterface;
//# sourceMappingURL=bitcoin-interface.js.map
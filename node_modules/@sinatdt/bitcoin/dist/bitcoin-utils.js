"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// let { ECPairFactory } = require("ecpair");
// let ecc = require("tiny-secp256k1");
let varUnit = require("varuint-bitcoin");
const fastRoot = require("merkle-lib/fastRoot");
const merkle = require("merkle-lib");
const merkleProof = require("merkle-lib/proof");
const bitcoin = require("bitcoinjs-lib");
const networks = require("./utils/networks");
function parseRawTransaction(rawTransaction) {
    const size = {
        version: 4,
        flag: 2,
        tx: 32,
        index: 4,
        sequence: 4,
        amount: 8,
    };
    let offset = 0;
    let version = rawTransaction.slice(offset, size.version * 2);
    offset += size.version * 2;
    let flag = rawTransaction.slice(offset, offset + size.flag * 2);
    offset = flag === "0001" ? offset + size.flag * 2 : offset;
    let inputsStartIndex = offset;
    let numberOfInputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
    let noiSize = varUnit.encodingLength(numberOfInputs);
    offset += noiSize * 2;
    for (let i = 0; i < numberOfInputs; i += 1) {
        offset += size.tx * 2;
        offset += size.index * 2;
        let sigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
        let sigLengthSize = varUnit.encodingLength(sigLength);
        offset += sigLengthSize * 2;
        offset += sigLength * 2;
        offset += size.sequence * 2;
    }
    let inputLastIndex = offset;
    let outputStartIndex = offset;
    let numberOfOutputs = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
    let nooSize = varUnit.encodingLength(numberOfOutputs);
    offset += nooSize * 2;
    for (let i = 0; i < numberOfOutputs; i += 1) {
        offset += size.amount * 2;
        let unlockSigLength = varUnit.decode(Buffer.from(rawTransaction.slice(offset), "hex"));
        let unlockSigLengthSize = varUnit.encodingLength(unlockSigLength);
        offset += unlockSigLengthSize * 2;
        offset += unlockSigLength * 2;
    }
    let outputLastIndex = offset;
    version = `0x${version}`;
    flag = `0x${flag}`;
    const vin = `0x${rawTransaction.slice(inputsStartIndex, inputLastIndex)}`;
    const vout = `0x${rawTransaction.slice(outputStartIndex, outputLastIndex)}`;
    let witness = `0x${rawTransaction.slice(outputLastIndex, rawTransaction.length - 8)}`;
    let locktime = `0x${rawTransaction.slice(rawTransaction.length - 8, rawTransaction.length)}`;
    return { version, flag, vin, vout, witness, locktime };
}
function reverseBytes(hexInput) {
    return Buffer.from(hexInput, "hex").reverse().toString("hex");
}
function getAddressType(address, network) {
    if (address.startsWith(network.bech32)) {
        return "p2wpkh";
    }
    let base58Data = bitcoin.address.fromBase58Check(address);
    if (base58Data.version === Number(network.scriptHash)) {
        return "p2sh";
    }
    if (base58Data.version === Number(network.pubKeyHash)) {
        return "p2pkh";
    }
    throw new Error("invalid address");
}
function createAddressObjectByHash({ addressType, hash }, network) {
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                hash,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                hash,
                network,
            });
            break;
        case "p2sh":
            addressObject = bitcoin.payments.p2sh({
                hash,
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return addressObject;
}
function createAddressObjectByScript({ addressType, script }, network) {
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                output: script,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                output: script,
                network,
            });
            break;
        case "p2sh":
            addressObject = bitcoin.payments.p2sh({
                output: script,
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return addressObject;
}
function createAddressObjectByPublicKey({ addressType, publicKey }, network) {
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                pubkey: publicKey,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                pubkey: publicKey,
                network,
            });
            break;
        case "p2sh-p2wpkh":
            addressObject = bitcoin.payments.p2sh({
                redeem: bitcoin.payments.p2wpkh({
                    pubkey: publicKey,
                    network,
                }),
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return addressObject;
}
function createAddressObjectByAddress(address, network) {
    let addressType = getAddressType(address, network);
    let addressObject;
    switch (addressType) {
        case "p2pkh":
            addressObject = bitcoin.payments.p2pkh({
                address,
                network,
            });
            break;
        case "p2wpkh":
            addressObject = bitcoin.payments.p2wpkh({
                address,
                network,
            });
            break;
        case "p2sh":
            addressObject = bitcoin.payments.p2sh({
                address,
                network,
            });
            break;
        default:
            throw new Error("address type is incorrect");
    }
    return { addressObject, addressType };
}
function deriveAddressFromPubKey(pubKey, network) {
    return __awaiter(this, void 0, void 0, function* () {
        let { address } = this.bitcoinJS.payments.p2pkh({
            network,
            pubkey: Buffer.from(pubKey, "hex"),
        });
        return address;
    });
}
function deriveAddressFromBufferPubKey(pubKey, network) {
    return __awaiter(this, void 0, void 0, function* () {
        let { address } = this.bitcoinJS.payments.p2pkh({ network, pubkey: pubKey });
        return address;
    });
}
function getPubKeyFromPrivateKey(privateKey, network) {
    // return __awaiter(this, void 0, void 0, function* () {
    //     let ECPair = ECPairFactory(ecc);
    //     let key = ECPair.fromWIF(privateKey, network);
    //     return key.publicKey;
    // });
}
function calculateMerkleProof(blockTransactions, txId, blockMerkleRoot = null) {
    let transactionIndex = blockTransactions.findIndex((tx) => tx === txId);
    if (transactionIndex < 0)
        throw new Error("txId is not in this tree");
    let data = blockTransactions.map((a) => Buffer.from(a, "hex").reverse());
    if (blockMerkleRoot &&
        blockMerkleRoot !== fastRoot(data, bitcoin.crypto.hash256).toString("hex")) {
        throw new Error("calculated anf block merkleRoot not matched");
    }
    let tree = merkle(data, bitcoin.crypto.hash256);
    let proof = merkleProof(tree, data[transactionIndex]);
    let intermediateNodesArray = proof
        .map((_id) => _id && _id.toString("hex"))
        .filter((_id) => _id != null);
    let intermediateNodes = intermediateNodesArray.reduce((a, value, index) => index !== transactionIndex % 2 && index < intermediateNodesArray.length - 1 ? a + value : a, "0x");
    return {
        intermediateNodes,
        transactionIndex,
    };
}
function parseBlockHeader(headerHex) {
    const size = {
        version: 4,
        previousBlockHash: 32,
        merkleRoot: 32,
        timestamp: 4,
        difficulty: 4,
        nonce: 4,
    };
    let offset = 0;
    let result = {};
    for (let key in size) {
        result[key] = headerHex.slice(offset, offset + size[key] * 2);
        offset += size[key] * 2;
    }
    return result;
}
function convertBitcoinScriptToAddress(script, network) {
    var _a;
    try {
        return (_a = bitcoin.address) === null || _a === void 0 ? void 0 : _a.fromOutputScript(script, network);
    }
    catch (error) {
        return null;
    }
}
function parseRawBlock(rawBlockHex, blockNumber = null, network = bitcoin.networks.network) {
    let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"));
    let blockHash = block.getHash().toString("hex");
    let merkleRoot = block.merkleRoot.toString("hex");
    let prvBlockHash = block.prevHash.toString("hex");
    return {
        blockNumber,
        merkleRoot,
        prvBlockHash,
        transactions: block.transactions.map((tx) => ({
            txId: tx.getId(),
            version: tx.version,
            locktime: tx.locktime,
            blockNumber,
            blockHash,
            vout: tx.outs.map((vo) => ({
                address: convertBitcoinScriptToAddress(vo.script, network),
                script: vo.script.toString("hex"),
                value: vo.value,
            })),
            vin: tx.ins.map((vi) => ({
                txId: vi.hash.reverse().toString("hex"),
                index: vi.index,
            })),
        })),
    };
}
function extractTransactionsAndBlockInfoFromRawBlock(rawBlockHex, blockNumber, addresses = [], inputs = [], network = bitcoin.networks.bitcoin) {
    let block = bitcoin.Block.fromBuffer(Buffer.from(rawBlockHex, "hex"));
    let blockHash = block.getHash().reverse().toString("hex");
    let merkleRoot = block.merkleRoot.toString("hex");
    let prvBlockHash = block.prevHash.toString("hex");
    let blockInfo = {
        blockNumber,
        blockHash,
        merkleRoot,
        prvBlockHash,
    };
    let addressScript = addresses.map((address) => createAddressObjectByAddress(address, network).addressObject.output.toString("hex"));
    let blockTxIds = block.transactions.map((tx) => tx.getId());
    let withdrawTxs = [];
    let depositTxs = [];
    block.transactions.forEach((tx) => {
        let txId = tx.getId();
        let transactionAddressIndex;
        let txVinInput = inputs.find((vin) => vin.txId === txId);
        if (txVinInput) {
            let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot);
            withdrawTxs.push({
                txId: tx.getId(),
                version: tx.version,
                locktime: tx.locktime,
                blockNumber,
                blockHash,
                merkleProof: txMerkleProof,
                vout: tx.outs.map((vo) => ({
                    address: convertBitcoinScriptToAddress(vo.script, network),
                    script: vo.script.toString("hex"),
                    value: vo.value,
                })),
                vin: tx.ins.map((vi) => {
                    let viInput = inputs.find((vin) => vin.txId === txId);
                    return {
                        txId: vi.hash.reverse().toString("hex"),
                        index: vi.index,
                        address: viInput.address || null,
                        script: viInput.script || null,
                        value: viInput.value || null,
                    };
                }),
                address: txVinInput.address,
                addressScript: createAddressObjectByAddress(txVinInput.address, network).addressObject.output.toString("hex"),
            });
        }
        else if (tx.outs.findIndex((blockTxVo) => {
            let sIndex = addressScript.findIndex((addScript) => addScript === blockTxVo.script.toString("hex"));
            if (sIndex >= 0) {
                transactionAddressIndex = sIndex;
                return true;
            }
            return false;
        }) >= 0) {
            let txMerkleProof = calculateMerkleProof(blockTxIds, txId, merkleRoot);
            depositTxs.push({
                txId: tx.getId(),
                version: tx.version,
                locktime: tx.locktime,
                blockNumber,
                blockHash,
                merkleProof: txMerkleProof,
                vout: tx.outs.map((vo) => ({
                    address: convertBitcoinScriptToAddress(vo.script, network),
                    script: vo.script.toString("hex"),
                    value: vo.value,
                })),
                vin: tx.ins.map((vi) => ({
                    txId: vi.hash.reverse().toString("hex"),
                    index: vi.index,
                })),
                addressScript: addressScript[transactionAddressIndex],
                address: addresses[transactionAddressIndex],
            });
        }
    });
    return {
        blockInfo,
        withdrawTxs,
        depositTxs,
    };
}
module.exports = {
    parseRawTransaction,
    calculateMerkleProof,
    createAddressObjectByHash,
    createAddressObjectByPublicKey,
    createAddressObjectByAddress,
    createAddressObjectByScript,
    getAddressType,
    deriveAddressFromPubKey,
    deriveAddressFromBufferPubKey,
    getPubKeyFromPrivateKey,
    reverseBytes,
    parseBlockHeader,
    parseRawBlock,
    extractTransactionsAndBlockInfoFromRawBlock,
    networks,
};
//# sourceMappingURL=bitcoin-utils.js.map
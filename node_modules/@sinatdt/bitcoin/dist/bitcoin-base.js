"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const bip39 = require("bip39");
const bip32 = require("bip32");
const hdWalletNetworksPath = require("@sinatdt/configs").hdWalletPath;
const networks = require("./utils/networks");
const TransactionBuilder = require("./transaction-builder/bitcoin-transaction-builder");
const BitcoinSign = require("./sign/sign-transaction");
class BitcoinBase {
    constructor(connectionInfo = {
        api: {
            enabled: true,
            provider: "BlockStream",
        },
    }, networkName) {
        this.network = networks[networkName];
        this.hdWalletPath = hdWalletNetworksPath[networkName.replace("_testnet", "")];
        this.transactionBuilder = new TransactionBuilder(connectionInfo, networkName, this.network);
        this.btcInterface = this.transactionBuilder.btcInterface;
        this.signer = new BitcoinSign(this.network);
        this.currentAccount = null;
        this.currentAccountType = null;
        this.privateKey = null;
        this.publicKey = null;
        this.publicKeys = [];
    }
    setMultiSigAccount(accountType = "p2sh") {
        switch (accountType) {
            default:
                throw new Error("accountType is incorrect");
        }
        this.currentAccountType = accountType;
    }
    setAccountPrivateKey(privateKeyHex) {
        this.privateKey = Buffer.from(privateKeyHex, "hex");
    }
    setAccountPublicKey(publicKeyHex) {
        this.publicKey = Buffer.from(publicKeyHex, "hex");
    }
    setAccountPrivateKeyByMnemonic({ mnemonic, mnemonicPassword = "", index = 0, walletNumber = 0, addressType = "p2sh-p2wpkh", }) {
        if (!bip39.validateMnemonic(mnemonic))
            throw new Error("invalid mnemonic");
        const seed = bip39.mnemonicToSeedSync(mnemonic, mnemonicPassword);
        const node = bip32.fromSeed(seed);
        if (!this.hdWalletPath[addressType])
            throw new Error("incorrect path or addressType");
        const path = `${this.hdWalletPath[addressType]}/${walletNumber}`;
        const account = node.derivePath(path);
        const userKeyPair = account.derive(index);
        this.setAccountPrivateKey(userKeyPair.privateKey.toString("hex"));
        this.setAccountPublicKey(userKeyPair.publicKey.toString("hex"));
    }
    setAccount(accountType = "p2pkh") {
        let addressObj = this.transactionBuilder.createAddressObject({
            addressType: accountType,
            publicKey: this.publicKey,
        });
        this.currentAccount = addressObj.address;
        this.currentAccountType = accountType;
        this.addressObj = addressObj;
        return addressObj.address;
    }
    getExtendedUtxo({ address, addressType, publicKey, derivationPath }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transactionBuilder.getExtendedUtxo({
                address,
                addressType,
                publicKey,
                derivationPath,
            });
        });
    }
    static checkBalanceIsSufficient({ targets, extendedUtxo, changeAddress, feeRate, fullAmount = false, }) {
        try {
            TransactionBuilder.helperHandleInputsAndOutputs({
                targets,
                extendedUtxo,
                changeAddress,
                feeRate,
                fullAmount,
            });
            return true;
        }
        catch (err) {
            return false;
        }
    }
    send({ receiverAddress, amount, fullAmount = false, speed = "normal" }) {
        return __awaiter(this, void 0, void 0, function* () {
            let extendedUtxo = yield this.getExtendedUtxo({
                address: this.currentAccount,
                addressType: this.currentAccountType,
                publicKey: this.publicKey.toString("hex"),
            });
            let feeRate = this.transactionBuilder._getFeeRate(speed);
            let unsignedTx = yield this.transactionBuilder.processUnsignedTransaction({
                extendedUtxo,
                targets: [
                    {
                        address: receiverAddress,
                        value: amount,
                    },
                ],
                changeAddress: this.currentAccount,
                feeRate,
                fullAmount,
            });
            let signedPsbt = yield this.signer.signPsbt(unsignedTx, this.privateKey);
            let signedTx = this.signer.finalizePsbts([signedPsbt]);
            let txId = yield this.transactionBuilder.sendTx(signedTx);
            return txId;
        });
    }
    sendSignedPsbt(signedPsbt) {
        return __awaiter(this, void 0, void 0, function* () {
            let signedTx = this.signer.finalizePsbts([signedPsbt]);
            let txId = yield this.transactionBuilder.sendTx(signedTx);
            return txId;
        });
    }
    sendMultiSignedPsbt(signedPsbts = []) {
        return __awaiter(this, void 0, void 0, function* () {
            let signedTx = this.signer.finalizePsbts(signedPsbts);
            let txId = yield this.transactionBuilder.sendTx(signedTx);
            return txId;
        });
    }
}
module.exports = BitcoinBase;
//# sourceMappingURL=bitcoin-base.js.map
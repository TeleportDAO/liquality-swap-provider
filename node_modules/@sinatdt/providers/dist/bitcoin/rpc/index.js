"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { getAxiosInstance } = require('../../utils/tools');
class BaseBitcoinLikeRpc {
    constructor({ headers, url: baseUrl, auth }) {
        this.axios = BaseBitcoinLikeRpc.getAxiosInstance({
            baseUrl,
            headers,
            auth,
            timeout: 3 * 60000,
        });
    }
    static getAxiosInstance(provider) {
        return getAxiosInstance(provider);
    }
    static getRpcBody(method, params = []) {
        return {
            jsonrpc: '2.0',
            id: 'teleport-dao',
            method,
            params,
        };
    }
    getChainInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getblockchaininfo'));
            return response.data.result;
        });
    }
    getLatestBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getblockcount'));
            return response.data.result;
        });
    }
    getBlockHash(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getblockhash', [Number(blockNumber)]));
            return response.data.result;
        });
    }
    getBlockByBlockHash(blockHash, verbosity = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getblock', [blockHash, Number(verbosity)]));
            return response.data.result;
        });
    }
    getBlockHeaderByBlockHash(blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getblockheader', [blockHash, false]));
            return response.data.result;
        });
    }
    getBlockByBlockNumber(blockNumber, verbosity) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getBlockByBlockHash(yield this.getBlockHash(blockNumber), verbosity);
        });
    }
    getTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getrawtransaction', [txId, true]));
            let tx = response.data.result;
            let block = yield this.getBlockByBlockHash(tx.blockhash);
            return {
                txId: tx.txid,
                version: tx.version,
                locktime: tx.locktime,
                blockNumber: block.height || null,
                blockHash: tx.blockhash || null,
                vout: tx.vout.map((vo) => ({
                    address: vo.scriptPubKey.address || null,
                    script: vo.scriptPubKey.hex,
                    value: Number((Number(vo.value) * 1e8).toFixed()),
                })),
            };
        });
    }
    getRawTransaction(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('getrawtransaction', [txId, true]));
            return response.data.result.hex;
        });
    }
    getTxOutProof(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('gettxoutproof', [txId, true]));
            return response.data.result.hex;
        });
    }
    getBlockTransactionIds(blockHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let block = yield this.getBlockByBlockHash(blockHash);
            return block.tx;
        });
    }
    sendRawTransaction(txHex, maxFeeRate = 0.1) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('sendrawtransaction', [txHex, maxFeeRate]));
            return response.data.result;
        });
    }
    getBlockHeaderHex(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = yield this.getBlockHash(blockNumber);
            const result = yield this.getBlockHeaderByBlockHash(hash);
            return result;
        });
    }
    getEstimateFeeByNumberOfBlock(n) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.axios.post('/', BaseBitcoinLikeRpc.getRpcBody('estimatesmartfee', [n]));
            return response.data.result.feerate * 10 ** 5;
        });
    }
    getFeeRate(speed = 'normal') {
        return __awaiter(this, void 0, void 0, function* () {
            let fee;
            switch (speed) {
                case 'slow':
                    fee = this.getEstimateFeeByNumberOfBlock(6);
                    break;
                case 'fast':
                    fee = this.getEstimateFeeByNumberOfBlock(1);
                    break;
                case 'normal':
                default:
                    fee = this.getEstimateFeeByNumberOfBlock(3);
                    break;
            }
            return fee.toFixed(2);
        });
    }
}
module.exports = BaseBitcoinLikeRpc;
//# sourceMappingURL=index.js.map
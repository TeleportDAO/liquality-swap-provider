const { getAxiosInstance } = require('../../utils/tools')

class BlockStreamProvider {
  constructor({ timeout = 30_000 }, testnet = false) {
    const mainnetUrl = 'https://blockstream.info/api'
    const testnetUrl = 'https://blockstream.info/testnet/api'
    this.baseURL = testnet ? testnetUrl : mainnetUrl
    this.axios = getAxiosInstance({
      baseUrl: this.baseURL,
      timeout,
    })
  }

  async getLatestBlockNumber() {
    const result = await this.axios.get(`/blocks/tip/height`)
    return result.data
  }

  async getBlockHash(blockNumber) {
    const result = await this.axios.get(`/block-height/${blockNumber}`)
    return result.data
  }

  async getBlockHeaderHex(blockNumber) {
    const hash = await this.getBlockHash(blockNumber)
    const result = await this.axios.get(`/block/${hash}/header`)
    return result.data
  }

  // --------------

  async getConfirmedTransactions(userAddress, lastReceivedTxId = '') {
    const result = await this.axios.get(`/address/${userAddress}/txs/chain/${lastReceivedTxId}`)
    return result.data
  }

  async getMempoolTransactions(userAddress) {
    const result = await this.axios.get(`/address/${userAddress}/txs/mempool`)
    return result.data
  }

  async getTransaction(txId) {
    const result = await this.axios.get(`/tx/${txId}`)
    let tx = result.data
    return {
      txId: tx.txid,
      version: tx.version,
      locktime: tx.locktime,
      blockTime: tx.status.block_time,
      blockNumber: tx.status.block_height || null,
      blockHash: tx.status.block_hash || null,
      vout: tx.vout.map((vo) => ({
        address: vo.scriptpubkey_address || null,
        script: vo.scriptpubkey,
        value: vo.value,
      })),
    }
  }

  async getRawTransaction(txId) {
    const result = await this.axios.get(`/tx/${txId}/hex`)
    return result.data
  }

  async getTransactionHistory(userAddress, blockNumber = 0, lastSeenTxId = null) {
    let maximumTxsLength = 15
    // get transactions from lastSeenTxId to the end
    let fetchTxs = true
    let allResults = []
    let lastReceivedTxId = ''
    while (fetchTxs) {
      let result = await this.getConfirmedTransactions(userAddress, lastReceivedTxId)
      let lastSeenTxIdIndex = result.findIndex((tx) => tx.txId === lastSeenTxId)
      result = result.filter((_value) => +_value.status.block_height > blockNumber)
      result =
        lastSeenTxIdIndex < 0 ? result : result.filter((_value, index) => index < lastSeenTxIdIndex)
      allResults.push(...result)
      lastReceivedTxId = result[result.length - 1]?.txid
      fetchTxs = result.length === maximumTxsLength && lastSeenTxIdIndex < 0 && result.length !== 0
    }

    return allResults.map((tx) => ({
      address: userAddress,
      txId: tx.txid,
      version: tx.version,
      locktime: tx.locktime,
      blockNumber: tx.status.block_height || null,
      blockHash: tx.status.block_hash || null,
      vout: tx.vout.map((vo) => ({
        address: vo.scriptpubkey_address || null,
        script: vo.scriptpubkey,
        value: vo.value,
      })),
      vin: tx.vin.map((vi) => ({
        txId: vi.txid,
        index: vi.vout,
        address: vi.prevout.scriptpubkey_address || null,
        script: vi.prevout.scriptpubkey,
        value: vi.prevout.value,
      })),
    }))
  }

  async getMempoolTransactionHistory(userAddress) {
    let result = await this.getMempoolTransactions(userAddress)
    return result.map((tx) => ({
      address: userAddress,
      txId: tx.txid,
      version: tx.version,
      locktime: tx.locktime,
      vout: tx.vout.map((vo) => ({
        address: vo.scriptpubkey_address || null,
        script: vo.scriptpubkey,
        value: vo.value,
      })),
      vin: tx.vin.map((vi) => ({
        txId: vi.txid,
        index: vi.vout,
        address: vi.prevout.scriptpubkey_address || null,
        script: vi.prevout.scriptpubkey,
        value: vi.prevout.value,
      })),
    }))
  }

  async getMempoolTransactionHistoryForMultipleAddresses(userAddresses, blockNumber = 0) {
    const allPromises = []
    for (let address of userAddresses) {
      let promise = await this.getMempoolTransactionHistory(address, blockNumber)
      allPromises.push(promise)
    }
    let result = await Promise.all(allPromises)
    return result
  }

  async getTransactionHistoryForMultipleAddresses(userAddresses, blockNumber = 0) {
    const allPromises = []
    for (let address of userAddresses) {
      let promise = await this.getTransactionHistory(address, blockNumber)
      allPromises.push(promise)
    }
    let result = await Promise.all(allPromises)
    return result
  }

  async getUtxos(userAddress) {
    const result = await this.axios.get(`/address/${userAddress}/utxo`)
    return result.data.map((tx) => ({
      address: userAddress,
      txId: tx.txid,
      index: tx.vout,
      value: tx.value,
      blockNumber: tx.status?.block_height || null,
    }))
  }

  async getBalance(address) {
    let utxos = this.getUtxos(address)
    return utxos.reduce((a, tx) => a + Number(tx.value), 0)
  }

  async getBlockTransactionIds(blockHash) {
    let result = await this.axios.get(`/block/${blockHash}/txids`)
    return result.data
  }

  async getFeeRate(speed = 'normal') {
    let result = await this.axios.get(`/fee-estimates`)
    let fees = {
      slow: +result.data[6],
      normal: +result.data[3],
      fast: +result.data[1],
    }
    return fees[speed] || fees.normal
  }

  async sendRawTransaction(rawTransaction) {
    const result = await this.axios.post(`/tx`, rawTransaction)
    return result.data
  }

  // not used

  async getMerkleProof(txId) {
    let result = await this.axios.get(`/tx/${txId}/merkle-proof`)
    result = result.data
    let intermediateNodes = result.merkle.reduce(
      (a, merkle) => a + Buffer.from(merkle, 'hex').reverse().toString('hex'),
      '0x',
    )
    let transactionIndex = result.pos
    return {
      intermediateNodes,
      transactionIndex,
    }
  }

  async getLatestBlock() {
    const result = await this.axios.get(`/blocks`)
    // 10 newest blocks
    const blocks = result.data
    return blocks[0]
  }

  async getBlock(blockNumber) {
    const blockHash = await this.getBlockHash(blockNumber)
    const result = await this.axios.get(`/block/${blockHash}`)
    return result.data
  }
}

module.exports = BlockStreamProvider

// new BlockStreamProvider({}, true).getFeeRate().then((x) => console.log(x))

const EthereumBase = require("../ethereum-base");
const { LockersLogicABI } = require("@sinatdt/configs").teleswap.ABI;
const { addressTypesNumber, addressTypes } =
  require("@sinatdt/configs").teleswap.bitcoinAddressTypes;

class LockerContract extends EthereumBase {
  constructor(connectionInfo, contractAddress) {
    super(connectionInfo);
    this.contractAddress = contractAddress;
    this.contract = new this.web3Eth.Contract(
      LockersLogicABI,
      this.contractAddress
    );
  }

  async isLocker(lockingScript) {
    return this.contract.methods.isLocker(lockingScript).call();
  }

  async getLockerTargetAddress(lockingScript) {
    return this.contract.methods.getLockerTargetAddress(lockingScript).call();
  }

  async getLockerLockingScript(targetAddress) {
    return this.contract.methods.getLockerLockingScript(targetAddress).call();
  }

  async getLockerPercentageFee() {
    return this.contract.methods.lockerPercentageFee().call();
  }

  async isValidLocker(lockingScript, targetAddress) {
    let hexLockerScript = `0x${lockingScript.replace("0x", "")}`;
    let address = await this.getLockerTargetAddress(hexLockerScript);
    let isLocker = await this.isLocker(hexLockerScript);
    console.log("isLocker", isLocker);
    return isLocker && address === targetAddress;
  }

  async getLockerCapacity(targetAddress) {
    return this.contract.methods.getLockerCapacity(targetAddress).call();
  }

  async getLockerInfo(targetAddress) {
    const {
      lockerLockingScript,
      lockerRescueType,
      lockerRescueScript,
      TDTLockedAmount,
      nativeTokenLockedAmount,
      netMinted,
      slashingTeleBTCAmount,
      reservedNativeTokenForSlash,
      isLocker,
      isCandidate,
      isScriptHash,
      isActive,
    } = await this.contract.methods.lockersMapping(targetAddress).call();
    return {
      lockerLockingScript,
      lockerRescueType: addressTypes[+lockerRescueType],
      lockerRescueScript,
      TDTLockedAmount,
      nativeTokenLockedAmount,
      netMinted,
      slashingTeleBTCAmount,
      reservedNativeTokenForSlash,
      isLocker,
      isCandidate,
      isScriptHash,
      isActive,
    };
  }

  async requestToBecomeLocker({
    lockerLockingScript,
    lockedTDTAmount,
    lockedNativeTokenAmount,
    lockerRescueType,
    lockerRescueScript,
    nonce = undefined,
  }) {
    try {
      const gasAmount = await this.contract.methods
        .requestToBecomeLocker(
          lockerLockingScript,
          lockedTDTAmount,
          lockedNativeTokenAmount,
          addressTypesNumber[lockerRescueType],
          lockerRescueScript
        )
        .estimateGas({
          from: this.currentAccount,
          value: lockedNativeTokenAmount,
          nonce,
        });

      let response = await this.contract.methods
        .requestToBecomeLocker(
          lockerLockingScript,
          lockedTDTAmount,
          lockedNativeTokenAmount,
          addressTypesNumber[lockerRescueType],
          lockerRescueScript
        )
        .send({
          from: this.currentAccount,
          value: lockedNativeTokenAmount,
          gas: gasAmount,
          nonce,
        })
        .then((recipient) => ({
          success: recipient.status,
          txId: recipient.transactionHash,
        }));

      return response;
    } catch (error) {
      return {
        success: false,
        message: error.message,
      };
    }
  }

  async addCollateral({
    targetAddress = this.currentAccount,
    nativeTokenAmount,
    nonce = undefined,
  }) {
    try {
      const gasAmount = await this.contract.methods
        .addCollateral(targetAddress, nativeTokenAmount)
        .estimateGas({
          from: this.currentAccount,
          value: nativeTokenAmount,
          nonce,
        });

      let response = await this.contract.methods
        .addCollateral(targetAddress, nativeTokenAmount)
        .send({
          from: this.currentAccount,
          value: nativeTokenAmount,
          gas: gasAmount,
          nonce,
        })
        .then((recipient) => ({
          success: recipient.status,
          txId: recipient.transactionHash,
        }));

      return response;
    } catch (error) {
      return {
        success: false,
        message: error.message,
      };
    }
  }
}
module.exports = LockerContract;

/* eslint-disable class-methods-use-this */
const EthereumBase = require("../ethereum-base");
const { LendingRouterABI } = require("@sinatdt/configs").teleswap.ABI;

class LendingRouter extends EthereumBase {
  constructor(connectionInfo, contractAddress) {
    super(connectionInfo);
    this.contractAddress = contractAddress;
    this.contract = new this.web3Eth.Contract(
      LendingRouterABI,
      contractAddress
    );
    this.contract.handleRevert = true;
  }

  async isUsed(txId) {
    let txIdWith0x = `0x${Buffer.from(txId, "hex").reverse().toString("hex")}`;
    let isUsed = await this.contract.methods
      .CCLendingRequests(txIdWith0x)
      .call();
    return isUsed?.isUsed;
  }

  async sendLendingRequest(
    lockerScript,
    parsedTx,
    merkleProof,
    blockNumber,
    blockFee,
    nonce = undefined
  ) {
    try {
      let value = blockFee ? (+blockFee * 1.3).toFixed() : "100000000000000000";

      const gasAmount = await this.contract.methods
        .lending(
          parsedTx.version,
          parsedTx.vin,
          parsedTx.vout,
          parsedTx.locktime,
          blockNumber,
          merkleProof.intermediateNodes,
          merkleProof.transactionIndex,
          `0x${lockerScript}`
        )
        .estimateGas({ from: this.currentAccount, value, nonce });

      let response = await this.contract.methods
        .lending(
          parsedTx.version,
          parsedTx.vin,
          parsedTx.vout,
          parsedTx.locktime,
          blockNumber,
          merkleProof.intermediateNodes,
          merkleProof.transactionIndex,
          `0x${lockerScript}`
        )
        .send({ from: this.currentAccount, gas: gasAmount, value, nonce })
        .then((recipient) => ({
          success: recipient.status,
          txId: recipient.transactionHash,
        }));
      return response;
    } catch (error) {
      return {
        success: false,
        message: error.message,
      };
    }
  }
}
module.exports = LendingRouter;

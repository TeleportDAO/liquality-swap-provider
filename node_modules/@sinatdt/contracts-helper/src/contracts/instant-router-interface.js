const EthereumBase = require("../ethereum-base");
const { InstantRouterABI } = require("@sinatdt/configs").teleswap.ABI;

class InstantRouter extends EthereumBase {
  constructor(connectionInfo, contractAddress) {
    super(connectionInfo);
    this.contractAddress = contractAddress;
    this.contract = new this.web3Eth.Contract(
      InstantRouterABI,
      contractAddress
    );
  }

  async getInstantDebts(userAddress, lastBlock = 0) {
    let debts = [];
    let lastDebt = null;
    let i = 0;
    let debt;
    do {
      debt = await this.contract.methods
        .instantRequests(userAddress, i)
        .call()
        .catch((err) => {
          if (err.message !== "Returned error: execution reverted") throw err;
          return null;
        });

      if (debt && +debt.deadline <= lastBlock) {
        debts.push({
          user: debt.user,
          collateralPool: debt.collateralPool,
          collateralToken: debt.collateralToken,
          paybackAmount: debt.paybackAmount,
          lockedCollateralPoolTokenAmount: debt.lockedCollateralPoolTokenAmount,
          deadline: debt.deadline,
          index: i,
        });
      }
      lastDebt = debt;
      i += 1;
    } while (debt && +debt.deadline <= lastBlock);
    return { debts, lastDebt };
  }

  async getInstantTransferEvents(fromBlock = 0) {
    let events = await this.contract.getPastEvents("InstantTransfer", {
      fromBlock,
    });
    return events.map((event) =>
      InstantRouter.parseInstantTransferEvent(event)
    );
  }

  async getInstantExchangeEvents(fromBlock = 0) {
    let events = await this.contract.getPastEvents("InstantExchange", {
      fromBlock,
    });
    return events.map((event) =>
      InstantRouter.parseInstantExchangeEvent(event)
    );
  }

  async getUserInstantRequestsLength(userAddress) {
    return this.contract.methods.getUserRequestsLength(userAddress).call();
  }

  async slashUser(userAddress, index) {
    console.log("userAddress, index", userAddress, index);

    const gasAmount = await this.contract.methods
      .slashUser(userAddress, index)
      .estimateGas({ from: this.currentAccount });

    return this.contract.methods
      .slashUser(userAddress, index)
      .send({ from: this.currentAccount, gas: gasAmount });
  }

  static parseInstantTransferEvent(event) {
    const txInfo = this.extractEventTxInfo(event);
    const {
      user,
      receiver,
      loanAmount,
      instantFee,
      deadline,
      collateralToken,
      lockedCollateralPoolToken,
    } = event.returnValues;
    return {
      user,
      receiver,
      loanAmount,
      instantFee,
      deadline,
      collateralToken,
      lockedCollateralPoolToken,
      txInfo,
    };
  }

  static parseInstantExchangeEvent(event) {
    const txInfo = this.extractEventTxInfo(event);
    const {
      user,
      receiver,
      loanAmount,
      instantFee,
      amountOut,
      path,
      isFixed,
      deadline,
      collateralToken,
      lockedCollateralPoolToken,
    } = event.returnValues;
    return {
      user,
      receiver,
      loanAmount,
      instantFee,
      amountOut,
      path,
      isFixed,
      deadline,
      collateralToken,
      lockedCollateralPoolToken,
      txInfo,
    };
  }
}
module.exports = InstantRouter;

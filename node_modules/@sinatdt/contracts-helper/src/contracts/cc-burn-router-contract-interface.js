const { CCBurnRouterABI } = require("@sinatdt/configs").teleswap.ABI
const { addressTypes } = require("@sinatdt/configs").teleswap.bitcoinAddressTypes
const { bitcoinUtils } = require("@sinatdt/bitcoin")
const EthereumBase = require("../ethereum-base")

const { createAddressObjectByHash, networks } = bitcoinUtils

class CcBurnRouter extends EthereumBase {
  constructor(connectionInfo, contractAddress) {
    super(connectionInfo)
    this.contractAddress = contractAddress
    this.contract = new this.web3Eth.Contract(CCBurnRouterABI, contractAddress)
  }

  static parseCcBurnEvent(event, sourceNetworkName = "bitcoin") {
    let network = networks[sourceNetworkName]
    const txInfo = this.extractEventTxInfo(event)
    const {
      userTargetAddress,
      userScript,
      scriptType,
      amount,
      burntAmount,
      lockerTargetAddress,
      lockerLockingScript,
      requestIdOfLocker,
      deadline,
    } = event.returnValues

    let address = createAddressObjectByHash(
      {
        addressType: addressTypes[scriptType],
        hash: Buffer.from(userScript.replace("0x", ""), "hex"),
      },
      network,
    ).address

    return {
      addressType: addressTypes[scriptType],
      addressScript: userScript.replace("0x", ""),
      address,
      requestIndex: requestIdOfLocker,
      amount,
      burntAmount,
      lockerTargetAddress,
      lockerLockingScript: lockerLockingScript.replace("0x", ""),
      userTargetAddress,
      deadline,
      txInfo,
    }
  }

  static parsePaidBurnEvent(event) {
    // const txInfo = this.extractEventTxInfo(event)
    const { bitcoinTxId, bitcoinTxOutputIndex, lockerTargetAddress, requestIdOfLocker } =
      event.returnValues

    return {
      bitcoinTxId: bitcoinTxId.replace("0x", ""),
      bitcoinTxOutputIndex,
      lockerTargetAddress,
      requestIndex: requestIdOfLocker,
    }
  }

  static parseBurnDisputeEvent(event) {
    // const txInfo = this.extractEventTxInfo(event)
    const { userTargetAddress, _lockerTargetAddress, lockerLockingScript, requestIdOfLocker } =
      event.returnValues

    return {
      lockerLockingScript,
      userTargetAddress,
      lockerTargetAddress: _lockerTargetAddress,
      requestIndex: requestIdOfLocker,
    }
  }

  static parseLockerDisputeEvent(event) {
    // const txInfo = this.extractEventTxInfo(event)
    const { _lockerTargetAddress, lockerLockingScript, _blockNumber, txId, amount } =
      event.returnValues

    return {
      txId: txId.replace("0x", ""),
      amount,
      lockerLockingScript,
      blockNumber: _blockNumber,
      lockerTargetAddress: _lockerTargetAddress,
    }
  }

  async getProtocolPercentageFee() {
    return this.contract.methods.protocolPercentageFee().call()
  }

  async getBitcoinFee() {
    return this.contract.methods.bitcoinFee().call()
  }

  async isTransferred(lockerTargetAddress, index) {
    return this.contract.methods.isTransferred(lockerTargetAddress, index).call()
  }

  async isUsedAsBurnProof(bitcoinTxId) {
    let txIdWith0x = `0x${Buffer.from(bitcoinTxId, "hex").reverse().toString("hex")}`
    return this.contract.methods.isUsedAsBurnProof(txIdWith0x).call()
  }

  async getBurnTransferDeadline() {
    return this.contract.methods.transferDeadline().call()
  }

  async getBurnEvents(fromBlock = 0) {
    let events = await this.contract.getPastEvents("CCBurn", {
      fromBlock,
    })
    return events.map((event) => CcBurnRouter.parseCcBurnEvent(event))
  }

  async getPaidBurnEvents(fromBlock = 0) {
    let events = await this.contract.getPastEvents("PaidCCBurn", {
      fromBlock,
    })
    return events.map((event) => CcBurnRouter.parsePaidBurnEvent(event))
  }

  async getBurnDisputeEvents(fromBlock = 0) {
    let events = await this.contract.getPastEvents("BurnDispute", {
      fromBlock,
    })
    return events.map((event) => CcBurnRouter.parseBurnDisputeEvent(event))
  }

  async getLockerDisputeEvents(fromBlock = 0) {
    let events = await this.contract.getPastEvents("LockerDispute", {
      fromBlock,
    })
    return events.map((event) => CcBurnRouter.parseLockerDisputeEvent(event))
  }

  // write functions

  async sendBurnProof(
    parsedTx,
    merkleProof,
    blockNumber,
    requestIndexes,
    voutIndexes,
    lockerLockingScript,
    blockFee,
    nonce = null,
  ) {
    try {
      // todo : fix value and get needed value
      let value = blockFee ? (+blockFee * 1.3).toFixed() : "100000000000000000"

      const gasAmount = await this.contract.methods
        .burnProof(
          parsedTx.version,
          parsedTx.vin,
          parsedTx.vout,
          parsedTx.locktime,
          blockNumber,
          merkleProof.intermediateNodes,
          merkleProof.transactionIndex,
          lockerLockingScript,
          requestIndexes, // requestIndexes
          voutIndexes, // vout indexes
        )
        .estimateGas({ from: this.currentAccount, value })

      let response = await this.contract.methods
        .burnProof(
          parsedTx.version,
          parsedTx.vin,
          parsedTx.vout,
          parsedTx.locktime,
          blockNumber,
          merkleProof.intermediateNodes,
          merkleProof.transactionIndex,
          lockerLockingScript,
          requestIndexes, // requestIndexes
          voutIndexes, // vout indexes
        )
        .send({ from: this.currentAccount, gas: gasAmount, value })

      return {
        success: response.status,
        txId: response.transactionHash,
      }
    } catch (error) {
      console.log("***********error******", JSON.stringify(error))
      return {
        success: false,
        message: error.message,
      }
    }
  }

  async disputeBurn(lockerLockingScript, arrayOfRequestIndexes, nonce = null) {
    try {
      const gasAmount = await this.contract.methods
        .disputeBurn(lockerLockingScript, arrayOfRequestIndexes)
        .estimateGas({ from: this.currentAccount })

      let response = await this.contract.methods
        .disputeBurn(lockerLockingScript, arrayOfRequestIndexes)
        .send({ from: this.currentAccount, gas: gasAmount })

      return {
        success: response.status,
        txId: response.transactionHash,
      }
    } catch (error) {
      console.log("***********error******", JSON.stringify(error))
      return {
        success: false,
        message: error.message,
      }
    }
  }

  async disputeLocker(lockerLockingScript, input, output, blockFee, nonce = null) {
    try {
      // todo : fix value and get needed value
      let value = blockFee ? (+blockFee * 1.3).toFixed() : "100000000000000000"

      console.log(
        JSON.stringify(
          {
            lockerLockingScript,
            ver: [input.parsedTx.version, output.parsedTx.version],
            i_vin: input.parsedTx.vin,
            i_vout: input.parsedTx.vout,
            o_vin: output.parsedTx.vin,
            o_vout: output.parsedTx.vout,
            locktime: [input.parsedTx.locktime, output.parsedTx.locktime],
            intermediateNodes: input.merkleProof.intermediateNodes,
            numbers: [output.index, input.merkleProof.transactionIndex, input.blockNumber],
          },
          null,
          2,
        ),
      )
      const gasAmount = await this.contract.methods
        .disputeLocker(
          lockerLockingScript,
          [input.parsedTx.version, output.parsedTx.version],
          input.parsedTx.vin,
          input.parsedTx.vout,
          output.parsedTx.vin,
          output.parsedTx.vout,
          [input.parsedTx.locktime, output.parsedTx.locktime],
          input.merkleProof.intermediateNodes,
          [output.index, input.merkleProof.transactionIndex, input.blockNumber],
        )
        .estimateGas({ from: this.currentAccount, value })

      let response = await this.contract.methods
        .disputeLocker(
          lockerLockingScript,
          [input.parsedTx.version, output.parsedTx.version],
          input.parsedTx.vin,
          input.parsedTx.vout,
          output.parsedTx.vin,
          output.parsedTx.vout,
          [input.parsedTx.locktime, output.parsedTx.locktime],
          input.merkleProof.intermediateNodes,
          [output.index, input.merkleProof.transactionIndex, input.blockNumber],
        )
        .send({ from: this.currentAccount, gas: gasAmount, value })

      return {
        success: response.status,
        txId: response.transactionHash,
      }
    } catch (error) {
      console.log("***********error******", JSON.stringify(error))
      return {
        success: false,
        message: error.message,
      }
    }
  }
}
module.exports = CcBurnRouter

/* eslint-disable class-methods-use-this */
const EthereumBase = require("../ethereum-base");
const { CCExchangeRouterABI } = require("@sinatdt/configs").teleswap.ABI;

class CcExchangeRouter extends EthereumBase {
  constructor(connectionInfo, contractAddress) {
    super(connectionInfo);
    this.contractAddress = contractAddress;
    this.contract = new this.web3Eth.Contract(
      CCExchangeRouterABI,
      contractAddress
    );
  }

  async getProtocolPercentageFee() {
    return this.contract.methods.protocolPercentageFee().call();
  }

  async isUsed(txId) {
    let txIdWith0x = `0x${Buffer.from(txId, "hex").reverse().toString("hex")}`;
    let isUsed = await this.contract.methods.isRequestUsed(txIdWith0x).call();
    return isUsed;
  }

  async sendExchangeRequest(
    lockerScript,
    parsedTx,
    merkleProof,
    blockNumber,
    blockFee,
    nonce = undefined
  ) {
    let value = blockFee ? (+blockFee * 1.3).toFixed() : "100000000000000000";
    const gasAmount = await this.contract.methods
      .ccExchange(
        parsedTx.version,
        parsedTx.vin,
        parsedTx.vout,
        parsedTx.locktime,
        blockNumber,
        merkleProof.intermediateNodes,
        merkleProof.transactionIndex,
        `0x${lockerScript}`
      )
      .estimateGas({ from: this.currentAccount, value });

    let response = await this.contract.methods
      .ccExchange(
        parsedTx.version,
        parsedTx.vin,
        parsedTx.vout,
        parsedTx.locktime,
        blockNumber,
        merkleProof.intermediateNodes,
        merkleProof.transactionIndex,
        `0x${lockerScript}`
      )
      .send({ from: this.currentAccount, gas: gasAmount, value, nonce })
      .then((recipient) => ({
        success: recipient.status,
        txId: recipient.transactionHash,
      }));

    return response;
  }
}
module.exports = CcExchangeRouter;

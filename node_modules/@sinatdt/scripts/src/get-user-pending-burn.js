/* eslint-disable no-underscore-dangle */
const { getWeb3Eth } = require('./helper')
const { BitcoinRelay } = require('@sinatdt/contracts-helper').contracts
const { BitcoinInterface } = require('@sinatdt/bitcoin')

let { contractsInfo } = require('@sinatdt/configs').teleswap
const polygonContracts = contractsInfo.polygon

/**
 *
 * @param {Object} input
 * @param {Object[]} input.userBurnRequests
 * @param {number} input.userBurnRequests[].amount
 * @param {string} input.userBurnRequests[].address
 * @param {String} input.lockerAddresses
 * @param {*} input.targetNetworkConnectionInfo
 * @param {Boolean} input.testnet
 * @returns
 */
async function getUserPendingBurns({
  userBurnRequests,
  lockerAddresses,
  targetNetworkConnectionInfo,
  testnet = false,
}) {
  let sourceNetworkConnection = {
    api: {
      enabled: true,
      provider: 'BlockStream',
    },
  }
  let sourceNetworkName = testnet ? 'bitcoin_testnet' : 'bitcoin'
  const btcInterface = new BitcoinInterface(sourceNetworkConnection, sourceNetworkName)

  let contracts = testnet ? polygonContracts.testnet : polygonContracts.mainnet
  let { connectionConfig } = getWeb3Eth(targetNetworkConnectionInfo)

  let userAddresses = new Set(userBurnRequests.map((r) => r.address))

  const relay = new BitcoinRelay(connectionConfig, contracts.relayAddress)

  let numberOfConfirmations = await relay.getNumberOfConfirmations()
  let lastBlock = await relay.lastSubmittedHeight()
  let confirmedTxs = await btcInterface.getLockersBurnTransactions(
    lockerAddresses,
    +lastBlock - 10 * +numberOfConfirmations,
  )

  confirmedTxs = confirmedTxs.filter((rs) =>
    rs.burnInfo.receivers.find((r) => userAddresses.has(r.address)),
  )

  let processedBurns = []
  let unprocessedBurns = []
  userBurnRequests.forEach((br) => {
    let receiver
    let txIndex = confirmedTxs.findIndex((rs) => {
      receiver = rs.burnInfo.receivers.find((r) => br.address === r.address)
      return receiver
    })
    if (receiver && +receiver.value === br.amount) {
      confirmedTxs.splice(txIndex, 1)
      processedBurns.push({ ...br, requests: confirmedTxs[txIndex] })
    } else {
      unprocessedBurns.push(br)
    }
  })

  return {
    processedBurns,
    unprocessedBurns,
  }
}

module.exports = getUserPendingBurns

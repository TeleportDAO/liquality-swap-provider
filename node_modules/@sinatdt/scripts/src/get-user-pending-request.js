/* eslint-disable no-underscore-dangle */
const { getWeb3Eth } = require("./helper");
const { CcTransferRouter, CcExchangeRouter, LendingRouter, BitcoinRelay } =
  require("@sinatdt/contracts-helper").contracts;
const { BitcoinInterface } = require("@sinatdt/bitcoin");

let { contractsInfo } = require("@sinatdt/configs").teleswap;
const polygonContracts = contractsInfo.polygon;

async function getUserPendingRequests({
  ethClientAddress,
  lockerAddresses,
  targetNetworkConnectionInfo,
  testnet = false,
}) {
  let sourceNetworkConnection = {
    api: {
      enabled: true,
      provider: "BlockStream",
    },
  };
  let sourceNetworkName = testnet ? "bitcoin_testnet" : "bitcoin";
  let contracts = testnet ? polygonContracts.testnet : polygonContracts.mainnet;
  let { connectionConfig } = getWeb3Eth(targetNetworkConnectionInfo);

  const relay = new BitcoinRelay(connectionConfig, contracts.relayAddress);

  const ccTransfer = new CcTransferRouter(
    connectionConfig,
    contracts.ccTransferAddress
  );
  const ccExchange = new CcExchangeRouter(
    connectionConfig,
    contracts.ccExchangeAddress
  );
  const lending = new LendingRouter(connectionConfig, contracts.lendingAddress);

  console.log(ethClientAddress);
  console.log(lockerAddresses);

  let numberOfConfirmations = await relay.getNumberOfConfirmations();
  let lastBlock = await relay.lastSubmittedHeight();
  const btcInterface = new BitcoinInterface(
    sourceNetworkConnection,
    sourceNetworkName
  );
  let confirmedRequests = await btcInterface.getTeleporterRequests(
    lockerAddresses,
    +lastBlock - 10 * +numberOfConfirmations
  );
  let pendingRequests = await btcInterface.getTeleporterRequests(
    lockerAddresses,
    undefined,
    undefined,
    true
  );

  confirmedRequests = confirmedRequests.filter(
    (rs) =>
      rs.request.data.recipientAddress.toLowerCase() ===
      ethClientAddress.toLowerCase()
  );
  pendingRequests = pendingRequests.filter(
    (rs) =>
      rs.request.data.recipientAddress.toLowerCase() ===
      ethClientAddress.toLowerCase()
  );

  let isUsed = [];
  confirmedRequests.forEach(async (data, index) => {
    switch (data.request.data.requestType) {
      case "transfer":
        isUsed[index] = ccTransfer.isUsed(data.transaction.txId);
        break;
      case "exchange":
        isUsed[index] = ccExchange.isUsed(data.transaction.txId);
        break;
      case "lend":
      case "borrow":
        isUsed[index] = lending.isUsed(data.transaction.txId);
        break;
      default: {
        // ignore
        console.error(data);
      }
    }
  });

  isUsed = await Promise.all(isUsed);

  confirmedRequests = confirmedRequests.filter((rs, index) => !isUsed[index]);

  return {
    confirmedRequests,
    pendingRequests,
  };
}

module.exports = getUserPendingRequests;

const { BitcoinInterface } = require("@sinatdt/bitcoin")
const { BigNumber } = require("bignumber.js")
const { BitcoinRelay, CcTransferRouter, CcExchangeRouter, CcBurnRouter, LockerContract } =
  require("@sinatdt/contracts-helper").contracts

let { contractsInfo } = require("@sinatdt/configs").teleswap

const polygonContracts = contractsInfo.polygon

const { getAxiosInstance } = require("./utils/tools")
const { getWeb3Eth } = require("./helper")

// const calculateFee = async (
//   amount: any,
//   type = 'transfer',
//   isInstant = false,
//   calculateMemData: any,
//   teleporterFeeRatio = 2,
//   minimumFee = 0.00001,
// ) => {
//   const {
//     price,
//     gasUsed,
//     gasPrize,
//     lastRelayBlockFee,
//     protocolPercentageFeeCCTransfer,
//     protocolPercentageFeeCCExchange,
//     protocolPercentageFeeCCBurn,
//     bitcoinFeeCCBurn,
//     lockerPercentageFee,
//     feeRate,
//   } = calculateMemData

//   const protocolPercentageFee =
//     type === 'transfer'
//       ? protocolPercentageFeeCCTransfer
//       : type === 'burn'
//       ? protocolPercentageFeeCCBurn
//       : protocolPercentageFeeCCExchange
//   const _gasPrize = gasPrize?.toNumber()
//   const _lastRelayBlockFee = lastRelayBlockFee?.toNumber()
//   const teleportFee = new BigNumber(gasUsed).multipliedBy(_gasPrize).dividedBy(1e18).toFixed()

//   const relayFee = new BigNumber(_lastRelayBlockFee).dividedBy(1e18).toFixed()

//   const totalFee = new BigNumber(teleportFee).plus(relayFee).toFixed()
//   const toBtcRate = price

//   const calculatedFeeInBTC = BigNumber.maximum(
//     minimumFee,
//     new BigNumber(totalFee).multipliedBy(toBtcRate),
//   ).toFixed()

//   const teleporterPercentageFee = BigNumber.maximum(
//     0.01,
//     new BigNumber(calculatedFeeInBTC)
//       .dividedBy(amount)
//       .multipliedBy(100)
//       .multipliedBy(teleporterFeeRatio),
//   ).toFixed(2)

//   const teleporterFeeInBTC = new BigNumber(teleporterPercentageFee)
//     .dividedBy(100)
//     .multipliedBy(amount)
//     .toFixed(8)
//   const protocolFeeInBTC = new BigNumber(protocolPercentageFee)
//     .dividedBy(100)
//     .multipliedBy(amount)
//     .toFixed(8)
//   const lockerFeeInBTC = new BigNumber(lockerPercentageFee)
//     .dividedBy(100)
//     .multipliedBy(amount)
//     .toFixed(8)

//   const receivedAmount = new BigNumber(amount)
//     .minus(teleporterFeeInBTC)
//     .minus(protocolFeeInBTC)
//     .minus(lockerFeeInBTC)
//     .toFixed(8)

//   //
//   const instantSettlementFeeInBTC = lockerFeeInBTC
//   const instantSettlementPercentageFee = lockerPercentageFee

//   // protocolFee
//   //
//   // the deciaml must be 8
//   const _amount = new BigNumber(amount)
//   const _protocolFeeInBTC = new BigNumber(protocolPercentageFee)
//     .multipliedBy(_amount)
//     .dividedBy(100)
//   // the divide is redundant (every BTC amount must have 8 dec)
//   // const bitcoinFeeCCBurnInBTC = new BigNumber(bitcoinFeeCCBurn).dividedBy(1e8);
//   const bitcoinFeeCCBurnInBTC = new BigNumber(bitcoinFeeCCBurn)

//   const remainedAmountAfterProtocolAndBitcoinFee = new BigNumber(_amount)
//     .minus(_protocolFeeInBTC)
//     .minus(bitcoinFeeCCBurnInBTC)
//   const lockerFeeOfBurnInBTC = new BigNumber(lockerPercentageFee)
//     .multipliedBy(remainedAmountAfterProtocolAndBitcoinFee)
//     .dividedBy(100)

//   const finalRemainedBurnAmount = new BigNumber(remainedAmountAfterProtocolAndBitcoinFee)
//     .minus(lockerFeeOfBurnInBTC)
//     .toNumber()
//   const burnFeeInBTC = _amount.minus(finalRemainedBurnAmount)

//   const txFeeEstimate = ((type === 'transfer' ? 200 : 300) * feeRate) / 1e8
//   return {
//     teleportFee,
//     relayFee,
//     totalFee,

//     amount,
//     receivedAmount: type === 'burn' ? finalRemainedBurnAmount : receivedAmount,
//     teleporterPercentageFee,
//     teleporterFeeInBTC,
//     protocolPercentageFee,
//     protocolFeeInBTC,
//     lockerPercentageFee,
//     lockerFeeInBTC,
//     instantSettlementFeeInBTC,
//     instantSettlementPercentageFee,

//     totalFeeInBTC: new BigNumber(lockerFeeInBTC)
//       .plus(protocolFeeInBTC)
//       .plus(teleporterFeeInBTC)
//       .plus(txFeeEstimate)
//       .plus(isInstant ? instantSettlementFeeInBTC : 0)
//       .toNumber(),

//     totalPercentageFee: new BigNumber(lockerPercentageFee)
//       .plus(protocolPercentageFee)
//       .plus(teleporterPercentageFee)
//       .plus(txFeeEstimate)
//       .plus(isInstant ? instantSettlementPercentageFee : 0)
//       .toNumber(),

//     burnFeeInBTC,
//     txFeeStimate: txFeeEstimate,
//   }
// }

async function getFeeParams({ targetNetworkConnectionInfo, testnet = false }) {
  let sourceNetworkConnection = {
    api: {
      enabled: true,
      provider: "BlockStream",
    },
  }
  let sourceNetworkName = testnet ? "bitcoin_testnet" : "bitcoin"
  const btcInterface = new BitcoinInterface(sourceNetworkConnection, sourceNetworkName)

  let contracts = testnet ? polygonContracts.testnet : polygonContracts.mainnet

  let api = getAxiosInstance({ baseUrl: "https://api.binance.com/api/v3/" })
  let price = (await api.get("/ticker/price?symbol=MATICBTC"))?.data.price
  if (!price) {
    throw new Error("cant get price")
  }
  price = +price
  let { baseEth, connectionConfig } = getWeb3Eth(targetNetworkConnectionInfo)
  let relay = new BitcoinRelay(connectionConfig, contracts.relayAddress)
  let ccTransfer = new CcTransferRouter(connectionConfig, contracts.ccTransferAddress)
  let ccExchange = new CcExchangeRouter(connectionConfig, contracts.ccExchangeAddress)
  let locker = new LockerContract(connectionConfig, contracts.lockerAddress)
  let ccBurn = new CcBurnRouter(connectionConfig, contracts.ccBurnAddress)

  let lastRelayBlockFee = await relay.getLastBlockFee()
  let relayFee = new BigNumber(lastRelayBlockFee).dividedBy(1e18).toFixed()

  const gasUsed = new BigNumber(460000 * (1 + 0.01)).toFixed()
  let gasPrize = await baseEth.web3Eth.getGasPrice()
  let teleportFee = new BigNumber(gasUsed).multipliedBy(gasPrize).dividedBy(1e18).toFixed()

  const protocolPercentageFeeCCTransfer =
    +((await ccTransfer?.getProtocolPercentageFee()) || 0) / 100
  const protocolPercentageFeeCCExchange =
    +((await ccExchange?.getProtocolPercentageFee()) || 0) / 100
  const protocolPercentageFeeCCBurn = +((await ccBurn?.getProtocolPercentageFee()) || 0) / 100

  const burnBitcoinFee = +((await ccBurn?.getBitcoinFee()) || 0)
  const lockerPercentageFee = +((await locker?.getLockerPercentageFee()) || 0) / 100

  const feeRate = +((await btcInterface.getFeeRate("normal")) || 0)

  return {
    price,
    gasPrize,

    lastRelayBlockFee,

    relayFee,
    teleportFee,

    protocolPercentageFeeCCTransfer,
    protocolPercentageFeeCCExchange,
    protocolPercentageFeeCCBurn,

    burnBitcoinFee,

    lockerPercentageFee,

    feeRate,
  }
}

async function calculateTransferFee({ amount, feeInfo, minimumFee, teleporterFeeRatio = 2, type }) {
  const {
    price,
    relayFee,
    teleportFee,
    protocolPercentageFeeCCTransfer,
    protocolPercentageFeeCCExchange,
    lockerPercentageFee,
    feeRate,
  } = feeInfo

  let totalFeeForTeleporter = new BigNumber(teleportFee).plus(relayFee).toFixed()
  let toBtcRate = price

  let calculatedTeleporterFee = BigNumber.maximum(
    minimumFee,
    new BigNumber(totalFeeForTeleporter).multipliedBy(toBtcRate),
  )
    .multipliedBy(teleporterFeeRatio)
    .toFixed()

  let teleporterPercentageFee = BigNumber.maximum(
    0.01,
    new BigNumber(calculatedTeleporterFee).dividedBy(amount).multipliedBy(100),
  ).toFixed(2)

  let protocolPercentageFee =
    type === "transfer" ? protocolPercentageFeeCCTransfer : protocolPercentageFeeCCExchange

  let teleporterFeeInBTC = new BigNumber(teleporterPercentageFee)
    .dividedBy(100)
    .multipliedBy(amount)
    .toFixed(8)
  let protocolFeeInBTC = new BigNumber(protocolPercentageFee)
    .dividedBy(100)
    .multipliedBy(amount)
    .toFixed(8)
  let lockerFeeInBTC = new BigNumber(lockerPercentageFee)
    .dividedBy(100)
    .multipliedBy(amount)
    .toFixed(8)

  let TransactionFeeInBTC = new BigNumber(type === "transfer" ? 200 : 300)
    .multipliedBy(feeRate)
    .dividedBy(1e8)
    .toFixed(8)

  let totalFeeInBTC = new BigNumber(teleporterFeeInBTC)
    .plus(protocolFeeInBTC)
    .plus(lockerFeeInBTC)
    .plus(TransactionFeeInBTC)
    .toFixed(8)

  let receivedAmount = new BigNumber(amount).minus(totalFeeInBTC).toFixed(8)

  return {
    teleporterPercentageFee,
    protocolPercentageFee,
    lockerPercentageFee,

    teleporterFeeInBTC,
    protocolFeeInBTC,
    lockerFeeInBTC,
    TransactionFeeInBTC,

    totalFeeInBTC,
    receivedAmount,
  }
}

async function calculateBurnFee({ amount, feeInfo }) {
  const { protocolPercentageFeeCCBurn, burnBitcoinFee, lockerPercentageFee } = feeInfo

  let protocolPercentageFee = protocolPercentageFeeCCBurn

  let protocolFeeInBTC = new BigNumber(protocolPercentageFee)
    .dividedBy(100)
    .multipliedBy(amount)
    .toFixed(8)

  let burnBitcoinFeeInBTC = new BigNumber(burnBitcoinFee).dividedBy(1e8).toFixed(8)

  let realBtcAmount = new BigNumber(amount).minus(burnBitcoinFeeInBTC).toFixed(8)
  let lockerFeeInBTC = new BigNumber(lockerPercentageFee)
    .dividedBy(100)
    .multipliedBy(realBtcAmount)
    .toFixed(8)

  const instantSettlementFeeInBTC = lockerFeeInBTC
  const instantSettlementPercentageFee = lockerPercentageFee

  let totalFeeInBTC = new BigNumber(protocolFeeInBTC)
    .plus(burnBitcoinFeeInBTC)
    .plus(lockerFeeInBTC)
    .plus(instantSettlementFeeInBTC)
    .toFixed(8)

  let receivedAmount = new BigNumber(amount).minus(totalFeeInBTC).toFixed(8)

  return {
    protocolPercentageFee,
    lockerPercentageFee,
    instantSettlementPercentageFee,

    protocolFeeInBTC,
    burnBitcoinFeeInBTC,
    lockerFeeInBTC,
    instantSettlementFeeInBTC,

    totalFeeInBTC,
    receivedAmount,
  }
}

async function calculateFee({
  amount,
  type = "transfer",
  teleporterFeeRatio = 2,
  minimumFee = 0.00001,
  targetNetworkConnectionInfo,
  testnet = false,
  feeParams = undefined,
}) {
  let feeInfo =
    feeParams ||
    (await getFeeParams({
      targetNetworkConnectionInfo,
      testnet,
    }))

  switch (type) {
    case "transfer":
    case "exchange":
      return calculateTransferFee({ amount, feeInfo, minimumFee, teleporterFeeRatio, type })
    case "burn":
      return calculateBurnFee({ amount, feeInfo })
    default:
      throw new Error("type is incorrect")
  }
}

module.exports = { calculateFee, getFeeParams }

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusManager = void 0;
var types_1 = require("../types");
var utils_1 = require("../utils/utils");
var utils_2 = require("./utils");
/**
 * Manages status updates of a route and provides various functions for tracking processes
 * @param  {Route} route  The route this StatusManger belongs to.
 * @param  {InternalExecutionSettings} settings   The ExecutionSettings for this route.
 * @param  {InternalUpdateRouteCallback} internalUpdateRouteCallback  Internal callback to propage route changes.
 * @return {StatusManager}       An instance of StatusManager.
 */
var StatusManager = /** @class */ (function () {
    function StatusManager(route, settings, internalUpdateRouteCallback) {
        var _this = this;
        this.shouldUpdate = true;
        /**
         * Initializes the execution object of a Step.
         * @param  {Step} step  The current step in execution
         * @return {Execution}       The initialized execution object for this step and a function to update this step
         */
        this.initExecutionObject = function (step) {
            var currentExecution = step.execution || (0, utils_1.deepClone)(types_1.emptyExecution);
            if (!step.execution) {
                step.execution = currentExecution;
                _this.updateStepInRoute(step);
            }
            return currentExecution;
        };
        /**
         * Create and push a new process into the execution.
         * @param  {ProcessType} type Type of the process. Used to identify already existing processes.
         * @param  {Step} step The step that should contain the new process.
         * @param  {Status} status By default created procces is set to the STARTED status. We can override new process with the needed status.
         * @return {Process}
         */
        this.findOrCreateProcess = function (type, step, status) {
            if (!step.execution || !step.execution.process) {
                throw new Error("Execution hasn't been initialized.");
            }
            var process = step.execution.process.find(function (p) { return p.type === type; });
            if (process) {
                return process;
            }
            var newProcess = {
                type: type,
                startedAt: Date.now(),
                message: (0, utils_2.getProcessMessage)(type, status !== null && status !== void 0 ? status : 'STARTED'),
                status: status !== null && status !== void 0 ? status : 'STARTED',
            };
            step.execution.process.push(newProcess);
            _this.updateStepInRoute(step);
            return newProcess;
        };
        /**
         * Update a process object.
         * @param  {Step} step The step where the process should be updated
         * @param  {ProcessType} type  The process type to update
         * @param  {Status} status The status the process gets.
         * @param  {object} [params]   Additional parameters to append to the process.
         * @return {Process} The update process
         */
        this.updateProcess = function (step, type, status, params) {
            var _a;
            var currentProcess = (_a = step === null || step === void 0 ? void 0 : step.execution) === null || _a === void 0 ? void 0 : _a.process.find(function (p) { return p.type === type; });
            if (!currentProcess) {
                throw new Error("Can't find a process for the given type.");
            }
            switch (status) {
                case 'CANCELLED':
                    currentProcess.doneAt = Date.now();
                    break;
                case 'FAILED':
                    currentProcess.doneAt = Date.now();
                    break;
                case 'DONE':
                    currentProcess.doneAt = Date.now();
                    break;
                default:
                    break;
            }
            currentProcess.status = status;
            currentProcess.message = (0, utils_2.getProcessMessage)(type, status);
            // set extra parameters or overwritte the standard params set in the switch statement
            if (params) {
                for (var _i = 0, _b = Object.entries(params); _i < _b.length; _i++) {
                    var _c = _b[_i], key = _c[0], value = _c[1];
                    currentProcess[key] = value;
                }
            }
            _this.updateStepInRoute(step); // updates the step in the route
            return currentProcess;
        };
        /**
         * Remove a process from the execution
         * @param  {Step} step The step where the process should be removed from
         * @param  {ProcessType} type  The process type to remove
         * @return {void}
         */
        this.removeProcess = function (step, type) {
            if (!step.execution) {
                throw new Error("Execution hasn't been initialized.");
            }
            var index = step.execution.process.findIndex(function (p) { return p.type === type; });
            step.execution.process.splice(index, 1);
            _this.updateStepInRoute(step);
        };
        this.updateStepInRoute = function (step) {
            if (!_this.shouldUpdate) {
                return;
            }
            var stepIndex = _this.route.steps.findIndex(function (routeStep) { return routeStep.id === step.id; });
            if (stepIndex === -1) {
                throw new Error("Couldn't find a step to update.");
            }
            _this.route.steps[stepIndex] = Object.assign(_this.route.steps[stepIndex], step);
            _this.settings.updateCallback(_this.route);
            _this.internalUpdateRouteCallback(_this.route);
        };
        this.route = route;
        this.settings = settings;
        this.internalUpdateRouteCallback = internalUpdateRouteCallback;
    }
    /**
     * Updates the execution object of a Step.
     * @param  {Step} step  The current step in execution
     * @param  {Status} status  The status for the execution
     * @param  {Receipt} receipt Optional. Information about received tokens
     * @return {Step}       The step with the updated execution object
     */
    StatusManager.prototype.updateExecution = function (step, status, receipt) {
        if (!step.execution) {
            throw Error("Can't update empty execution.");
        }
        step.execution.status = status;
        if (receipt) {
            step.execution.fromAmount = receipt.fromAmount;
            step.execution.toAmount = receipt.toAmount;
            step.execution.toToken = receipt.toToken;
        }
        this.updateStepInRoute(step);
        return step;
    };
    StatusManager.prototype.setShouldUpdate = function (value) {
        this.shouldUpdate = value;
    };
    return StatusManager;
}());
exports.StatusManager = StatusManager;
